{"version":3,"sources":["../src/index.ts"],"names":["leb","blake2b","base32","base32Function","uint8arrays","Protocol","Network","defaultNetwork","MAIN","payloadHashLength","addressHash","ingest","Address","str","network","length","Error","_protocol","_network","slice","encode","addr","equals","bigintToArray","v","tmp","BigInt","toString","fromString","getChecksum","validateChecksum","expect","digest","compare","newAddress","protocol","payload","protocolByte","Uint8Array","concat","newIDAddress","id","ID","unsigned","newActorAddress","data","ACTOR","newSecp256k1Address","pubkey","SECP256K1","newBLSAddress","BLS","decode","address","checkAddressString","parseInt","raw","substring","payloadChecksum","checksum","addressObj","String","bytes","newFromString","validateAddressString","addressString","error","idFromAddress"],"mappings":"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","sourcesContent":["import * as leb from 'leb128'\nimport { blake2b } from 'blakejs'\nimport { base32 as base32Function } from './base32'\nimport * as uint8arrays from 'uint8arrays'\nimport { Protocol } from './protocol'\nimport { Network } from './network'\n\nexport * from './network'\nexport * from './protocol'\n\nconst defaultNetwork = Network.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// PayloadHashLength defines the hash length taken over addresses using the\n// Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\nfunction addressHash (ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly str: Uint8Array\n  readonly _protocol: Protocol\n  readonly _network: Network\n\n  constructor(str: Uint8Array, network: Network = defaultNetwork) {\n    if (!str || str.length < 1) throw new Error('Missing str in address')\n    this.str = str\n    this._protocol = this.str[0] as Protocol\n    if (!Protocol[this._protocol]) {\n      throw new Error(`Invalid protocol ${this._protocol}`)\n    }\n    this._network = network\n  }\n\n  network(): Network {\n    return this._network\n  }\n\n  protocol(): Protocol {\n    return this._protocol\n  }\n\n  payload(): Uint8Array {\n    return this.str.slice(1, this.str.length)\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"network\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default network prefix \"f\" (mainnet).\n   */\n  toString (): string {\n    return encode(this._network, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"str\" property matches byte for byte.\n   */\n  equals (addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.str, addr.str)\n  }\n}\n\nexport function bigintToArray(v: string | BigInt | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, 4)\n}\n\nexport function validateChecksum(\n  ingest: string | Uint8Array,\n  expect: Uint8Array\n) {\n  const digest = getChecksum(ingest)\n  return uint8arrays.compare(digest, expect)\n}\n\nexport function newAddress(protocol: Protocol, payload: Uint8Array, network: Network = defaultNetwork): Address {\n  const protocolByte = new Uint8Array([protocol])\n  return new Address(uint8arrays.concat([protocolByte, payload]), network)\n}\n\nexport function newIDAddress(id: number|string, network: Network = defaultNetwork): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), network)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress (data: Uint8Array): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data))\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address (pubkey: Uint8Array): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey))\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress (pubkey: Uint8Array): Address {\n  return newAddress(Protocol.BLS, pubkey)\n}\n\nexport function decode(address: string): Address {\n  checkAddressString(address)\n\n  const network = address.slice(0, 1) as Network\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address.slice(1, 2)) as Protocol\n  const raw = address.substring(2, address.length)\n  const protocolByte = new Uint8Array([protocol])\n\n  if (protocol === Protocol.ID) {\n    return newIDAddress(raw, network)\n  }\n\n  const payloadChecksum = base32.decode(raw)\n  const length = payloadChecksum.length\n  const payload = payloadChecksum.slice(0, length - 4)\n  const checksum = payloadChecksum.slice(length - 4, length)\n  if (validateChecksum(uint8arrays.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\")\n  }\n\n  const addressObj = newAddress(protocol, payload, network)\n  if (encode(network, addressObj) !== address)\n    throw Error(`Did not encode this address properly: ${address}`)\n\n  return addressObj\n}\n\nexport function encode(network: string, address: Address): string {\n  if (!address || !address.str) throw Error('Invalid address')\n  const payload = address.payload()\n\n  switch (address.protocol()) {\n    case 0: {\n      return (\n        network +\n        String(address.protocol()) +\n        leb.unsigned.decode(address.payload())\n      )\n    }\n    default: {\n      const protocolByte = new Uint8Array([address.protocol()])\n      const checksum = getChecksum(uint8arrays.concat([protocolByte, payload]))\n      const bytes = uint8arrays.concat([payload, checksum])\n      return String(network) + String(address.protocol()) + base32.encode(bytes)\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string) {\n  if (!address) throw Error('No bytes to validate.')\n  if (address.length < 3) throw Error('Address is too short to validate.')\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address network.')\n  }\n\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address[1]) as Protocol\n  switch (protocol) {\n    case Protocol.ID: {\n      if (address.length > 22) throw Error('Invalid ID address length.')\n      break\n    }\n    case Protocol.SECP256K1: {\n      if (address.length !== 41)\n        throw Error('Invalid secp256k1 address length.')\n      break\n    }\n    case Protocol.ACTOR: {\n      if (address.length !== 41) throw Error('Invalid Actor address length.')\n      break\n    }\n    case Protocol.BLS: {\n      if (address.length !== 86) throw Error('Invalid BLS address length.')\n      break\n    }\n    default: {\n      throw new Error('Invalid address protocol.')\n    }\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress (address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  Network,\n  Protocol\n}\n"],"file":"index.js"}