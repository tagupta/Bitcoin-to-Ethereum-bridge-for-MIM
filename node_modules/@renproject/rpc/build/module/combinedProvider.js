var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getRenNetworkDetails, NullLogger, RenNetwork, } from "@renproject/interfaces";
import { RenVMProvider as V1Provider } from "./v1";
import { RenVMProvider as V2Provider } from "./v2";
const isV1Selector = (selector) => {
    return ([
        "BTC0Btc2Eth",
        "BTC0Eth2Btc",
        "ZEC0Zec2Eth",
        "ZEC0Eth2Zec",
        "BCH0Bch2Eth",
        "BCH0Eth2Bch",
    ].indexOf(selector) >= 0);
};
export class CombinedProvider {
    constructor(network, logger = NullLogger) {
        this.selector = (params) => {
            const v1Selector = this.v1 && this.v1.selector(params);
            return v1Selector && isV1Selector(v1Selector)
                ? v1Selector
                : this.v2.selector(params);
        };
        this.version = (selector) => (isV1Selector(selector) ? 1 : 2);
        this.mintTxHash = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.mintTxHash(params)
            : this.v2.mintTxHash(params);
        this.submitMint = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.submitMint(params)
            : this.v2.submitMint(params);
        this.burnTxHash = (params) => {
            if (isV1Selector(params.selector)) {
                throw new Error(`Fetching burn txHash is not supported for ${params.selector}`);
            }
            return this.v2.burnTxHash(params);
        };
        this.submitBurn = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.submitBurn(params)
            : this.v2.submitBurn(params);
        this.queryMintOrBurn = (selector, utxoTxHash, retries) => this.v1 && isV1Selector(selector)
            ? this.v1.queryMintOrBurn(selector, utxoTxHash, retries)
            : this.v2.queryMintOrBurn(selector, utxoTxHash, retries);
        this.waitForTX = (selector, utxoTxHash, onStatus, cancelRequested, timeout) => this.v1 && isV1Selector(selector)
            ? this.v1.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout)
            : this.v2.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout);
        /**
         * selectPublicKey fetches the key for the RenVM shard handling
         * the provided contract.
         *
         * @returns The key hash (20 bytes) as a string.
         */
        this.selectPublicKey = (selector, assetOrChain) => this.v1 && isV1Selector(selector)
            ? this.v1.selectPublicKey(selector, assetOrChain)
            : this.v2.selectPublicKey(selector, assetOrChain);
        /**
         * Used to query what network a custom provider is connected to. LockAndMint
         * and BurnAndRelease use this to configure their chain parameters.
         */
        this.getNetwork = (selector) => this.v1 && isV1Selector(selector)
            ? this.v1.getNetwork(selector)
            : this.v2.getNetwork(selector);
        this.getConfirmationTarget = (selector, chain) => __awaiter(this, void 0, void 0, function* () {
            return this.v1 && isV1Selector(selector)
                ? this.v1.getConfirmationTarget(selector, chain)
                : this.v2.getConfirmationTarget(selector, chain);
        });
        this.estimateTransactionFee = (asset, lockChain, hostChain) => __awaiter(this, void 0, void 0, function* () { return this.v2.estimateTransactionFee(asset, lockChain, hostChain); });
        this.network = getRenNetworkDetails(network);
        if (this.network.name === RenNetwork.Mainnet ||
            this.network.name === RenNetwork.Testnet) {
            this.v1 = new V1Provider(this.network, undefined, logger);
        }
        this.v2 = new V2Provider(this.network, undefined, logger);
        // Default to the v2 network.
        this.sendMessage = this.v2.sendMessage;
    }
}
//# sourceMappingURL=combinedProvider.js.map