"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenVMProvider = exports.generateMintTxHash = void 0;
const interfaces_1 = require("@renproject/interfaces");
const provider_1 = require("@renproject/provider");
const utils_1 = require("@renproject/utils");
const immutable_1 = require("immutable");
const methods_1 = require("./methods");
const unmarshal_1 = require("./unmarshal");
const value_1 = require("./value");
const generateMintTxHash = (selector, encodedID, deposit, logger = interfaces_1.NullLogger) => {
    // Type validation
    utils_1.assertType("string", { encodedID, deposit });
    const message = `txHash_${selector}_${encodedID}_${deposit}`;
    const digest = utils_1.keccak256(Buffer.from(message));
    logger.debug("Mint txHash", utils_1.toBase64(digest), message);
    return digest;
};
exports.generateMintTxHash = generateMintTxHash;
class RenVMProvider {
    constructor(network, provider, logger = interfaces_1.NullLogger) {
        this.version = () => 1;
        this.selector = ({ asset, from, to, }) => {
            return `${asset}0${from.legacyName || from.name}2${to.legacyName || from.name}`;
        };
        this.queryBlock = async (blockHeight, retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryBlock, { blockHeight }, retry);
        this.queryBlocks = async (blockHeight, n, retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryBlocks, { blockHeight, n }, retry);
        this.submitTx = async (tx, retry) => this.sendMessage(methods_1.RPCMethod.MethodSubmitTx, { tx }, retry);
        this.queryTx = async (txHash, retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryTx, { txHash }, retry);
        this.queryTxs = async (tags, page, pageSize, txStatus, retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryTxs, {
            tags,
            page: (page || 0).toString(),
            pageSize: (pageSize || 0).toString(),
            txStatus,
        }, retry);
        this.queryNumPeers = async (retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryNumPeers, {}, retry);
        this.queryPeers = async (retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryPeers, {}, retry);
        this.queryShards = async (retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryShards, {}, retry);
        this.queryStat = async (retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryStat, {}, retry);
        this.queryFees = async (retry) => this.sendMessage(methods_1.RPCMethod.MethodQueryFees, {}, retry);
        this.getFees = async () => unmarshal_1.unmarshalFees(await this.queryFees());
        this.mintTxHash = ({ selector, gHash, outputHashFormat, }) => {
            utils_1.assertType("Buffer", { gHash });
            utils_1.assertType("string", { outputHashFormat });
            return exports.generateMintTxHash(selector, utils_1.toBase64(gHash), outputHashFormat, this.logger);
        };
        this.submitMint = async ({ selector, nonce, output, payload, to, token, fn, fnABI, tags, }) => {
            const { txindex, txid } = output;
            utils_1.assertType("Buffer", { nonce, payload, txid });
            utils_1.assertType("string", { to, token, fn, txindex });
            const response = await this.sendMessage(methods_1.RPCMethod.MethodSubmitTx, {
                tx: {
                    to: selector,
                    in: [
                        //
                        {
                            name: "p",
                            type: value_1.RenVMType.ExtEthCompatPayload,
                            value: {
                                abi: utils_1.toBase64(Buffer.from(JSON.stringify(fnABI))),
                                value: utils_1.toBase64(payload),
                                fn: utils_1.toBase64(Buffer.from(fn)),
                            },
                        },
                        // The hash of the payload data
                        // { name: "phash" as const, type: RenVMType.B32 as const, value: toBase64(pHash) },
                        // The amount of BTC (in SATs) that has be transferred to the gateway
                        // { name: "amount" as const, type: "u64", as const value: amount },
                        // The ERC20 contract address on Ethereum for BTC
                        {
                            name: "token",
                            type: value_1.RenVMType.ExtTypeEthCompatAddress,
                            value: utils_1.strip0x(token),
                        },
                        // The address on the Ethereum blockchain to which BTC will be transferred
                        {
                            name: "to",
                            type: value_1.RenVMType.ExtTypeEthCompatAddress,
                            value: utils_1.strip0x(to),
                        },
                        // The nonce is used to randomize the gateway
                        {
                            name: "n",
                            type: value_1.RenVMType.B32,
                            value: utils_1.toBase64(nonce),
                        },
                        // UTXO
                        {
                            name: "utxo",
                            type: value_1.RenVMType.ExtTypeBtcCompatUTXO,
                            value: {
                                txHash: utils_1.toBase64(txid),
                                vOut: txindex,
                            },
                        },
                    ],
                },
                tags,
            });
            return utils_1.fromBase64(response.tx.hash);
        };
        this.submitBurn = async (params) => {
            const { selector, burnNonce, tags } = params;
            const response = await this.sendMessage(methods_1.RPCMethod.MethodSubmitTx, {
                tx: {
                    to: selector,
                    in: [
                        {
                            name: "ref",
                            type: value_1.RenVMType.U64,
                            value: burnNonce.decimalPlaces(0).toFixed(),
                        },
                    ],
                },
                tags,
            });
            return utils_1.fromBase64(response.tx.hash);
        };
        this.queryMintOrBurn = async (_selector, utxoTxHash, retries) => {
            const response = await this.queryTx(utils_1.toBase64(utxoTxHash), retries);
            // Unmarshal transaction.
            const { asset, from } = utils_1.parseV1Selector(response.tx.to);
            if (asset.toUpperCase() === from.toUpperCase()) {
                return unmarshal_1.unmarshalMintTx(response);
            }
            else {
                return unmarshal_1.unmarshalBurnTx(response);
            }
        };
        this.waitForTX = async (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => {
            utils_1.assertType("Buffer", { utxoTxHash });
            let rawResponse;
            while (true) {
                if (_cancelRequested && _cancelRequested()) {
                    throw new Error(`waitForTX cancelled`);
                }
                try {
                    const result = await this.queryMintOrBurn(selector, utxoTxHash);
                    if (result && result.txStatus === interfaces_1.TxStatus.TxStatusDone) {
                        rawResponse = result;
                        break;
                    }
                    else if (onStatus && result && result.txStatus) {
                        onStatus(result.txStatus);
                    }
                }
                catch (error) {
                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {
                        // ignore
                    }
                    else {
                        this.logger.error(String(error));
                        // TODO: throw unexpected errors
                    }
                }
                await utils_1.sleep(utils_1.isDefined(timeout) ? timeout : 15 * utils_1.SECONDS);
            }
            return rawResponse;
        };
        /**
         * selectPublicKey fetches the public key for the RenVM shard handling
         * the provided contract.
         *
         * @param asset The asset for which the public key should be fetched.
         * @returns The public key hash (20 bytes) as a string.
         */
        this.selectPublicKey = async (_selector, asset) => {
            // Call the ren_queryShards RPC.
            const response = await this.queryShards(5);
            // Prioritize primary shards.
            const chosenShard = response.shards.sort((a, b) => a.primary && b.primary ? -1 : a.primary ? -1 : b.primary ? 1 : 0)[0];
            if (!chosenShard) {
                throw new Error("Unable to load public key from RenVM: no shards found");
            }
            // Get the gateway pubKey from the gateway with the right asset within
            // the shard with the lowest total value locked.
            const tokenGateway = immutable_1.List(chosenShard.gateways)
                .filter((gateway) => gateway.asset === asset)
                .first(undefined);
            if (!tokenGateway) {
                throw new Error(`Unable to load public key from RenVM: no gateway for the asset ${asset}`);
            }
            // Use this gateway pubKey to build the gateway address.
            // return hash160(
            return utils_1.fromBase64(tokenGateway.pubKey);
        };
        // In the future, this will be asynchronous. It returns a promise for
        // compatibility.
        // eslint-disable-next-line @typescript-eslint/require-await
        this.getNetwork = async (_selector) => {
            return this.network;
        };
        this.getConfirmationTarget = async (selector, _chain) => {
            const { asset } = utils_1.parseV1Selector(selector);
            switch (this.network) {
                case "mainnet":
                    switch (asset) {
                        case "BTC":
                            return 6;
                        case "ZEC":
                            return 24;
                        case "BCH":
                            return 15;
                        case "ETH":
                            return 30;
                    }
                    break;
                case "testnet":
                    switch (asset) {
                        case "BTC":
                            return 2;
                        case "ZEC":
                            return 6;
                        case "BCH":
                            return 2;
                        case "ETH":
                            return 12;
                    }
                    break;
            }
            return undefined;
        };
        this.estimateTransactionFee = async (_asset, _lockChain, hostChain) => {
            const allFees = await this.getFees();
            const fees = allFees[hostChain.legacyName
                ? hostChain.legacyName.toLowerCase()
                : hostChain.name.toLowerCase()];
            return Object.assign(Object.assign({}, fees), { mint: 25, burn: 15 });
        };
        if (!provider) {
            const rpcUrl = (interfaces_1.getRenNetworkDetails(network) || {}).lightnode;
            try {
                provider = new provider_1.HttpProvider(rpcUrl, logger);
            }
            catch (error) {
                if (/Invalid node URL/.exec(String(error && error.message))) {
                    throw new Error(`Invalid network or provider URL: "${(interfaces_1.getRenNetworkDetails(network) || {}).name ||
                        String(network)}"`);
                }
                throw error;
            }
        }
        this.network = network;
        this.logger = logger;
        this.provider = provider;
        this.sendMessage = async (method, request, retry = 2, timeout = 120 * utils_1.SECONDS) => {
            try {
                return await this.provider.sendMessage(method, request, retry, timeout);
            }
            catch (error) {
                const errorString = utils_1.extractError(error);
                if (/(tx hash=[a-zA-Z0-9+\/=]+ not found)/.exec(errorString)) {
                    error.code = interfaces_1.RenJSErrors.RenVMTransactionNotFound;
                }
                if (/(insufficient funds)/.exec(errorString)) {
                    error.code = interfaces_1.RenJSErrors.AmountTooSmall;
                }
                if (/(utxo spent or invalid index)/.exec(errorString)) {
                    error.code = interfaces_1.RenJSErrors.DepositSpentOrNotFound;
                }
                throw error;
            }
        };
    }
}
exports.RenVMProvider = RenVMProvider;
//# sourceMappingURL=renVMProvider.js.map