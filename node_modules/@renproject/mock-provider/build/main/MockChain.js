"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockChain = void 0;
const utils_1 = require("@renproject/utils");
const bs58_1 = __importDefault(require("bs58"));
const chains_bitcoin_1 = require("@renproject/chains-bitcoin");
const utils_2 = require("@renproject/chains-bitcoin/build/main/utils");
class MockChain extends chains_bitcoin_1.BitcoinClass {
    constructor(asset, network = "testnet") {
        super(network);
        this.chain = MockChain.chain;
        this.name = MockChain.chain;
        // eslint-disable-next-line @typescript-eslint/require-await
        this.fetchUTXO = async (txHash, vOut) => {
            const utxo = this.mempool.find((x) => x.txHash === txHash && x.vOut === vOut);
            if (utxo) {
                return utxo;
            }
            throw new Error(`UTXO ${txHash}, ${vOut} not found`);
        };
        this.fetchUTXOs = async (address, confirmations) => {
            return this.mempool.filter((x) => x.to === address && x.confirmations >= (confirmations || 0));
        };
        this.addUTXO = (to, amount) => {
            const tx = {
                to,
                txHash: utils_1.randomBytes(32).toString("hex"),
                vOut: 0,
                amount: amount.toString(),
                confirmations: 0,
            };
            this.mempool.push(tx);
            return tx;
        };
        // APIs
        this.withDefaultAPIs = (_network) => {
            return this.withAPI(this);
        };
        this.asset = "BTC";
        this.utils = utils_1.utilsWithChainNetwork(MockChain.utils, () => this.chainNetwork);
        this.mempool = [];
        this.asset = asset;
    }
}
exports.MockChain = MockChain;
MockChain.chain = "MockChain";
MockChain.asset = "BTC";
MockChain.utils = {
    resolveChainNetwork: chains_bitcoin_1.BitcoinClass.utils.resolveChainNetwork,
    p2shPrefix: {
        mainnet: Buffer.from([0x05]),
        testnet: Buffer.from([0xc4]),
    },
    addressBufferToString: bs58_1.default.encode,
    addressIsValid: (address, network = "mainnet") => utils_2.validateAddress(address, MockChain.asset, MockChain.utils.resolveChainNetwork(network)),
    transactionIsValid: (transaction, _network = "mainnet") => utils_1.isHex(typeof transaction === "string"
        ? transaction
        : transaction.txHash, { length: 32 }),
    addressExplorerLink: (address, _network = "mainnet") => {
        return address;
    },
    transactionExplorerLink: (tx, _network = "mainnet") => {
        return typeof tx === "string" ? tx : tx.txHash;
    },
};
const _ = MockChain;
//# sourceMappingURL=MockChain.js.map