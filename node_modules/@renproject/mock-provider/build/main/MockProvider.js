"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockProvider = exports.responseQueryParamsType = void 0;
const v2_1 = require("@renproject/rpc/build/main/v2");
const methods_1 = require("@renproject/rpc/build/main/v2/methods");
const utils_1 = require("@renproject/utils");
const ethereumjs_util_1 = require("ethereumjs-util");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const interfaces_1 = require("@renproject/interfaces");
const elliptic_1 = __importDefault(require("elliptic"));
const utils_2 = require("ethers/lib/utils");
const immutable_1 = require("immutable");
exports.responseQueryParamsType = {
    struct: [
        {
            amount: v2_1.PackPrimitive.U256,
        },
        {
            hash: v2_1.PackPrimitive.Bytes32,
        },
        {
            sighash: v2_1.PackPrimitive.Bytes32,
        },
        {
            sig: v2_1.PackPrimitive.Bytes65,
        },
        {
            txid: v2_1.PackPrimitive.Bytes,
        },
        {
            txindex: v2_1.PackPrimitive.U32,
        },
        {
            revert: v2_1.PackPrimitive.Str,
        },
    ],
};
class MockProvider {
    constructor(privateKey) {
        this.supportedChains = [];
        this.supportedAssets = [];
        this.mintAuthority = () => utils_1.Ox(ethereumjs_util_1.privateToAddress(this.privateKeyBuffer).toString("hex"));
        this.registerChain = (chain) => {
            this.supportedChains.push(chain.name);
        };
        this.registerAsset = (asset) => {
            this.supportedAssets.push(asset);
        };
        this.handle_submitTx = (request) => {
            const selector = request.tx.selector;
            const inputs = request.tx.in.v;
            const pHash = utils_1.fromBase64(inputs.phash);
            const nHash = utils_1.fromBase64(inputs.nhash);
            const to = utils_1.fromHex(inputs.to);
            let completedTransaction;
            if (/\/from/.exec(selector)) {
                // BURN //
                const amountIn = inputs.amount;
                const amountOut = new bignumber_js_1.default(amountIn).minus(1000).toFixed();
                completedTransaction = Object.assign(Object.assign({}, request), { txStatus: interfaces_1.TxStatus.TxStatusDone, tx: Object.assign(Object.assign({}, request.tx), { version: "1", in: request.tx.in, out: {
                            t: exports.responseQueryParamsType,
                            v: {
                                amount: amountOut,
                                hash: request.tx.hash,
                                revert: undefined,
                                sig: "",
                                sighash: "",
                                txid: "",
                                txindex: "0",
                            },
                        } }) });
            }
            else {
                // MINT //
                const amountIn = inputs.amount;
                const sHash = utils_1.keccak256(Buffer.from(selector));
                const amountOut = new bignumber_js_1.default(amountIn).minus(1000).toFixed();
                // Generate signature
                const sigParams = utils_2.defaultAbiCoder.encode(["bytes32", "uint256", "bytes32", "address", "bytes32"], [pHash, amountOut, sHash, utils_1.Ox(to), nHash]);
                const sigHash = utils_1.keccak256(utils_1.fromHex(sigParams));
                const sig = ethereumjs_util_1.ecsign(sigHash, this.privateKeyBuffer);
                const sigOut = utils_1.toURLBase64(Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]));
                completedTransaction = Object.assign(Object.assign({}, request), { txStatus: interfaces_1.TxStatus.TxStatusDone, tx: Object.assign(Object.assign({}, request.tx), { version: "1", in: request.tx.in, out: {
                            t: exports.responseQueryParamsType,
                            v: {
                                amount: amountOut,
                                hash: request.tx.hash,
                                revert: undefined,
                                sig: sigOut,
                                sighash: utils_1.toURLBase64(sigHash),
                                txid: "",
                                txindex: "0",
                            },
                        } }) });
            }
            this.transactions.set(completedTransaction.tx.hash, completedTransaction);
            // TODO: Fix type.
            return {};
        };
        this.handle_queryTx = (request) => {
            const tx = this.transactions.get(request.txHash);
            if (tx) {
                return tx;
            }
            else {
                throw new Error(`Transaction ${request.txHash} not found.`);
            }
        };
        this.handle_queryConfig = (_request) => {
            return {
                confirmations: this.supportedChains.reduce((acc, chain) => (Object.assign(Object.assign({}, acc), { [chain]: 0 })), {}),
                whitelist: [],
            };
        };
        this.handle_queryBlockState = (_request) => {
            const ec = new elliptic_1.default.ec("secp256k1");
            const k = ec.keyFromPrivate(this.privateKeyBuffer);
            const key = Buffer.concat([
                Buffer.from([3]),
                k.getPublic().getX().toArrayLike(Buffer, "be", 32),
            ]);
            const assetPackType = {
                struct: [
                    {
                        latestHeight: v2_1.PackPrimitive.U256,
                    },
                    {
                        gasCap: v2_1.PackPrimitive.U256,
                    },
                    {
                        gasLimit: v2_1.PackPrimitive.U256,
                    },
                    {
                        gasPrice: v2_1.PackPrimitive.U256,
                    },
                    {
                        minimumAmount: v2_1.PackPrimitive.U256,
                    },
                    {
                        dustAmount: v2_1.PackPrimitive.U256,
                    },
                    {
                        shards: {
                            list: {
                                struct: [
                                    {
                                        shard: v2_1.PackPrimitive.Bytes32,
                                    },
                                    {
                                        pubKey: v2_1.PackPrimitive.Bytes,
                                    },
                                    {
                                        queue: {
                                            list: {
                                                struct: [
                                                    {
                                                        hash: v2_1.PackPrimitive.Bytes32,
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                    {
                                        state: {
                                            struct: [
                                                {
                                                    outpoint: {
                                                        struct: [
                                                            {
                                                                hash: v2_1.PackPrimitive.Bytes,
                                                            },
                                                            {
                                                                index: v2_1.PackPrimitive.U32,
                                                            },
                                                        ],
                                                    },
                                                },
                                                {
                                                    value: v2_1.PackPrimitive.U256,
                                                },
                                                {
                                                    pubKeyScript: v2_1.PackPrimitive.Bytes,
                                                },
                                            ],
                                        },
                                    },
                                ],
                            },
                        },
                    },
                    {
                        minted: {
                            list: {
                                struct: [
                                    {
                                        chain: v2_1.PackPrimitive.Str,
                                    },
                                    {
                                        amount: v2_1.PackPrimitive.U256,
                                    },
                                ],
                            },
                        },
                    },
                    {
                        fees: {
                            struct: [
                                {
                                    reserved: {
                                        struct: [
                                            {
                                                fund: v2_1.PackPrimitive.U256,
                                            },
                                        ],
                                    },
                                },
                                {
                                    unassigned: v2_1.PackPrimitive.U256,
                                },
                                {
                                    unclaimed: v2_1.PackPrimitive.U256,
                                },
                                {
                                    epochs: {
                                        list: {
                                            struct: [
                                                {
                                                    epoch: v2_1.PackPrimitive.U64,
                                                },
                                                {
                                                    amount: v2_1.PackPrimitive.U256,
                                                },
                                                {
                                                    numNodes: v2_1.PackPrimitive.U64,
                                                },
                                            ],
                                        },
                                    },
                                },
                                {
                                    nodes: {
                                        list: {
                                            struct: [
                                                {
                                                    node: v2_1.PackPrimitive.Bytes32,
                                                },
                                                {
                                                    amountClaimed: v2_1.PackPrimitive.U256,
                                                },
                                                {
                                                    nonce: v2_1.PackPrimitive.U64,
                                                },
                                            ],
                                        },
                                    },
                                },
                                {
                                    chains: {
                                        list: {
                                            struct: [
                                                {
                                                    chain: v2_1.PackPrimitive.Str,
                                                },
                                                {
                                                    mintFee: v2_1.PackPrimitive.U64,
                                                },
                                                {
                                                    burnFee: v2_1.PackPrimitive.U64,
                                                },
                                            ],
                                        },
                                    },
                                },
                            ],
                        },
                    },
                ],
            };
            const v = immutable_1.OrderedMap(this.supportedAssets.map((x) => [x, x]))
                .map(() => ({
                dustAmount: "546",
                fees: {
                    chains: this.supportedChains.map((chain) => ({
                        chain: chain,
                        burnFee: "15",
                        mintFee: "15",
                    })),
                    epochs: [],
                    nodes: [],
                    reserved: {
                        fund: "0",
                    },
                    unassigned: "0",
                    unclaimed: "0",
                },
                gasCap: "2",
                gasLimit: "400",
                gasPrice: "2",
                latestHeight: "0",
                minimumAmount: "547",
                minted: [],
                shards: [
                    {
                        pubKey: utils_1.toURLBase64(key),
                        queue: [],
                        shard: "",
                        state: {
                            outpoint: {
                                hash: "",
                                index: "",
                            },
                            pubKeyScript: "",
                            value: "",
                        },
                    },
                ],
            }))
                .toJS();
            return {
                state: {
                    t: {
                        struct: this.supportedAssets.map((x) => ({
                            [x]: assetPackType,
                        })),
                    },
                    v,
                },
            };
        };
        this.privateKeyBuffer = privateKey || utils_1.randomBytes(32);
        this.transactions = new Map();
    }
    sendMessage(method, request) {
        try {
            switch (method) {
                case methods_1.RPCMethod.SubmitTx:
                    return this.handle_submitTx(request);
                case methods_1.RPCMethod.QueryTx:
                    return this.handle_queryTx(request);
                case methods_1.RPCMethod.QueryConfig:
                    return this.handle_queryConfig(request);
                case methods_1.RPCMethod.QueryBlockState:
                    return this.handle_queryBlockState(request);
            }
            throw new Error(`Method ${method} not supported.`);
        }
        catch (error) {
            throw error;
        }
    }
}
exports.MockProvider = MockProvider;
//# sourceMappingURL=MockProvider.js.map