import { isHex, randomBytes, utilsWithChainNetwork } from "@renproject/utils";
import base58 from "bs58";
import { BitcoinClass, } from "@renproject/chains-bitcoin";
import { validateAddress } from "@renproject/chains-bitcoin/build/main/utils";
export class MockChain extends BitcoinClass {
    static chain = "MockChain";
    chain = MockChain.chain;
    name = MockChain.chain;
    mempool;
    constructor(asset, network = "testnet") {
        super(network);
        this.mempool = [];
        this.asset = asset;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    fetchUTXO = async (txHash, vOut) => {
        const utxo = this.mempool.find((x) => x.txHash === txHash && x.vOut === vOut);
        if (utxo) {
            return utxo;
        }
        throw new Error(`UTXO ${txHash}, ${vOut} not found`);
    };
    fetchUTXOs = async (address, confirmations) => {
        return this.mempool.filter((x) => x.to === address && x.confirmations >= (confirmations || 0));
    };
    addUTXO = (to, amount) => {
        const tx = {
            to,
            txHash: randomBytes(32).toString("hex"),
            vOut: 0,
            amount: amount.toString(),
            confirmations: 0,
        };
        this.mempool.push(tx);
        return tx;
    };
    // APIs
    withDefaultAPIs = (_network) => {
        return this.withAPI(this);
    };
    static asset = "BTC";
    asset = "BTC";
    static utils = {
        resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,
        p2shPrefix: {
            mainnet: Buffer.from([0x05]),
            testnet: Buffer.from([0xc4]),
        },
        addressBufferToString: base58.encode,
        addressIsValid: (address, network = "mainnet") => validateAddress(address, MockChain.asset, MockChain.utils.resolveChainNetwork(network)),
        transactionIsValid: (transaction, _network = "mainnet") => isHex(typeof transaction === "string"
            ? transaction
            : transaction.txHash, { length: 32 }),
        addressExplorerLink: (address, _network = "mainnet") => {
            return address;
        },
        transactionExplorerLink: (tx, _network = "mainnet") => {
            return typeof tx === "string" ? tx : tx.txHash;
        },
    };
    utils = utilsWithChainNetwork(MockChain.utils, () => this.chainNetwork);
}
const _ = MockChain;
//# sourceMappingURL=MockChain.js.map