import { PackPrimitive, } from "@renproject/rpc/build/main/v2";
import { RPCMethod, } from "@renproject/rpc/build/main/v2/methods";
import { fromBase64, fromHex, keccak256, Ox, randomBytes, toURLBase64, } from "@renproject/utils";
import { ecsign, privateToAddress } from "ethereumjs-util";
import BigNumber from "bignumber.js";
import { TxStatus } from "@renproject/interfaces";
import elliptic from "elliptic";
import { defaultAbiCoder } from "ethers/lib/utils";
import { OrderedMap } from "immutable";
export const responseQueryParamsType = {
    struct: [
        {
            amount: PackPrimitive.U256,
        },
        {
            hash: PackPrimitive.Bytes32,
        },
        {
            sighash: PackPrimitive.Bytes32,
        },
        {
            sig: PackPrimitive.Bytes65,
        },
        {
            txid: PackPrimitive.Bytes,
        },
        {
            txindex: PackPrimitive.U32,
        },
        {
            revert: PackPrimitive.Str,
        },
    ],
};
export class MockProvider {
    privateKeyBuffer;
    transactions;
    supportedChains = [];
    supportedAssets = [];
    constructor(privateKey) {
        this.privateKeyBuffer = privateKey || randomBytes(32);
        this.transactions = new Map();
    }
    mintAuthority = () => Ox(privateToAddress(this.privateKeyBuffer).toString("hex"));
    registerChain = (chain) => {
        this.supportedChains.push(chain.name);
    };
    registerAsset = (asset) => {
        this.supportedAssets.push(asset);
    };
    sendMessage(method, request) {
        try {
            switch (method) {
                case RPCMethod.SubmitTx:
                    return this.handle_submitTx(request);
                case RPCMethod.QueryTx:
                    return this.handle_queryTx(request);
                case RPCMethod.QueryConfig:
                    return this.handle_queryConfig(request);
                case RPCMethod.QueryBlockState:
                    return this.handle_queryBlockState(request);
            }
            throw new Error(`Method ${method} not supported.`);
        }
        catch (error) {
            throw error;
        }
    }
    handle_submitTx = (request) => {
        const selector = request.tx.selector;
        const inputs = request.tx.in.v;
        const pHash = fromBase64(inputs.phash);
        const nHash = fromBase64(inputs.nhash);
        const to = fromHex(inputs.to);
        let completedTransaction;
        if (/\/from/.exec(selector)) {
            // BURN //
            const amountIn = inputs.amount;
            const amountOut = new BigNumber(amountIn).minus(1000).toFixed();
            completedTransaction = {
                ...request,
                txStatus: TxStatus.TxStatusDone,
                tx: {
                    ...request.tx,
                    version: "1",
                    in: request.tx.in,
                    out: {
                        t: responseQueryParamsType,
                        v: {
                            amount: amountOut,
                            hash: request.tx.hash,
                            revert: undefined,
                            sig: "",
                            sighash: "",
                            txid: "",
                            txindex: "0",
                        },
                    },
                },
            };
        }
        else {
            // MINT //
            const amountIn = inputs.amount;
            const sHash = keccak256(Buffer.from(selector));
            const amountOut = new BigNumber(amountIn).minus(1000).toFixed();
            // Generate signature
            const sigParams = defaultAbiCoder.encode(["bytes32", "uint256", "bytes32", "address", "bytes32"], [pHash, amountOut, sHash, Ox(to), nHash]);
            const sigHash = keccak256(fromHex(sigParams));
            const sig = ecsign(sigHash, this.privateKeyBuffer);
            const sigOut = toURLBase64(Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]));
            completedTransaction = {
                ...request,
                txStatus: TxStatus.TxStatusDone,
                tx: {
                    ...request.tx,
                    version: "1",
                    in: request.tx.in,
                    out: {
                        t: responseQueryParamsType,
                        v: {
                            amount: amountOut,
                            hash: request.tx.hash,
                            revert: undefined,
                            sig: sigOut,
                            sighash: toURLBase64(sigHash),
                            txid: "",
                            txindex: "0",
                        },
                    },
                },
            };
        }
        this.transactions.set(completedTransaction.tx.hash, completedTransaction);
        // TODO: Fix type.
        return {};
    };
    handle_queryTx = (request) => {
        const tx = this.transactions.get(request.txHash);
        if (tx) {
            return tx;
        }
        else {
            throw new Error(`Transaction ${request.txHash} not found.`);
        }
    };
    handle_queryConfig = (_request) => {
        return {
            confirmations: this.supportedChains.reduce((acc, chain) => ({ ...acc, [chain]: 0 }), {}),
            whitelist: [],
        };
    };
    handle_queryBlockState = (_request) => {
        const ec = new elliptic.ec("secp256k1");
        const k = ec.keyFromPrivate(this.privateKeyBuffer);
        const key = Buffer.concat([
            Buffer.from([3]),
            k.getPublic().getX().toArrayLike(Buffer, "be", 32),
        ]);
        const assetPackType = {
            struct: [
                {
                    latestHeight: PackPrimitive.U256,
                },
                {
                    gasCap: PackPrimitive.U256,
                },
                {
                    gasLimit: PackPrimitive.U256,
                },
                {
                    gasPrice: PackPrimitive.U256,
                },
                {
                    minimumAmount: PackPrimitive.U256,
                },
                {
                    dustAmount: PackPrimitive.U256,
                },
                {
                    shards: {
                        list: {
                            struct: [
                                {
                                    shard: PackPrimitive.Bytes32,
                                },
                                {
                                    pubKey: PackPrimitive.Bytes,
                                },
                                {
                                    queue: {
                                        list: {
                                            struct: [
                                                {
                                                    hash: PackPrimitive.Bytes32,
                                                },
                                            ],
                                        },
                                    },
                                },
                                {
                                    state: {
                                        struct: [
                                            {
                                                outpoint: {
                                                    struct: [
                                                        {
                                                            hash: PackPrimitive.Bytes,
                                                        },
                                                        {
                                                            index: PackPrimitive.U32,
                                                        },
                                                    ],
                                                },
                                            },
                                            {
                                                value: PackPrimitive.U256,
                                            },
                                            {
                                                pubKeyScript: PackPrimitive.Bytes,
                                            },
                                        ],
                                    },
                                },
                            ],
                        },
                    },
                },
                {
                    minted: {
                        list: {
                            struct: [
                                {
                                    chain: PackPrimitive.Str,
                                },
                                {
                                    amount: PackPrimitive.U256,
                                },
                            ],
                        },
                    },
                },
                {
                    fees: {
                        struct: [
                            {
                                reserved: {
                                    struct: [
                                        {
                                            fund: PackPrimitive.U256,
                                        },
                                    ],
                                },
                            },
                            {
                                unassigned: PackPrimitive.U256,
                            },
                            {
                                unclaimed: PackPrimitive.U256,
                            },
                            {
                                epochs: {
                                    list: {
                                        struct: [
                                            {
                                                epoch: PackPrimitive.U64,
                                            },
                                            {
                                                amount: PackPrimitive.U256,
                                            },
                                            {
                                                numNodes: PackPrimitive.U64,
                                            },
                                        ],
                                    },
                                },
                            },
                            {
                                nodes: {
                                    list: {
                                        struct: [
                                            {
                                                node: PackPrimitive.Bytes32,
                                            },
                                            {
                                                amountClaimed: PackPrimitive.U256,
                                            },
                                            {
                                                nonce: PackPrimitive.U64,
                                            },
                                        ],
                                    },
                                },
                            },
                            {
                                chains: {
                                    list: {
                                        struct: [
                                            {
                                                chain: PackPrimitive.Str,
                                            },
                                            {
                                                mintFee: PackPrimitive.U64,
                                            },
                                            {
                                                burnFee: PackPrimitive.U64,
                                            },
                                        ],
                                    },
                                },
                            },
                        ],
                    },
                },
            ],
        };
        const v = OrderedMap(this.supportedAssets.map((x) => [x, x]))
            .map(() => ({
            dustAmount: "546",
            fees: {
                chains: this.supportedChains.map((chain) => ({
                    chain: chain,
                    burnFee: "15",
                    mintFee: "15",
                })),
                epochs: [],
                nodes: [],
                reserved: {
                    fund: "0",
                },
                unassigned: "0",
                unclaimed: "0",
            },
            gasCap: "2",
            gasLimit: "400",
            gasPrice: "2",
            latestHeight: "0",
            minimumAmount: "547",
            minted: [],
            shards: [
                {
                    pubKey: toURLBase64(key),
                    queue: [],
                    shard: "",
                    state: {
                        outpoint: {
                            hash: "",
                            index: "",
                        },
                        pubKeyScript: "",
                        value: "",
                    },
                },
            ],
        }))
            .toJS();
        return {
            state: {
                t: {
                    struct: this.supportedAssets.map((x) => ({
                        [x]: assetPackType,
                    })),
                },
                v,
            },
        };
    };
}
//# sourceMappingURL=MockProvider.js.map