"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBurnTxHash = exports.renVMHashToBase64 = exports.generateSighash = exports.generateNHash = exports.generateGHash = exports.generateSHash = exports.generatePHash = void 0;
const interfaces_1 = require("@renproject/interfaces");
const assert_1 = require("./assert");
const common_1 = require("./common");
const hash_1 = require("./hash");
// export const generateNHash = (tx: Tx): Buffer => {
//     const encoded = rawEncode(
//         ["bytes32", "bytes32"],
//         [Ox(tx.hash), Ox(tx.args.n)],
//     );
//     return keccak256(encoded);
// };
/**
 * Hash the payloads associated with a RenVM cross-chain transaction.
 *
 * @param zip An array (or spread) of parameters with with types defined.
 */
const generatePHash = (zip, logger = interfaces_1.NullLogger) => {
    // Check if they called as hashPayload([...]) instead of hashPayload(...)
    const args = (Array.isArray(zip[0]) ? zip[0] : zip).filter((arg) => !arg.notInPayload);
    const types = args.map((param) => param.type);
    const values = args.map((param) => param.value);
    const message = common_1.rawEncode(types, values);
    const digest = hash_1.keccak256(message);
    logger.debug("pHash", common_1.toBase64(digest), common_1.Ox(message), args);
    return digest; // sha3 can accept a Buffer
};
exports.generatePHash = generatePHash;
const generateSHash = (selector) => {
    const toSelector = selector.replace(/\/.*To/, "/to");
    return hash_1.keccak256(Buffer.from(toSelector));
};
exports.generateSHash = generateSHash;
const generateGHash = (payload, to, tokenIdentifier, nonce, v2, logger = interfaces_1.NullLogger) => {
    // Type validation
    assert_1.assertType("Buffer", { nonce });
    assert_1.assertType("string", { to, token: tokenIdentifier });
    const pHash = exports.generatePHash(payload, logger);
    const sHash = common_1.fromHex(tokenIdentifier);
    const toBytes = common_1.fromHex(to);
    const encoded = v2
        ? Buffer.concat([pHash, sHash, toBytes, nonce])
        : common_1.rawEncode(["bytes32", "address", "address", "bytes32"], [pHash, tokenIdentifier, to, nonce]);
    const digest = hash_1.keccak256(encoded);
    logger.debug("gHash", common_1.toBase64(digest), common_1.Ox(encoded));
    return digest;
};
exports.generateGHash = generateGHash;
const generateNHash = (nonce, txid, txindex, v2, logger = interfaces_1.NullLogger) => {
    const encoded = v2
        ? Buffer.concat([
            nonce,
            txid,
            common_1.rawEncode(["uint32"], [txindex]).slice(-4),
        ])
        : common_1.rawEncode(["bytes32", "bytes32", "uint32"], [nonce, txid, txindex]);
    const digest = hash_1.keccak256(encoded);
    logger.debug("nHash", common_1.toBase64(digest), common_1.Ox(encoded));
    return digest;
};
exports.generateNHash = generateNHash;
const generateSighash = (pHash, amount, to, tokenIdentifier, nonceHash, v2, logger = interfaces_1.NullLogger) => {
    // Type validation
    assert_1.assertType("string", { to, tokenIdentifier });
    assert_1.assertType("Buffer", { pHash, nonceHash });
    const encoded = common_1.rawEncode([
        "bytes32",
        "uint256",
        v2 ? "bytes32" : "address",
        "address",
        "bytes32",
    ], [pHash, amount, common_1.Ox(tokenIdentifier), common_1.Ox(to), nonceHash]);
    const digest = hash_1.keccak256(encoded);
    logger.debug("sigHash", common_1.toBase64(digest), common_1.Ox(encoded));
    return digest;
};
exports.generateSighash = generateSighash;
const renVMHashToBase64 = (txHash, v2) => {
    // Type validation
    assert_1.assertType("string", { txHash });
    // Hex
    if (/^(0x)?[0-9a-fA-Z]{64}$/.exec(txHash)) {
        return (v2 ? common_1.toURLBase64 : common_1.toBase64)(common_1.fromHex(txHash));
    }
    // Already base64. For v2, ensure it's in URL-base64 format.
    return v2 ? common_1.toURLBase64(common_1.fromBase64(txHash)) : txHash;
};
exports.renVMHashToBase64 = renVMHashToBase64;
const generateBurnTxHash = (selector, encodedID, logger = interfaces_1.NullLogger) => {
    // Type validation
    assert_1.assertType("string", { encodedID });
    const message = `txHash_${selector}_${encodedID}`;
    const digest = hash_1.keccak256(Buffer.from(message));
    logger.debug("Burn txHash", common_1.toBase64(digest), message);
    return digest;
};
exports.generateBurnTxHash = generateBurnTxHash;
//# sourceMappingURL=renVMHashes.js.map