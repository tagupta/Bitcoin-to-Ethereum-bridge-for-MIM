"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHex = exports.isURLBase64 = exports.isBase64 = exports.doesntError = exports.isDefined = exports.rawEncode = exports.emptyNonce = exports.randomNonce = exports.randomBytes = exports.retryNTimes = exports.extractError = exports.fromReadable = exports.toReadable = exports.toURLBase64 = exports.fromBigNumber = exports.toBase64 = exports.fromBase64 = exports.fromHex = exports.Ox = exports.strip0x = exports.sleep = exports.SECONDS = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("ethers/lib/utils");
const assert_1 = require("./assert");
/**
 * Represents 1 second for functions that accept a parameter in milliseconds.
 */
exports.SECONDS = 1000;
/**
 * Pauses the thread for the specified number of milliseconds.
 *
 * @param ms The number of milliseconds to pause for.
 */
const sleep = async (ms) => new Promise((resolve) => setTimeout(resolve, ms));
exports.sleep = sleep;
/**
 * Remove 0x prefix from a hex string. If the input doesn't have a 0x prefix,
 * it's returned unchanged.
 *
 * @param hex The hex value to be prefixed.
 */
const strip0x = (hex) => {
    // Type validation
    assert_1.assertType("string", { hex });
    return hex.substring(0, 2) === "0x" ? hex.slice(2) : hex;
};
exports.strip0x = strip0x;
/**
 * Add a 0x prefix to a hex value, converting to a string first. If the input
 * is already prefixed, it's returned unchanged.
 *
 * @param hex The hex value to be prefixed.
 */
const Ox = (hex, { prefix } = { prefix: "0x" }) => {
    const hexString = typeof hex === "string" ? hex : hex.toString("hex");
    return hexString.substring(0, 2) === prefix
        ? hexString
        : `${prefix}${hexString}`;
};
exports.Ox = Ox;
const fromHex = (hex) => {
    assert_1.assertType("Buffer | string", { hex });
    return Buffer.isBuffer(hex)
        ? Buffer.from(hex)
        : Buffer.from(exports.strip0x(hex), "hex");
};
exports.fromHex = fromHex;
const fromBase64 = (base64) => {
    assert_1.assertType("Buffer | string", {
        base64,
    });
    return Buffer.isBuffer(base64)
        ? Buffer.from(base64)
        : Buffer.from(base64, "base64");
};
exports.fromBase64 = fromBase64;
const toBase64 = (input) => {
    assert_1.assertType("Buffer", { input });
    return input.toString("base64");
};
exports.toBase64 = toBase64;
const fromBigNumber = (bn) => {
    const bnStr = bn.toString(16);
    // Pad if necessary
    return Buffer.from(bnStr.length % 2 ? "0" + bnStr : bnStr, "hex");
};
exports.fromBigNumber = fromBigNumber;
// Unpadded alternate base64 encoding defined in RFC 4648, commonly used in
// URLs.
const toURLBase64 = (input) => {
    assert_1.assertType("Buffer | string", {
        input,
    });
    return (Buffer.isBuffer(input) ? Buffer.from(input) : exports.fromHex(input))
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "");
};
exports.toURLBase64 = toURLBase64;
const toReadable = (value, decimals) => new bignumber_js_1.default(value).dividedBy(new bignumber_js_1.default(10).exponentiatedBy(decimals));
exports.toReadable = toReadable;
const fromReadable = (value, decimals) => new bignumber_js_1.default(value)
    .times(new bignumber_js_1.default(10).exponentiatedBy(decimals))
    .decimalPlaces(0);
exports.fromReadable = fromReadable;
const hasOwnProperty = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
object, property) => {
    return object.hasOwnProperty(property);
};
const invalidError = (errorMessage) => errorMessage === "" ||
    errorMessage === "null" ||
    errorMessage === "undefined";
const extractError = (error) => {
    if (error && typeof error === "object") {
        if (hasOwnProperty(error, "response") && error.response) {
            const extractedError = exports.extractError(error.response);
            if (!invalidError(extractedError)) {
                return extractedError;
            }
        }
        if (hasOwnProperty(error, "data") && error.data) {
            const extractedError = exports.extractError(error.data);
            if (!invalidError(extractedError)) {
                return extractedError;
            }
        }
        if (hasOwnProperty(error, "error") && error.error) {
            const extractedError = exports.extractError(error.error);
            if (!invalidError(extractedError)) {
                return extractedError;
            }
        }
        if (hasOwnProperty(error, "context") && error.context) {
            const extractedError = exports.extractError(error.context);
            if (!invalidError(extractedError)) {
                return extractedError;
            }
        }
        if (hasOwnProperty(error, "message") && error.message) {
            const extractedError = exports.extractError(error.message);
            if (!invalidError(extractedError)) {
                return extractedError;
            }
        }
        if (hasOwnProperty(error, "statusText") && error.statusText) {
            const extractedError = exports.extractError(error.statusText);
            if (!invalidError(extractedError)) {
                return extractedError;
            }
        }
    }
    try {
        if (typeof error === "string") {
            if (error.slice(0, 7) === "Error: ") {
                error = error.slice(7);
            }
            return error;
        }
        return JSON.stringify(error);
    }
    catch (innerError) {
        // Ignore JSON error
    }
    return String(error);
};
exports.extractError = extractError;
const retryNTimes = async (fnCall, retries, timeout = 1 * exports.SECONDS, // in ms
logger) => {
    let returnError;
    const errorMessages = new Set();
    for (let i = 0; retries === -1 || i < retries; i++) {
        try {
            return await fnCall();
        }
        catch (error) {
            // Fix error message.
            const errorMessage = exports.extractError(error);
            errorMessages.add(errorMessage);
            returnError = error;
            if (i < retries || retries === -1) {
                await exports.sleep(timeout);
                if (logger) {
                    logger.warn(error);
                }
            }
        }
    }
    returnError.message = Array.from(errorMessages).join(", ");
    throw returnError;
};
exports.retryNTimes = retryNTimes;
/**
 * Generates a random hex string (prefixed with '0x').
 *
 * @param bytes The number of bytes to generate.
 */
const randomBytes = (bytes) => {
    try {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (window) {
            const uints = new Uint32Array(bytes / 4); // 4 bytes (32 bits)
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            window.crypto.getRandomValues(uints);
            let str = "";
            for (const uint of uints) {
                str +=
                    "0".repeat(8 - uint.toString(16).length) +
                        String(uint.toString(16));
            }
            return exports.fromHex(str);
        }
    }
    catch (error) {
        // Ignore error
    }
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const crypto = require("crypto");
    return crypto.randomBytes(bytes);
};
exports.randomBytes = randomBytes;
/**
 * Returns a random 32 byte Buffer.
 */
const randomNonce = () => exports.randomBytes(32);
exports.randomNonce = randomNonce;
const emptyNonce = () => exports.fromHex("00".repeat(32));
exports.emptyNonce = emptyNonce;
const rawEncode = (types, parameters) => exports.fromHex(utils_1.defaultAbiCoder.encode(types, parameters));
exports.rawEncode = rawEncode;
/**
 * isDefined returns true if the parameter is defined and not null.
 */
const isDefined = (x) => x !== null && x !== undefined;
exports.isDefined = isDefined;
const assert = (input, reason) => {
    if (!input) {
        throw new Error(reason || `Assertion failed.`);
    }
};
/**
 * Returns false if the method throws or returns false - returns true otherwise.
 */
const doesntError = (f) => {
    return (...p) => {
        try {
            const response = f(...p);
            return response === undefined || response === true ? true : false;
        }
        catch (error) {
            return false;
        }
    };
};
exports.doesntError = doesntError;
/**
 * Returns true if the
 */
exports.isBase64 = exports.doesntError((input, options = {}) => {
    const buffer = Buffer.from(input, "base64");
    assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);
    assert(buffer.toString("base64") === input);
});
exports.isURLBase64 = exports.doesntError((input, options = {}) => {
    const buffer = Buffer.from(input, "base64");
    assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);
    assert(exports.toURLBase64(buffer) === input);
});
exports.isHex = exports.doesntError((input, options = {}) => {
    if (options.prefix) {
        assert(input.slice(0, 2) === "0x");
        input = input.slice(2);
    }
    const buffer = Buffer.from(input, "hex");
    assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);
    assert(buffer.toString("hex") === input);
});
//# sourceMappingURL=common.js.map