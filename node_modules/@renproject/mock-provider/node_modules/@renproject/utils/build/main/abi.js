"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.payloadToMintABI = exports.payloadToABI = void 0;
const assert_1 = require("./assert");
const mintABITemplate = {
    constant: false,
    inputs: [
        {
            name: "_amount",
            type: "uint256",
        },
        {
            name: "_nHash",
            type: "bytes32",
        },
        {
            name: "_sig",
            type: "bytes",
        },
    ],
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function",
};
const tupleRegex = /tuple\(([a-zA-Z0-9]+(,[a-zA-Z0-9]+)*)\)/;
/**
 * If the type of an Ethereum arg matches `tuple(...)`, then it needs to include
 * a `components` array that provides the name and type of each of the tuple's
 * values. If it wasn't included, `fixTuple` will create the components array.
 */
const fixTuple = (argument) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { value } = argument, args = __rest(argument, ["value"]);
    try {
        // If type is `tuple(...)` but components haven't been
        // been passed in, add them.
        const match = args && args.type && tupleRegex.exec(args.type);
        if (match && !argument.components) {
            const types = match[1].split(",");
            const components = [];
            for (let i = 0; i < types.length; i++) {
                components[i] = {
                    name: String(i),
                    type: types[i],
                };
            }
            return Object.assign(Object.assign({}, args), { components });
        }
    }
    catch (error) {
        console.error(error);
    }
    return args;
};
const payloadToABI = (methodName, payload) => {
    // Type validation
    assert_1.assertType("string", { methodName });
    (payload || []).map(({ type, name }) => assert_1.assertType("string", { type, name }));
    return [
        {
            name: methodName,
            type: "function",
            stateMutability: "nonpayable",
            inputs: [
                ...(payload || []).map(fixTuple).map((value) => (Object.assign({ type: value.type, name: value.name }, (value.components
                    ? {
                        components: value.components,
                    }
                    : undefined)))),
            ],
            outputs: [],
        },
    ];
};
exports.payloadToABI = payloadToABI;
const payloadToMintABI = (methodName, payload) => {
    // Type validation
    assert_1.assertType("string", { methodName });
    (payload || []).map(({ type, name }) => assert_1.assertType("string", { type, name }));
    return [
        Object.assign(Object.assign({}, mintABITemplate), { name: methodName, inputs: [
                ...(payload || []).map(fixTuple).map((value) => (Object.assign({ type: value.type, name: value.name }, (value.components
                    ? {
                        components: value.components,
                    }
                    : undefined)))),
                ...(mintABITemplate.inputs ? mintABITemplate.inputs : []),
            ] }),
    ];
};
exports.payloadToMintABI = payloadToMintABI;
//# sourceMappingURL=abi.js.map