var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { LogLevel, NullLogger } from "@renproject/interfaces";
import { extractError, retryNTimes, SECONDS } from "@renproject/utils";
import axios from "axios";
const generatePayload = (method, params) => ({
    id: 1,
    jsonrpc: "2.0",
    method,
    params,
});
export class HttpProvider {
    constructor(ipOrMultiaddress, logger = NullLogger) {
        this.sendMessage = (method, request, retry = 2, timeout = 120 * SECONDS) => __awaiter(this, void 0, void 0, function* () {
            const payload = generatePayload(method, request);
            if (
            // Check level before doing expensive JSON call.
            typeof this.logger.level !== "number" ||
                this.logger.level >= LogLevel.Debug) {
                this.logger.debug("[request]", JSON.stringify(payload, null, "    "));
            }
            try {
                const response = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {
                    return axios.post(this.nodeURL, payload, 
                    // Use a 120 second timeout. This could be reduced, but
                    // should be done based on the method, since some requests
                    // may take a long time, especially on a slow connection.
                    { timeout });
                }), retry, 1 * SECONDS);
                if (response.status !== 200) {
                    throw this.responseError(`Unexpected status code ${String(response.status)} returned from node.`, response);
                }
                if (response.data.error) {
                    throw new Error(response.data.error);
                }
                if (response.data.result === undefined) {
                    throw new Error(`Empty result returned from node.`);
                }
                if (typeof this.logger.level !== "number" ||
                    this.logger.level >= LogLevel.Debug) {
                    this.logger.debug("[response]", JSON.stringify(response.data.result, null, "    "));
                }
                return response.data.result;
            }
            catch (error) {
                if (error.response) {
                    error.message = `Node returned status ${String(error.response.status)} with reason: ${extractError(error)}`;
                }
                throw error;
            }
        });
        this.responseError = (msg, response) => {
            const error = new Error(msg);
            error.response = response;
            return error;
        };
        this.logger = logger;
        if (typeof ipOrMultiaddress !== "string") {
            throw new Error(`Invalid node URL ${String(ipOrMultiaddress)}`);
        }
        if (ipOrMultiaddress.indexOf("://") === -1) {
            throw new Error(`Invalid node URL without protocol: ${ipOrMultiaddress}.`);
        }
        this.nodeURL = ipOrMultiaddress;
    }
}
//# sourceMappingURL=httpProvider.js.map