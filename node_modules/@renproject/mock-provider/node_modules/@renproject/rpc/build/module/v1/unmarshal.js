var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { NullLogger, } from "@renproject/interfaces";
import { assert, fixSignature, fromBase64, Ox, signatureToBuffer, toBase64, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { RenVMType } from "./value";
const decodeString = (input) => fromBase64(input).toString();
const decodeBytes = (input) => fromBase64(input);
const decodeNumber = (input) => new BigNumber(input);
/**
 * Validate an argument returned from RenVM.
 *
 * @param name The expected name.
 * @param type The expected type.
 * @param arg The actual argument returned.
 */
const assertArgumentType = (name, type, arg) => {
    assert(arg.type === type, `Expected argument ${name} of type ${type} but got ${arg.name} of type ${arg.type}`);
    return arg.value;
};
const assertAndDecodeBytes = (name, type, arg) => {
    try {
        return decodeBytes(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assertArgumentType(name, type, arg));
    }
    catch (error) {
        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;
        throw error;
    }
};
const assertAndDecodeNumber = (name, type, arg) => {
    try {
        return decodeNumber(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assertArgumentType(name, type, arg));
    }
    catch (error) {
        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;
        throw error;
    }
};
const assertAndDecodeAddress = (name, type, arg) => {
    try {
        return Ox(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assertArgumentType(name, type, arg));
    }
    catch (error) {
        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;
        throw error;
    }
};
const defaultPayload = {
    name: "p",
    type: RenVMType.ExtEthCompatPayload,
    value: {
        abi: "W10=",
        value: "",
        fn: "",
    },
};
const findField = (field, response) => {
    for (const outField of response.tx.out || []) {
        if (outField.name === field) {
            return outField;
        }
    }
    for (const outField of response.tx.autogen) {
        if (outField.name === field) {
            return outField;
        }
    }
    for (const outField of response.tx.in) {
        if (outField.name === field) {
            return outField;
        }
    }
    throw new Error(`Unable to find field ${field} in response from RenVM.`);
};
const onError = (getP, defaultP) => {
    try {
        return getP();
    }
    catch (error) {
        return defaultP;
    }
};
export const unmarshalMintTx = (response, logger = NullLogger) => {
    // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.
    const pRaw = assertArgumentType("p", RenVMType.ExtEthCompatPayload, onError(() => findField("p", response), defaultPayload));
    const token = assertAndDecodeAddress("token", RenVMType.ExtTypeEthCompatAddress, findField("token", response));
    const to = assertAndDecodeAddress("to", RenVMType.ExtTypeEthCompatAddress, findField("to", response));
    const n = assertAndDecodeBytes("n", RenVMType.B32, findField("n", response));
    const p = {
        abi: JSON.parse(decodeString(pRaw.abi)),
        value: decodeBytes(pRaw.value),
        fn: decodeString(pRaw.fn),
    };
    const phash = assertAndDecodeBytes("phash", RenVMType.B32, findField("phash", response));
    const ghash = assertAndDecodeBytes("ghash", RenVMType.B32, findField("ghash", response));
    const nhash = assertAndDecodeBytes("nhash", RenVMType.B32, findField("nhash", response));
    const amount = assertAndDecodeNumber("amount", RenVMType.U256, findField("amount", response)).toFixed();
    const utxoRaw = assertArgumentType("utxo", RenVMType.ExtTypeBtcCompatUTXO, findField("utxo", response));
    const sighash = assertAndDecodeBytes("sighash", RenVMType.B32, findField("sighash", response));
    const utxo = {
        txHash: Ox(decodeBytes(utxoRaw.txHash), { prefix: "" }),
        vOut: parseInt(utxoRaw.vOut, 10),
        scriptPubKey: utxoRaw.scriptPubKey
            ? Ox(decodeBytes(utxoRaw.scriptPubKey), { prefix: "" })
            : "",
        amount: decodeNumber(utxoRaw.amount).toFixed(),
    };
    const out = {
        sighash,
        ghash,
        nhash,
        phash,
        amount,
    };
    if (response.tx.out) {
        const [rArg, sArg, vArg] = [
            findField("r", response),
            findField("s", response),
            findField("v", response),
        ];
        const r = rArg.type === RenVMType.B
            ? assertAndDecodeBytes("r", RenVMType.B, rArg)
            : assertAndDecodeBytes("r", RenVMType.B32, rArg);
        const s = sArg.type === RenVMType.B
            ? assertAndDecodeBytes("s", RenVMType.B, sArg)
            : assertAndDecodeBytes("s", RenVMType.B32, sArg);
        const v = vArg.type === RenVMType.B
            ? assertAndDecodeBytes("v", RenVMType.B, vArg)[0]
            : assertAndDecodeNumber("v", RenVMType.U8, vArg).toNumber();
        const signature = signatureToBuffer(fixSignature(r, s, v, sighash, phash, amount, to, token, nhash, false, logger));
        out.signature = signature; // r, s, v
    }
    return {
        hash: toBase64(decodeBytes(response.tx.hash)),
        txStatus: response.txStatus,
        to: response.tx.to,
        in: { p, token, to, n, utxo },
        out,
    };
};
export const unmarshalBurnTx = (response) => {
    // TODO: Check that result is burn response.
    // assert(
    //     parseV1Selector(response.tx.to).from === Chain.Ethereum,
    //     `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.to})`
    // );
    const [refArg, toArg, amountArg] = response.tx.in;
    const ref = assertAndDecodeNumber("ref", RenVMType.U64, refArg).toFixed();
    const toRaw = assertArgumentType("to", RenVMType.B, toArg);
    let amount;
    try {
        amount = assertAndDecodeNumber("amount", RenVMType.U256, amountArg).toFixed();
    }
    catch (error) {
        amount = assertAndDecodeNumber("amount", RenVMType.U64, amountArg).toFixed();
    }
    const to = toRaw;
    // response.tx.to === Tokens.ZEC.Eth2Zec ?
    //     utils.zec.addressFrom(toRaw) :
    //     response.tx.to === Tokens.BCH.Eth2Bch ?
    //         utils.bch.addressFrom(toRaw) :
    //         utils.btc.addressFrom(toRaw);
    return {
        hash: toBase64(decodeBytes(response.tx.hash)),
        to: response.tx.to,
        in: { ref, to, amount },
        txStatus: response.txStatus,
    };
};
const unmarshalAssetFees = (fees) => {
    const { lock, release } = fees, tokens = __rest(fees, ["lock", "release"]);
    // TODO: Fix type errors.
    return Object.assign({ lock: decodeNumber(lock), release: decodeNumber(release) }, Object.keys(tokens).reduce((acc, token) => (Object.assign(Object.assign({}, acc), { [token]: {
            mint: decodeNumber(fees[token].mint).toNumber(),
            burn: decodeNumber(fees[token].burn).toNumber(),
        } })), {}));
};
export const unmarshalFees = (response) => {
    const fees = {};
    for (const key of Object.keys(response)) {
        fees[key] = unmarshalAssetFees(response[key]);
    }
    return fees;
};
//# sourceMappingURL=unmarshal.js.map