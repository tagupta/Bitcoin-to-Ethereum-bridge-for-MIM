var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getRenNetworkDetails, NullLogger, TxStatus, } from "@renproject/interfaces";
import { HttpProvider } from "@renproject/provider";
import { assertType, fromBase64, isDefined, SECONDS, sleep, toURLBase64, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { RPCMethod, } from "./methods";
import { unmarshalTypedPackValue } from "./pack/pack";
import { hashTransaction, mintParamsType, submitGatewayType, } from "./transaction";
import { unmarshalBurnTx, unmarshalMintTx } from "./unmarshal";
export const resolveV2Contract = ({ asset, from, to, }) => {
    if (from.assetIsNative &&
        from.assetIsNative(asset)) {
        return `${asset}/to${to.name}`;
    }
    if (to.assetIsNative &&
        to.assetIsNative(asset)) {
        return `${asset}/from${from.name}`;
    }
    return `${asset}/from${from.name}To${to.name}`;
};
export class RenVMProvider {
    constructor(network, provider, logger = NullLogger) {
        this.version = () => 2;
        this.sendMessage = (method, request, retry, timeout) => {
            return this.provider.sendMessage(method, request, retry, timeout);
        };
        this.selector = (params) => {
            return resolveV2Contract(params);
        };
        this.queryBlock = (blockHeight, retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.QueryBlock, { blockHeight }, retry);
        });
        this.queryBlocks = (blockHeight, n, retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.QueryBlocks, { blockHeight, n }, retry);
        });
        this.submitGateway = (gateway, tx, retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.SubmitGateway, { gateway, tx }, retry);
        });
        this.submitTx = (tx, retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.SubmitTx, { tx }, retry);
        });
        this.queryTx = (txHash, retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.QueryTx, { txHash }, retry);
        });
        this.queryTxs = (tags, page, pageSize, txStatus, retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.QueryTxs, {
                tags,
                page: (page || 0).toString(),
                pageSize: (pageSize || 0).toString(),
                txStatus,
            }, retry);
        });
        this.queryConfig = (retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.QueryConfig, {}, retry);
        });
        /**
         * @deprecated - use `queryBlockState` instead.
         */
        this.queryState = (retry) => __awaiter(this, void 0, void 0, function* () { return this.sendMessage(RPCMethod.QueryState, {}, retry); });
        this.queryBlockState = (retry) => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(RPCMethod.QueryBlockState, {}, retry);
        });
        this.buildGateway = ({ selector, gHash, gPubKey, nHash, nonce, payload, pHash, to, transactionVersion, }) => {
            assertType("Buffer", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
            });
            assertType("string", { to });
            const version = isDefined(transactionVersion)
                ? String(transactionVersion)
                : "1";
            const txIn = {
                t: submitGatewayType(),
                v: {
                    ghash: toURLBase64(gHash),
                    gpubkey: toURLBase64(gPubKey),
                    nhash: toURLBase64(nHash),
                    nonce: toURLBase64(nonce),
                    payload: toURLBase64(payload),
                    phash: toURLBase64(pHash),
                    to,
                },
            };
            return {
                selector: selector,
                version,
                // TODO: Fix types
                in: txIn,
            };
        };
        this.buildTransaction = ({ selector, gHash, gPubKey, nHash, nonce, output, amount, payload, pHash, to, transactionVersion, }) => {
            assertType("Buffer", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
                txid: output.txid,
            });
            assertType("string", { to, amount, txindex: output.txindex });
            const version = isDefined(transactionVersion)
                ? String(transactionVersion)
                : "1";
            const txIn = {
                t: mintParamsType(),
                v: {
                    txid: toURLBase64(output.txid),
                    txindex: output.txindex,
                    ghash: toURLBase64(gHash),
                    gpubkey: toURLBase64(gPubKey),
                    nhash: toURLBase64(nHash),
                    nonce: toURLBase64(nonce),
                    payload: toURLBase64(payload),
                    phash: toURLBase64(pHash),
                    to,
                    amount,
                },
            };
            return {
                hash: toURLBase64(hashTransaction(version, selector, txIn)),
                selector: selector,
                version,
                // TODO: Fix types
                in: txIn,
            };
        };
        this.mintTxHash = (params) => {
            return fromBase64(this.buildTransaction(params).hash);
        };
        this.submitMint = (params, retries) => __awaiter(this, void 0, void 0, function* () {
            const tx = this.buildTransaction(params);
            yield this.submitTx(tx, retries);
            return fromBase64(tx.hash);
        });
        this.submitGatewayDetails = (gateway, params, retries) => __awaiter(this, void 0, void 0, function* () {
            const tx = this.buildGateway(params);
            yield this.submitGateway(gateway, tx, retries);
            return gateway;
        });
        this.burnTxHash = this.mintTxHash;
        this.submitBurn = this.submitMint;
        /**
         * Queries the result of a RenVM transaction and unmarshals the result into
         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
         *
         * @param renVMTxHash The transaction hash as a Buffer.
         */
        this.queryMintOrBurn = (_selector, renVMTxHash, retries) => __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.queryTx(toURLBase64(renVMTxHash), retries);
                // Unmarshal transaction.
                // TODO: Improve mint/burn detection. Currently checks if the format
                // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return
                // a false positive if the chain name contains `To`.
                const isMint = /((\/to)|(To))/.exec(response.tx.selector);
                if (isMint) {
                    return unmarshalMintTx(response);
                }
                else {
                    return unmarshalBurnTx(response);
                }
            }
            catch (error) {
                throw error;
            }
        });
        /**
         * Fetches the result of a RenVM transaction on a repeated basis until the
         * transaction's status is `"done"`.
         *
         * @param utxoTxHash The transaction hash as a Buffer.
         * @param onStatus A callback called each time the status of the transaction
         * is refreshed - even if it hasn't changed.
         * @param _cancelRequested A function that returns `true` to cancel the
         * loop.
         */
        this.waitForTX = (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => __awaiter(this, void 0, void 0, function* () {
            assertType("Buffer", { utxoTxHash });
            let rawResponse;
            while (true) {
                if (_cancelRequested && _cancelRequested()) {
                    throw new Error(`waitForTX cancelled.`);
                }
                try {
                    const result = yield this.queryMintOrBurn(selector, utxoTxHash);
                    if (result && result.txStatus === TxStatus.TxStatusDone) {
                        rawResponse = result;
                        break;
                    }
                    else if (onStatus && result && result.txStatus) {
                        onStatus(result.txStatus);
                    }
                }
                catch (error) {
                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {
                        // ignore
                    }
                    else {
                        this.logger.error(String(error));
                        // TODO: throw unexpected errors
                    }
                }
                yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);
            }
            return rawResponse;
        });
        /**
         * selectPublicKey fetches the public key for the RenVM shard handling
         * the provided contract.
         *
         * @param chain The chain for which the public key should be fetched.
         * @returns The public key hash (20 bytes) as a string.
         */
        this.selectPublicKey = (selector, _chain) => __awaiter(this, void 0, void 0, function* () {
            const asset = selector.split("/")[0];
            // Call the ren_queryBlockState RPC.
            const renVMState = yield this.queryBlockState(5);
            const blockState = unmarshalTypedPackValue(renVMState.state);
            if (!blockState[asset]) {
                throw new Error(`No RenVM block state found for ${asset}.`);
            }
            const pubKey = blockState[asset].shards[0].pubKey;
            if (!pubKey || pubKey.length === 0) {
                throw new Error(`Unable to fetch RenVM public key for ${asset}.`);
            }
            return fromBase64(pubKey);
        });
        // In the future, this will be asynchronous. It returns a promise for
        // compatibility.
        // eslint-disable-next-line @typescript-eslint/require-await
        this.getNetwork = (_selector) => __awaiter(this, void 0, void 0, function* () {
            return this.network;
        });
        this.getConfirmationTarget = (_selector, chain) => __awaiter(this, void 0, void 0, function* () {
            const renVMConfig = yield this.sendMessage(RPCMethod.QueryConfig, {});
            return parseInt(renVMConfig.confirmations[chain.name], 10);
        });
        this.estimateTransactionFee = (asset, _lockChain, hostChain) => __awaiter(this, void 0, void 0, function* () {
            const renVMState = yield this.queryBlockState();
            const blockState = unmarshalTypedPackValue(renVMState.state);
            if (!blockState[asset]) {
                throw new Error(`No fee details found for ${asset}`);
            }
            const { gasLimit, gasCap } = blockState[asset];
            const fee = new BigNumber(gasLimit).times(new BigNumber(gasCap));
            const mintAndBurnFees = blockState[asset].fees.chains.filter((chainFees) => chainFees.chain === hostChain.name)[0];
            return {
                lock: fee,
                release: fee,
                mint: mintAndBurnFees && mintAndBurnFees.mintFee
                    ? mintAndBurnFees.mintFee.toNumber()
                    : 15,
                burn: mintAndBurnFees && mintAndBurnFees.burnFee
                    ? mintAndBurnFees.burnFee.toNumber()
                    : 15,
            };
        });
        if (!provider || typeof provider === "string") {
            const rpcUrl = provider || (getRenNetworkDetails(network) || {}).lightnode;
            try {
                provider = new HttpProvider(rpcUrl, logger);
            }
            catch (error) {
                if (/Invalid node URL/.exec(String(error && error.message))) {
                    throw new Error(`Invalid network or provider URL: "${(getRenNetworkDetails(network) || {}).name ||
                        String(network)}"`);
                }
                throw error;
            }
        }
        this.network = network;
        this.logger = logger;
        this.provider = provider;
    }
}
//# sourceMappingURL=renVMProvider.js.map