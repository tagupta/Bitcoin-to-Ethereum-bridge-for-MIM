/// <reference types="node" />
import { BurnAndReleaseTransaction, LockAndMintTransaction, LockChain, Logger, MintChain, RenNetwork, RenNetworkDetails, RenNetworkString, SyncOrPromise, TxStatus } from "@renproject/interfaces";
import { Provider } from "@renproject/provider";
import BigNumber from "bignumber.js";
import { AbstractRenVMProvider } from "../abstract";
import { ParamsQueryBlock, ParamsQueryBlocks, ParamsQueryTx, ParamsQueryTxs, ParamsSubmitBurn, ParamsSubmitGateway, ParamsSubmitMint, RenVMParams, RenVMResponses, RPCMethod } from "./methods";
import { MintTransactionInput, SubmitGatewayInput } from "./transaction";
export declare const resolveV2Contract: ({ asset, from, to, }: {
    asset: string;
    from: LockChain<any, any, any> | MintChain<any, any>;
    to: LockChain<any, any, any> | MintChain<any, any>;
}) => string;
export declare class RenVMProvider implements AbstractRenVMProvider<RenVMParams, RenVMResponses> {
    version: () => number;
    private readonly network;
    readonly provider: Provider<RenVMParams, RenVMResponses>;
    private readonly logger;
    constructor(network: RenNetwork | RenNetworkString | RenNetworkDetails, provider?: Provider<RenVMParams, RenVMResponses> | string, logger?: Logger);
    sendMessage: <Method extends RPCMethod>(method: Method, request: RenVMParams[Method], retry?: number | undefined, timeout?: number | undefined) => SyncOrPromise<RenVMResponses[Method]>;
    selector: (params: {
        asset: string;
        from: LockChain<any, any, any> | MintChain<any, any>;
        to: LockChain<any, any, any> | MintChain<any, any>;
    }) => string;
    queryBlock: (blockHeight: ParamsQueryBlock["blockHeight"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryBlock>;
    queryBlocks: (blockHeight: ParamsQueryBlocks["blockHeight"], n: ParamsQueryBlocks["n"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryBlocks>;
    submitGateway: (gateway: ParamsSubmitGateway["gateway"], tx: ParamsSubmitGateway["tx"], retry?: number | undefined) => Promise<import("./methods").ResponseSubmitGateway>;
    submitTx: (tx: ParamsSubmitBurn["tx"] | ParamsSubmitMint["tx"], retry?: number | undefined) => Promise<import("./methods").ResponseSubmitTx>;
    queryTx: (txHash: ParamsQueryTx["txHash"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryTx>;
    queryTxs: (tags: ParamsQueryTxs["tags"], page?: number | undefined, pageSize?: number | undefined, txStatus?: ParamsQueryTxs["txStatus"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryTxs>;
    queryConfig: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryConfig>;
    /**
     * @deprecated - use `queryBlockState` instead.
     */
    queryState: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryState>;
    queryBlockState: (retry?: number | undefined) => Promise<import("./methods/ren_queryBlockState").ResponseQueryBlockState>;
    buildGateway: ({ selector, gHash, gPubKey, nHash, nonce, payload, pHash, to, transactionVersion, }: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number | undefined;
    }) => SubmitGatewayInput;
    buildTransaction: ({ selector, gHash, gPubKey, nHash, nonce, output, amount, payload, pHash, to, transactionVersion, }: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        output: {
            txid: Buffer;
            txindex: string;
        };
        amount: string;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number | undefined;
    }) => MintTransactionInput;
    mintTxHash: (params: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        output: {
            txindex: string;
            txid: Buffer;
        };
        amount: string;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number;
    }) => Buffer;
    submitMint: (params: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        output: {
            txindex: string;
            txid: Buffer;
        };
        amount: string;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number;
    }, retries?: number | undefined) => Promise<Buffer>;
    submitGatewayDetails: (gateway: string, params: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number;
    }, retries?: number | undefined) => Promise<string>;
    burnTxHash: (params: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        output: {
            txindex: string;
            txid: Buffer;
        };
        amount: string;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number;
    }) => Buffer;
    submitBurn: (params: {
        selector: string;
        gHash: Buffer;
        gPubKey: Buffer;
        nHash: Buffer;
        nonce: Buffer;
        output: {
            txindex: string;
            txid: Buffer;
        };
        amount: string;
        payload: Buffer;
        pHash: Buffer;
        to: string;
        transactionVersion?: number;
    }, retries?: number | undefined) => Promise<Buffer>;
    /**
     * Queries the result of a RenVM transaction and unmarshals the result into
     * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
     *
     * @param renVMTxHash The transaction hash as a Buffer.
     */
    readonly queryMintOrBurn: <T extends LockAndMintTransaction | BurnAndReleaseTransaction>(_selector: string, renVMTxHash: Buffer, retries?: number | undefined) => Promise<T>;
    /**
     * Fetches the result of a RenVM transaction on a repeated basis until the
     * transaction's status is `"done"`.
     *
     * @param utxoTxHash The transaction hash as a Buffer.
     * @param onStatus A callback called each time the status of the transaction
     * is refreshed - even if it hasn't changed.
     * @param _cancelRequested A function that returns `true` to cancel the
     * loop.
     */
    readonly waitForTX: <T extends LockAndMintTransaction | BurnAndReleaseTransaction>(selector: string, utxoTxHash: Buffer, onStatus?: ((status: TxStatus) => void) | undefined, _cancelRequested?: (() => boolean) | undefined, timeout?: number | undefined) => Promise<T>;
    /**
     * selectPublicKey fetches the public key for the RenVM shard handling
     * the provided contract.
     *
     * @param chain The chain for which the public key should be fetched.
     * @returns The public key hash (20 bytes) as a string.
     */
    readonly selectPublicKey: (selector: string, _chain: string) => Promise<Buffer>;
    getNetwork: (_selector: string) => Promise<RenNetwork>;
    getConfirmationTarget: (_selector: string, chain: {
        name: string;
    }) => Promise<number>;
    estimateTransactionFee: (asset: string, _lockChain: {
        name: string;
    }, hostChain: {
        name: string;
    }) => Promise<{
        lock: BigNumber;
        release: BigNumber;
        mint: number;
        burn: number;
    }>;
}
