"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenVMProvider = exports.resolveV2Contract = void 0;
const interfaces_1 = require("@renproject/interfaces");
const provider_1 = require("@renproject/provider");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const methods_1 = require("./methods");
const pack_1 = require("./pack/pack");
const transaction_1 = require("./transaction");
const unmarshal_1 = require("./unmarshal");
const resolveV2Contract = ({ asset, from, to, }) => {
    if (from.assetIsNative &&
        from.assetIsNative(asset)) {
        return `${asset}/to${to.name}`;
    }
    if (to.assetIsNative &&
        to.assetIsNative(asset)) {
        return `${asset}/from${from.name}`;
    }
    return `${asset}/from${from.name}To${to.name}`;
};
exports.resolveV2Contract = resolveV2Contract;
class RenVMProvider {
    constructor(network, provider, logger = interfaces_1.NullLogger) {
        this.version = () => 2;
        this.sendMessage = (method, request, retry, timeout) => {
            return this.provider.sendMessage(method, request, retry, timeout);
        };
        this.selector = (params) => {
            return exports.resolveV2Contract(params);
        };
        this.queryBlock = async (blockHeight, retry) => this.sendMessage(methods_1.RPCMethod.QueryBlock, { blockHeight }, retry);
        this.queryBlocks = async (blockHeight, n, retry) => this.sendMessage(methods_1.RPCMethod.QueryBlocks, { blockHeight, n }, retry);
        this.submitGateway = async (gateway, tx, retry) => this.sendMessage(methods_1.RPCMethod.SubmitGateway, { gateway, tx }, retry);
        this.submitTx = async (tx, retry) => this.sendMessage(methods_1.RPCMethod.SubmitTx, { tx }, retry);
        this.queryTx = async (txHash, retry) => this.sendMessage(methods_1.RPCMethod.QueryTx, { txHash }, retry);
        this.queryTxs = async (tags, page, pageSize, txStatus, retry) => this.sendMessage(methods_1.RPCMethod.QueryTxs, {
            tags,
            page: (page || 0).toString(),
            pageSize: (pageSize || 0).toString(),
            txStatus,
        }, retry);
        this.queryConfig = async (retry) => this.sendMessage(methods_1.RPCMethod.QueryConfig, {}, retry);
        /**
         * @deprecated - use `queryBlockState` instead.
         */
        this.queryState = async (retry) => this.sendMessage(methods_1.RPCMethod.QueryState, {}, retry);
        this.queryBlockState = async (retry) => this.sendMessage(methods_1.RPCMethod.QueryBlockState, {}, retry);
        this.buildGateway = ({ selector, gHash, gPubKey, nHash, nonce, payload, pHash, to, transactionVersion, }) => {
            utils_1.assertType("Buffer", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
            });
            utils_1.assertType("string", { to });
            const version = utils_1.isDefined(transactionVersion)
                ? String(transactionVersion)
                : "1";
            const txIn = {
                t: transaction_1.submitGatewayType(),
                v: {
                    ghash: utils_1.toURLBase64(gHash),
                    gpubkey: utils_1.toURLBase64(gPubKey),
                    nhash: utils_1.toURLBase64(nHash),
                    nonce: utils_1.toURLBase64(nonce),
                    payload: utils_1.toURLBase64(payload),
                    phash: utils_1.toURLBase64(pHash),
                    to,
                },
            };
            return {
                selector: selector,
                version,
                // TODO: Fix types
                in: txIn,
            };
        };
        this.buildTransaction = ({ selector, gHash, gPubKey, nHash, nonce, output, amount, payload, pHash, to, transactionVersion, }) => {
            utils_1.assertType("Buffer", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
                txid: output.txid,
            });
            utils_1.assertType("string", { to, amount, txindex: output.txindex });
            const version = utils_1.isDefined(transactionVersion)
                ? String(transactionVersion)
                : "1";
            const txIn = {
                t: transaction_1.mintParamsType(),
                v: {
                    txid: utils_1.toURLBase64(output.txid),
                    txindex: output.txindex,
                    ghash: utils_1.toURLBase64(gHash),
                    gpubkey: utils_1.toURLBase64(gPubKey),
                    nhash: utils_1.toURLBase64(nHash),
                    nonce: utils_1.toURLBase64(nonce),
                    payload: utils_1.toURLBase64(payload),
                    phash: utils_1.toURLBase64(pHash),
                    to,
                    amount,
                },
            };
            return {
                hash: utils_1.toURLBase64(transaction_1.hashTransaction(version, selector, txIn)),
                selector: selector,
                version,
                // TODO: Fix types
                in: txIn,
            };
        };
        this.mintTxHash = (params) => {
            return utils_1.fromBase64(this.buildTransaction(params).hash);
        };
        this.submitMint = async (params, retries) => {
            const tx = this.buildTransaction(params);
            await this.submitTx(tx, retries);
            return utils_1.fromBase64(tx.hash);
        };
        this.submitGatewayDetails = async (gateway, params, retries) => {
            const tx = this.buildGateway(params);
            await this.submitGateway(gateway, tx, retries);
            return gateway;
        };
        this.burnTxHash = this.mintTxHash;
        this.submitBurn = this.submitMint;
        /**
         * Queries the result of a RenVM transaction and unmarshals the result into
         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
         *
         * @param renVMTxHash The transaction hash as a Buffer.
         */
        this.queryMintOrBurn = async (_selector, renVMTxHash, retries) => {
            try {
                const response = await this.queryTx(utils_1.toURLBase64(renVMTxHash), retries);
                // Unmarshal transaction.
                // TODO: Improve mint/burn detection. Currently checks if the format
                // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return
                // a false positive if the chain name contains `To`.
                const isMint = /((\/to)|(To))/.exec(response.tx.selector);
                if (isMint) {
                    return unmarshal_1.unmarshalMintTx(response);
                }
                else {
                    return unmarshal_1.unmarshalBurnTx(response);
                }
            }
            catch (error) {
                throw error;
            }
        };
        /**
         * Fetches the result of a RenVM transaction on a repeated basis until the
         * transaction's status is `"done"`.
         *
         * @param utxoTxHash The transaction hash as a Buffer.
         * @param onStatus A callback called each time the status of the transaction
         * is refreshed - even if it hasn't changed.
         * @param _cancelRequested A function that returns `true` to cancel the
         * loop.
         */
        this.waitForTX = async (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => {
            utils_1.assertType("Buffer", { utxoTxHash });
            let rawResponse;
            while (true) {
                if (_cancelRequested && _cancelRequested()) {
                    throw new Error(`waitForTX cancelled.`);
                }
                try {
                    const result = await this.queryMintOrBurn(selector, utxoTxHash);
                    if (result && result.txStatus === interfaces_1.TxStatus.TxStatusDone) {
                        rawResponse = result;
                        break;
                    }
                    else if (onStatus && result && result.txStatus) {
                        onStatus(result.txStatus);
                    }
                }
                catch (error) {
                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {
                        // ignore
                    }
                    else {
                        this.logger.error(String(error));
                        // TODO: throw unexpected errors
                    }
                }
                await utils_1.sleep(utils_1.isDefined(timeout) ? timeout : 15 * utils_1.SECONDS);
            }
            return rawResponse;
        };
        /**
         * selectPublicKey fetches the public key for the RenVM shard handling
         * the provided contract.
         *
         * @param chain The chain for which the public key should be fetched.
         * @returns The public key hash (20 bytes) as a string.
         */
        this.selectPublicKey = async (selector, _chain) => {
            const asset = selector.split("/")[0];
            // Call the ren_queryBlockState RPC.
            const renVMState = await this.queryBlockState(5);
            const blockState = pack_1.unmarshalTypedPackValue(renVMState.state);
            if (!blockState[asset]) {
                throw new Error(`No RenVM block state found for ${asset}.`);
            }
            const pubKey = blockState[asset].shards[0].pubKey;
            if (!pubKey || pubKey.length === 0) {
                throw new Error(`Unable to fetch RenVM public key for ${asset}.`);
            }
            return utils_1.fromBase64(pubKey);
        };
        // In the future, this will be asynchronous. It returns a promise for
        // compatibility.
        // eslint-disable-next-line @typescript-eslint/require-await
        this.getNetwork = async (_selector) => {
            return this.network;
        };
        this.getConfirmationTarget = async (_selector, chain) => {
            const renVMConfig = await this.sendMessage(methods_1.RPCMethod.QueryConfig, {});
            return parseInt(renVMConfig.confirmations[chain.name], 10);
        };
        this.estimateTransactionFee = async (asset, _lockChain, hostChain) => {
            const renVMState = await this.queryBlockState();
            const blockState = pack_1.unmarshalTypedPackValue(renVMState.state);
            if (!blockState[asset]) {
                throw new Error(`No fee details found for ${asset}`);
            }
            const { gasLimit, gasCap } = blockState[asset];
            const fee = new bignumber_js_1.default(gasLimit).times(new bignumber_js_1.default(gasCap));
            const mintAndBurnFees = blockState[asset].fees.chains.filter((chainFees) => chainFees.chain === hostChain.name)[0];
            return {
                lock: fee,
                release: fee,
                mint: mintAndBurnFees && mintAndBurnFees.mintFee
                    ? mintAndBurnFees.mintFee.toNumber()
                    : 15,
                burn: mintAndBurnFees && mintAndBurnFees.burnFee
                    ? mintAndBurnFees.burnFee.toNumber()
                    : 15,
            };
        };
        if (!provider || typeof provider === "string") {
            const rpcUrl = provider || (interfaces_1.getRenNetworkDetails(network) || {}).lightnode;
            try {
                provider = new provider_1.HttpProvider(rpcUrl, logger);
            }
            catch (error) {
                if (/Invalid node URL/.exec(String(error && error.message))) {
                    throw new Error(`Invalid network or provider URL: "${(interfaces_1.getRenNetworkDetails(network) || {}).name ||
                        String(network)}"`);
                }
                throw error;
            }
        }
        this.network = network;
        this.logger = logger;
        this.provider = provider;
    }
}
exports.RenVMProvider = RenVMProvider;
//# sourceMappingURL=renVMProvider.js.map