"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unmarshalFees = exports.unmarshalBurnTx = exports.unmarshalMintTx = void 0;
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const value_1 = require("./value");
const decodeString = (input) => utils_1.fromBase64(input).toString();
const decodeBytes = (input) => utils_1.fromBase64(input);
const decodeNumber = (input) => new bignumber_js_1.default(input);
/**
 * Validate an argument returned from RenVM.
 *
 * @param name The expected name.
 * @param type The expected type.
 * @param arg The actual argument returned.
 */
const assertArgumentType = (name, type, arg) => {
    utils_1.assert(arg.type === type, `Expected argument ${name} of type ${type} but got ${arg.name} of type ${arg.type}`);
    return arg.value;
};
const assertAndDecodeBytes = (name, type, arg) => {
    try {
        return decodeBytes(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assertArgumentType(name, type, arg));
    }
    catch (error) {
        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;
        throw error;
    }
};
const assertAndDecodeNumber = (name, type, arg) => {
    try {
        return decodeNumber(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assertArgumentType(name, type, arg));
    }
    catch (error) {
        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;
        throw error;
    }
};
const assertAndDecodeAddress = (name, type, arg) => {
    try {
        return utils_1.Ox(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assertArgumentType(name, type, arg));
    }
    catch (error) {
        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;
        throw error;
    }
};
const defaultPayload = {
    name: "p",
    type: value_1.RenVMType.ExtEthCompatPayload,
    value: {
        abi: "W10=",
        value: "",
        fn: "",
    },
};
const findField = (field, response) => {
    for (const outField of response.tx.out || []) {
        if (outField.name === field) {
            return outField;
        }
    }
    for (const outField of response.tx.autogen) {
        if (outField.name === field) {
            return outField;
        }
    }
    for (const outField of response.tx.in) {
        if (outField.name === field) {
            return outField;
        }
    }
    throw new Error(`Unable to find field ${field} in response from RenVM.`);
};
const onError = (getP, defaultP) => {
    try {
        return getP();
    }
    catch (error) {
        return defaultP;
    }
};
const unmarshalMintTx = (response, logger = interfaces_1.NullLogger) => {
    // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.
    const pRaw = assertArgumentType("p", value_1.RenVMType.ExtEthCompatPayload, onError(() => findField("p", response), defaultPayload));
    const token = assertAndDecodeAddress("token", value_1.RenVMType.ExtTypeEthCompatAddress, findField("token", response));
    const to = assertAndDecodeAddress("to", value_1.RenVMType.ExtTypeEthCompatAddress, findField("to", response));
    const n = assertAndDecodeBytes("n", value_1.RenVMType.B32, findField("n", response));
    const p = {
        abi: JSON.parse(decodeString(pRaw.abi)),
        value: decodeBytes(pRaw.value),
        fn: decodeString(pRaw.fn),
    };
    const phash = assertAndDecodeBytes("phash", value_1.RenVMType.B32, findField("phash", response));
    const ghash = assertAndDecodeBytes("ghash", value_1.RenVMType.B32, findField("ghash", response));
    const nhash = assertAndDecodeBytes("nhash", value_1.RenVMType.B32, findField("nhash", response));
    const amount = assertAndDecodeNumber("amount", value_1.RenVMType.U256, findField("amount", response)).toFixed();
    const utxoRaw = assertArgumentType("utxo", value_1.RenVMType.ExtTypeBtcCompatUTXO, findField("utxo", response));
    const sighash = assertAndDecodeBytes("sighash", value_1.RenVMType.B32, findField("sighash", response));
    const utxo = {
        txHash: utils_1.Ox(decodeBytes(utxoRaw.txHash), { prefix: "" }),
        vOut: parseInt(utxoRaw.vOut, 10),
        scriptPubKey: utxoRaw.scriptPubKey
            ? utils_1.Ox(decodeBytes(utxoRaw.scriptPubKey), { prefix: "" })
            : "",
        amount: decodeNumber(utxoRaw.amount).toFixed(),
    };
    const out = {
        sighash,
        ghash,
        nhash,
        phash,
        amount,
    };
    if (response.tx.out) {
        const [rArg, sArg, vArg] = [
            findField("r", response),
            findField("s", response),
            findField("v", response),
        ];
        const r = rArg.type === value_1.RenVMType.B
            ? assertAndDecodeBytes("r", value_1.RenVMType.B, rArg)
            : assertAndDecodeBytes("r", value_1.RenVMType.B32, rArg);
        const s = sArg.type === value_1.RenVMType.B
            ? assertAndDecodeBytes("s", value_1.RenVMType.B, sArg)
            : assertAndDecodeBytes("s", value_1.RenVMType.B32, sArg);
        const v = vArg.type === value_1.RenVMType.B
            ? assertAndDecodeBytes("v", value_1.RenVMType.B, vArg)[0]
            : assertAndDecodeNumber("v", value_1.RenVMType.U8, vArg).toNumber();
        const signature = utils_1.signatureToBuffer(utils_1.fixSignature(r, s, v, sighash, phash, amount, to, token, nhash, false, logger));
        out.signature = signature; // r, s, v
    }
    return {
        hash: utils_1.toBase64(decodeBytes(response.tx.hash)),
        txStatus: response.txStatus,
        to: response.tx.to,
        in: { p, token, to, n, utxo },
        out,
    };
};
exports.unmarshalMintTx = unmarshalMintTx;
const unmarshalBurnTx = (response) => {
    // TODO: Check that result is burn response.
    // assert(
    //     parseV1Selector(response.tx.to).from === Chain.Ethereum,
    //     `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.to})`
    // );
    const [refArg, toArg, amountArg] = response.tx.in;
    const ref = assertAndDecodeNumber("ref", value_1.RenVMType.U64, refArg).toFixed();
    const toRaw = assertArgumentType("to", value_1.RenVMType.B, toArg);
    let amount;
    try {
        amount = assertAndDecodeNumber("amount", value_1.RenVMType.U256, amountArg).toFixed();
    }
    catch (error) {
        amount = assertAndDecodeNumber("amount", value_1.RenVMType.U64, amountArg).toFixed();
    }
    const to = toRaw;
    // response.tx.to === Tokens.ZEC.Eth2Zec ?
    //     utils.zec.addressFrom(toRaw) :
    //     response.tx.to === Tokens.BCH.Eth2Bch ?
    //         utils.bch.addressFrom(toRaw) :
    //         utils.btc.addressFrom(toRaw);
    return {
        hash: utils_1.toBase64(decodeBytes(response.tx.hash)),
        to: response.tx.to,
        in: { ref, to, amount },
        txStatus: response.txStatus,
    };
};
exports.unmarshalBurnTx = unmarshalBurnTx;
const unmarshalAssetFees = (fees) => {
    const { lock, release } = fees, tokens = __rest(fees, ["lock", "release"]);
    // TODO: Fix type errors.
    return Object.assign({ lock: decodeNumber(lock), release: decodeNumber(release) }, Object.keys(tokens).reduce((acc, token) => (Object.assign(Object.assign({}, acc), { [token]: {
            mint: decodeNumber(fees[token].mint).toNumber(),
            burn: decodeNumber(fees[token].burn).toNumber(),
        } })), {}));
};
const unmarshalFees = (response) => {
    const fees = {};
    for (const key of Object.keys(response)) {
        fees[key] = unmarshalAssetFees(response[key]);
    }
    return fees;
};
exports.unmarshalFees = unmarshalFees;
//# sourceMappingURL=unmarshal.js.map