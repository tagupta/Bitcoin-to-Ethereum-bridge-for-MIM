/// <reference types="node" />
import { AbiItem, BurnAndReleaseTransaction, LockAndMintTransaction, LockChain, Logger, MintChain, RenNetwork, RenNetworkDetails, RenNetworkString, TxStatus } from "@renproject/interfaces";
import { Provider } from "@renproject/provider";
import BigNumber from "bignumber.js";
import { AbstractRenVMProvider } from "../abstract";
import { ParamsQueryBlock, ParamsQueryBlocks, ParamsQueryTx, ParamsQueryTxs, ParamsSubmitBurn, ParamsSubmitMint, RenVMParams, RenVMResponses } from "./methods";
export declare const generateMintTxHash: (selector: string, encodedID: string, deposit: string, logger?: Logger) => Buffer;
export declare class RenVMProvider implements AbstractRenVMProvider<RenVMParams, RenVMResponses> {
    version: () => number;
    private readonly network;
    readonly provider: Provider<RenVMParams, RenVMResponses>;
    sendMessage: RenVMProvider["provider"]["sendMessage"];
    private readonly logger;
    constructor(network: RenNetwork | RenNetworkString | RenNetworkDetails, provider?: Provider<RenVMParams, RenVMResponses>, logger?: Logger);
    selector: ({ asset, from, to, }: {
        asset: string;
        from: LockChain<any, any, any> | MintChain<any, any>;
        to: LockChain<any, any, any> | MintChain<any, any>;
    }) => string;
    queryBlock: (blockHeight: ParamsQueryBlock["blockHeight"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryBlock>;
    queryBlocks: (blockHeight: ParamsQueryBlocks["blockHeight"], n: ParamsQueryBlocks["n"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryBlocks>;
    submitTx: (tx: ParamsSubmitBurn["tx"] | ParamsSubmitMint["tx"], retry?: number | undefined) => Promise<import("./methods").ResponseSubmitTx>;
    queryTx: (txHash: ParamsQueryTx["txHash"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryTx>;
    queryTxs: (tags: ParamsQueryTxs["tags"], page?: number | undefined, pageSize?: number | undefined, txStatus?: ParamsQueryTxs["txStatus"], retry?: number | undefined) => Promise<import("./methods").ResponseQueryTxs>;
    queryNumPeers: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryNumPeers>;
    queryPeers: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryPeers>;
    queryShards: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryShards>;
    queryStat: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryStat>;
    queryFees: (retry?: number | undefined) => Promise<import("./methods").ResponseQueryFees>;
    getFees: () => Promise<import("@renproject/interfaces").RenVMFees>;
    mintTxHash: ({ selector, gHash, outputHashFormat, }: {
        selector: string;
        gHash: Buffer;
        outputHashFormat: string;
    }) => Buffer;
    submitMint: ({ selector, nonce, output, payload, to, token, fn, fnABI, tags, }: {
        selector: string;
        nonce: Buffer;
        output: {
            txindex: string;
            txid: Buffer;
        };
        payload: Buffer;
        to: string;
        token: string;
        fn: string;
        fnABI: AbiItem[];
        tags: [string] | [];
    }) => Promise<Buffer>;
    submitBurn: (params: {
        selector: string;
        tags: [string] | [];
        burnNonce: BigNumber;
    }) => Promise<Buffer>;
    readonly queryMintOrBurn: <T extends LockAndMintTransaction | BurnAndReleaseTransaction>(_selector: string, utxoTxHash: Buffer, retries?: number | undefined) => Promise<T>;
    readonly waitForTX: <T extends LockAndMintTransaction | BurnAndReleaseTransaction>(selector: string, utxoTxHash: Buffer, onStatus?: ((status: TxStatus) => void) | undefined, _cancelRequested?: (() => boolean) | undefined, timeout?: number | undefined) => Promise<T>;
    /**
     * selectPublicKey fetches the public key for the RenVM shard handling
     * the provided contract.
     *
     * @param asset The asset for which the public key should be fetched.
     * @returns The public key hash (20 bytes) as a string.
     */
    readonly selectPublicKey: (_selector: string, asset: string) => Promise<Buffer>;
    getNetwork: (_selector: string) => Promise<RenNetwork>;
    getConfirmationTarget: (selector: string, _chain: {
        name: string;
    }) => Promise<2 | 6 | 12 | 15 | 24 | 30 | undefined>;
    estimateTransactionFee: (_asset: string, _lockChain: {
        name: string;
        legacyName?: string;
    }, hostChain: {
        name: string;
        legacyName?: string;
    }) => Promise<{
        lock: BigNumber;
        release: BigNumber;
        mint: number;
        burn: number;
    }>;
}
