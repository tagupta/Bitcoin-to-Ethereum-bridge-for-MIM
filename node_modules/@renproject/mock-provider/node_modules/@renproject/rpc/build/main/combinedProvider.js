"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CombinedProvider = void 0;
const interfaces_1 = require("@renproject/interfaces");
const v1_1 = require("./v1");
const v2_1 = require("./v2");
const isV1Selector = (selector) => {
    return ([
        "BTC0Btc2Eth",
        "BTC0Eth2Btc",
        "ZEC0Zec2Eth",
        "ZEC0Eth2Zec",
        "BCH0Bch2Eth",
        "BCH0Eth2Bch",
    ].indexOf(selector) >= 0);
};
class CombinedProvider {
    constructor(network, logger = interfaces_1.NullLogger) {
        this.selector = (params) => {
            const v1Selector = this.v1 && this.v1.selector(params);
            return v1Selector && isV1Selector(v1Selector)
                ? v1Selector
                : this.v2.selector(params);
        };
        this.version = (selector) => (isV1Selector(selector) ? 1 : 2);
        this.mintTxHash = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.mintTxHash(params)
            : this.v2.mintTxHash(params);
        this.submitMint = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.submitMint(params)
            : this.v2.submitMint(params);
        this.burnTxHash = (params) => {
            if (isV1Selector(params.selector)) {
                throw new Error(`Fetching burn txHash is not supported for ${params.selector}`);
            }
            return this.v2.burnTxHash(params);
        };
        this.submitBurn = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.submitBurn(params)
            : this.v2.submitBurn(params);
        this.queryMintOrBurn = (selector, utxoTxHash, retries) => this.v1 && isV1Selector(selector)
            ? this.v1.queryMintOrBurn(selector, utxoTxHash, retries)
            : this.v2.queryMintOrBurn(selector, utxoTxHash, retries);
        this.waitForTX = (selector, utxoTxHash, onStatus, cancelRequested, timeout) => this.v1 && isV1Selector(selector)
            ? this.v1.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout)
            : this.v2.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout);
        /**
         * selectPublicKey fetches the key for the RenVM shard handling
         * the provided contract.
         *
         * @returns The key hash (20 bytes) as a string.
         */
        this.selectPublicKey = (selector, assetOrChain) => this.v1 && isV1Selector(selector)
            ? this.v1.selectPublicKey(selector, assetOrChain)
            : this.v2.selectPublicKey(selector, assetOrChain);
        /**
         * Used to query what network a custom provider is connected to. LockAndMint
         * and BurnAndRelease use this to configure their chain parameters.
         */
        this.getNetwork = (selector) => this.v1 && isV1Selector(selector)
            ? this.v1.getNetwork(selector)
            : this.v2.getNetwork(selector);
        this.getConfirmationTarget = async (selector, chain) => this.v1 && isV1Selector(selector)
            ? this.v1.getConfirmationTarget(selector, chain)
            : this.v2.getConfirmationTarget(selector, chain);
        this.estimateTransactionFee = async (asset, lockChain, hostChain) => this.v2.estimateTransactionFee(asset, lockChain, hostChain);
        this.network = interfaces_1.getRenNetworkDetails(network);
        if (this.network.name === interfaces_1.RenNetwork.Mainnet ||
            this.network.name === interfaces_1.RenNetwork.Testnet) {
            this.v1 = new v1_1.RenVMProvider(this.network, undefined, logger);
        }
        this.v2 = new v2_1.RenVMProvider(this.network, undefined, logger);
        // Default to the v2 network.
        this.sendMessage = this.v2.sendMessage;
    }
}
exports.CombinedProvider = CombinedProvider;
//# sourceMappingURL=combinedProvider.js.map