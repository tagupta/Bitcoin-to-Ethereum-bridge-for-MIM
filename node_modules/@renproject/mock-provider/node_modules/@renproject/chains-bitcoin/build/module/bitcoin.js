import { Callable, isHex, utilsWithChainNetwork } from "@renproject/utils";
import { BitcoinBaseChain, } from "./base";
import { validateAddress } from "./utils";
import { Blockstream } from "./APIs/blockstream";
import { Blockchair, BlockchairNetwork } from "./APIs/blockchair";
import { SoChain, SoChainNetwork } from "./APIs/sochain";
import base58 from "bs58";
/**
 * The Bitcoin class adds support for the asset BTC.
 */
export class BitcoinClass extends BitcoinBaseChain {
    constructor() {
        super(...arguments);
        this.chain = BitcoinClass.chain;
        this.name = BitcoinClass.chain;
        this.legacyName = "Btc";
        this.asset = "BTC";
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockstream())
                        .withAPI(Blockchair())
                        .withAPI(SoChain(), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockstream({ testnet: true }))
                        .withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET))
                        .withAPI(SoChain(SoChainNetwork.BTCTEST), { priority: 15 });
                case "regtest":
                    // Will be supported when Electrum is added as an API.
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.utils = utilsWithChainNetwork(BitcoinClass.utils, () => this.chainNetwork);
    }
}
BitcoinClass.chain = "Bitcoin";
// Asset
BitcoinClass.asset = "BTC";
BitcoinClass.utils = {
    resolveChainNetwork: BitcoinBaseChain.utils.resolveChainNetwork,
    p2shPrefix: {
        mainnet: Buffer.from([0x05]),
        testnet: Buffer.from([0xc4]),
    },
    addressBufferToString: base58.encode,
    addressIsValid: (address, network = "mainnet") => validateAddress(address, BitcoinBaseChain.asset, Bitcoin.utils.resolveChainNetwork(network)),
    transactionIsValid: (transaction, _network = "mainnet") => isHex(typeof transaction === "string"
        ? transaction
        : transaction.txHash, { length: 32 }),
    addressExplorerLink: (address, network = "mainnet") => {
        switch (Bitcoin.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return BlockCypher.Address(BlockCypherNetwork.BitcoinMainnet, address);
            case "testnet":
                return BlockCypher.Address(BlockCypherNetwork.BitcoinTestnet, address);
            case "regtest":
                return undefined;
        }
    },
    transactionExplorerLink: (tx, network = "mainnet") => {
        const txHash = typeof tx === "string" ? tx : tx.txHash;
        switch (Bitcoin.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return BlockCypher.Transaction(BlockCypherNetwork.BitcoinMainnet, txHash);
            case "testnet":
                return BlockCypher.Transaction(BlockCypherNetwork.BitcoinTestnet, txHash);
            case "regtest":
                return undefined;
        }
    },
};
export const Bitcoin = Callable(BitcoinClass);
const _ = Bitcoin;
// Explorers ///////////////////////////////////////////////////////////////////
export var BlockCypherNetwork;
(function (BlockCypherNetwork) {
    BlockCypherNetwork["BitcoinMainnet"] = "btc";
    BlockCypherNetwork["BitcoinTestnet"] = "btc-testnet";
})(BlockCypherNetwork || (BlockCypherNetwork = {}));
export const BlockCypher = {
    Address: (network, address) => `https://live.blockcypher.com/${network}/address/${address}/`,
    Transaction: (network, txHash) => `https://live.blockcypher.com/${network}/tx/${txHash}/`,
};
//# sourceMappingURL=bitcoin.js.map