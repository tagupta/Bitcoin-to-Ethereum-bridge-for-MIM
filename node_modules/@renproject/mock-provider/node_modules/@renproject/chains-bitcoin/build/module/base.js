var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import bech32 from "bech32";
import BigNumber from "bignumber.js";
import base58 from "bs58";
import { getRenNetworkDetails, } from "@renproject/interfaces";
import { assertType, fromHex, hash160, retryNTimes, strip0x, toBase64, utilsWithChainNetwork, } from "@renproject/utils";
import { CombinedAPI } from "./APIs/API";
import { Blockchair, BlockchairNetwork } from "./APIs/blockchair";
import { Blockstream } from "./APIs/blockstream";
import { SoChain, SoChainNetwork } from "./APIs/sochain";
import { createAddressBuffer } from "./script/index";
const transactionToDeposit = (transaction) => ({
    transaction,
    amount: transaction.amount.toString(),
});
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
export class BitcoinBaseChain {
    constructor(network) {
        this.chain = BitcoinBaseChain.chain;
        this.name = BitcoinBaseChain.chain;
        this.legacyName = "Btc";
        this.asset = "BTC";
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockstream())
                        .withAPI(Blockchair())
                        .withAPI(SoChain(), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockstream({ testnet: true }))
                        .withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET))
                        .withAPI(SoChain(SoChainNetwork.BTCTEST), { priority: 15 });
                case "regtest":
                    // Will be supported when Electrum is added as an API.
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.api = CombinedAPI();
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.api.withAPI(api, { priority });
            return this;
        };
        this.utils = utilsWithChainNetwork(BitcoinBaseChain.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet ? "testnet" : "mainnet");
            return this.withDefaultAPIs(this.chainNetwork);
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => asset === this.asset;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            if (asset === this.asset) {
                return 8;
            }
            throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = (asset, address, progress, onDeposit) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            if (this.chainNetwork === "regtest") {
                throw new Error(`Unable to fetch deposits on ${this.chainNetwork}`);
            }
            this.assertAssetIsSupported(asset);
            let txs;
            if (!progress) {
                try {
                    txs = yield retryNTimes(() => this.api.fetchTXs(address), 2);
                }
                catch (error) {
                    // Ignore error and fallback to getUTXOs.
                }
            }
            if (!txs) {
                txs = yield this.api.fetchUTXOs(address);
            }
            yield Promise.all(txs.map((tx) => __awaiter(this, void 0, void 0, function* () { return onDeposit(transactionToDeposit(tx)); })));
            return true;
        });
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            transaction = yield this.api.fetchUTXO(transaction.txHash, transaction.vOut);
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === "mainnet" ? 6 : 2,
            };
        });
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, publicKey, gHash) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            this.assertAssetIsSupported(asset);
            const isTestnet = this.chainNetwork === "testnet";
            return this.utils.addressBufferToString(createAddressBuffer(hash160(publicKey), gHash, this.utils.p2shPrefix[isTestnet ? "testnet" : "mainnet"]));
        };
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.addressToBytes = (address) => {
            // Attempt to decode address as a bech32 address, and if that fails
            // fall back to base58.
            try {
                const [type, ...words] = bech32.decode(address).words;
                return Buffer.concat([
                    Buffer.from([type]),
                    Buffer.from(bech32.fromWords(words)),
                ]);
            }
            catch (error) {
                try {
                    return base58.decode(address);
                }
                catch (internalError) {
                    throw new Error(`Unrecognized address format "${address}".`);
                }
            }
        };
        /**
         * See [[LockChain.bytesToAddress]].
         */
        this.bytesToAddress = (address) => {
            const words = bech32.toWords(address);
            return bech32.encode("", words);
        };
        /** @deprecated. Renamed to addressToBytes. */
        this.addressStringToBytes = this.addressToBytes;
        this.addressToString = (address) => address;
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.txHash;
        this.transactionIDFromRPCFormat = (txid, _txindex, reversed) => {
            // RenVM returns TXIDs in the correct byte direction, so they should be
            // reversed when converting to a string.
            // See https://learnmeabitcoin.com/technical/txid#why
            if (reversed) {
                // Reverse bytes.
                const bufferTxid = typeof txid === "string"
                    ? Buffer.from(strip0x(txid), "hex")
                    : // Create new buffer because `reverse` is in-place.
                        Buffer.from(txid);
                return bufferTxid.reverse().toString("hex");
            }
            else {
                return typeof txid === "string" ? txid : txid.toString("hex");
            }
        };
        this.transactionFromRPCFormat = (txid, txindex, reversed) => __awaiter(this, void 0, void 0, function* () {
            const txidString = this.transactionIDFromRPCFormat(txid, txindex, reversed);
            return this.api.fetchUTXO(txidString, parseInt(txindex, 10));
        });
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.depositV1HashString = ({ transaction }) => {
            return `${toBase64(fromHex(transaction.txHash))}_${transaction.vOut}`;
        };
        this.transactionRPCFormat = (transaction, v2) => {
            const { txHash, vOut } = transaction;
            assertType("string", { txHash });
            assertType("number", { vOut });
            return {
                txid: v2
                    ? fromHex(transaction.txHash).reverse()
                    : fromHex(transaction.txHash),
                txindex: transaction.vOut.toFixed(),
            };
        };
        this.transactionRPCTxidFromID = (transactionID, v2) => v2 ? fromHex(transactionID).reverse() : fromHex(transactionID);
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.Address = (address) => {
            // Type validation
            assertType("string", { address });
            this.burnPayloadGetter = (bytes) => bytes ? this.addressToBytes(address).toString("hex") : address;
            return this;
        };
        this.burnPayload = (burnPayloadConfig) => {
            return this.burnPayloadGetter
                ? this.burnPayloadGetter(burnPayloadConfig && burnPayloadConfig.bytes)
                : undefined;
        };
        this.toSats = (value) => new BigNumber(value)
            .times(new BigNumber(10).exponentiatedBy(8))
            .decimalPlaces(0)
            .toFixed();
        this.fromSats = (value) => new BigNumber(value)
            .dividedBy(new BigNumber(10).exponentiatedBy(8))
            .toFixed();
        this.chainNetwork = network;
    }
}
BitcoinBaseChain.chain = "Bitcoin";
// Asset
BitcoinBaseChain.asset = "BTC";
// Utils
BitcoinBaseChain.utils = {
    p2shPrefix: {},
    addressBufferToString: base58.encode,
    addressIsValid: (_address, _network = "mainnet") => true,
    transactionIsValid: (_transaction, _network = "mainnet") => true,
    addressExplorerLink: (_address, _network = "mainnet") => undefined,
    transactionExplorerLink: (_tx, _network = "mainnet") => undefined,
    resolveChainNetwork: (network) => {
        if (network === "mainnet" ||
            network === "testnet" ||
            network === "regtest") {
            return network;
        }
        const renNetwork = getRenNetworkDetails(network);
        return renNetwork.isTestnet ? "testnet" : "mainnet";
    },
};
const _ = BitcoinBaseChain;
//# sourceMappingURL=base.js.map