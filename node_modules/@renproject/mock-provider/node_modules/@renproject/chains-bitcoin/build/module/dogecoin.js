import { Callable, isHex, utilsWithChainNetwork } from "@renproject/utils";
import base58 from "bs58";
import { Blockchair, BlockchairNetwork } from "./APIs/blockchair";
import { SoChain, SoChainNetwork } from "./APIs/sochain";
import { BitcoinClass } from "./bitcoin";
import { validateAddress } from "./utils";
export class DogecoinClass extends BitcoinClass {
    constructor() {
        super(...arguments);
        this.chain = DogecoinClass.chain;
        this.name = DogecoinClass.chain;
        this.legacyName = undefined;
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockchair(BlockchairNetwork.DOGECOIN))
                        .withAPI(SoChain(SoChainNetwork.DOGE), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(SoChain(SoChainNetwork.DOGETEST), { priority: 15 });
                case "regtest":
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.asset = "DOGE";
        this.utils = utilsWithChainNetwork(DogecoinClass.utils, () => this.chainNetwork);
    }
}
DogecoinClass.chain = "Dogecoin";
DogecoinClass.asset = "DOGE";
DogecoinClass.utils = {
    resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,
    p2shPrefix: {
        mainnet: Buffer.from([0x16]),
        testnet: Buffer.from([0xc4]),
    },
    addressBufferToString: base58.encode,
    addressIsValid: (address, network = "mainnet") => validateAddress(address, DogecoinClass.asset, Dogecoin.utils.resolveChainNetwork(network)),
    transactionIsValid: (transaction, _network = "mainnet") => isHex(typeof transaction === "string"
        ? transaction
        : transaction.txHash, { length: 32 }),
    addressExplorerLink: (address, network = "mainnet") => {
        switch (Dogecoin.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://sochain.com/address/DOGE/${address}/`;
            case "testnet":
                return `https://sochain.com/address/DOGETEST/${address}/`;
            case "regtest":
                return undefined;
        }
    },
    transactionExplorerLink: (tx, network = "mainnet") => {
        const txHash = typeof tx === "string" ? tx : tx.txHash;
        switch (Dogecoin.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://sochain.com/tx/DOGE/${txHash}/`;
            case "testnet":
                return `https://sochain.com/tx/DOGETEST/${txHash}/`;
            case "regtest":
                return undefined;
        }
    },
};
export const Dogecoin = Callable(DogecoinClass);
const _ = Dogecoin;
//# sourceMappingURL=dogecoin.js.map