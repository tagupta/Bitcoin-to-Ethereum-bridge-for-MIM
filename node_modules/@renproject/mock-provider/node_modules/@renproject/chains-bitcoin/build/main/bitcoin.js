"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockCypher = exports.BlockCypherNetwork = exports.Bitcoin = exports.BitcoinClass = void 0;
const utils_1 = require("@renproject/utils");
const base_1 = require("./base");
const utils_2 = require("./utils");
const blockstream_1 = require("./APIs/blockstream");
const blockchair_1 = require("./APIs/blockchair");
const sochain_1 = require("./APIs/sochain");
const bs58_1 = __importDefault(require("bs58"));
/**
 * The Bitcoin class adds support for the asset BTC.
 */
class BitcoinClass extends base_1.BitcoinBaseChain {
    constructor() {
        super(...arguments);
        this.chain = BitcoinClass.chain;
        this.name = BitcoinClass.chain;
        this.legacyName = "Btc";
        this.asset = "BTC";
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(blockstream_1.Blockstream())
                        .withAPI(blockchair_1.Blockchair())
                        .withAPI(sochain_1.SoChain(), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(blockstream_1.Blockstream({ testnet: true }))
                        .withAPI(blockchair_1.Blockchair(blockchair_1.BlockchairNetwork.BITCOIN_TESTNET))
                        .withAPI(sochain_1.SoChain(sochain_1.SoChainNetwork.BTCTEST), { priority: 15 });
                case "regtest":
                    // Will be supported when Electrum is added as an API.
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.utils = utils_1.utilsWithChainNetwork(BitcoinClass.utils, () => this.chainNetwork);
    }
}
exports.BitcoinClass = BitcoinClass;
BitcoinClass.chain = "Bitcoin";
// Asset
BitcoinClass.asset = "BTC";
BitcoinClass.utils = {
    resolveChainNetwork: base_1.BitcoinBaseChain.utils.resolveChainNetwork,
    p2shPrefix: {
        mainnet: Buffer.from([0x05]),
        testnet: Buffer.from([0xc4]),
    },
    addressBufferToString: bs58_1.default.encode,
    addressIsValid: (address, network = "mainnet") => utils_2.validateAddress(address, base_1.BitcoinBaseChain.asset, exports.Bitcoin.utils.resolveChainNetwork(network)),
    transactionIsValid: (transaction, _network = "mainnet") => utils_1.isHex(typeof transaction === "string"
        ? transaction
        : transaction.txHash, { length: 32 }),
    addressExplorerLink: (address, network = "mainnet") => {
        switch (exports.Bitcoin.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return exports.BlockCypher.Address(BlockCypherNetwork.BitcoinMainnet, address);
            case "testnet":
                return exports.BlockCypher.Address(BlockCypherNetwork.BitcoinTestnet, address);
            case "regtest":
                return undefined;
        }
    },
    transactionExplorerLink: (tx, network = "mainnet") => {
        const txHash = typeof tx === "string" ? tx : tx.txHash;
        switch (exports.Bitcoin.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return exports.BlockCypher.Transaction(BlockCypherNetwork.BitcoinMainnet, txHash);
            case "testnet":
                return exports.BlockCypher.Transaction(BlockCypherNetwork.BitcoinTestnet, txHash);
            case "regtest":
                return undefined;
        }
    },
};
exports.Bitcoin = utils_1.Callable(BitcoinClass);
const _ = exports.Bitcoin;
// Explorers ///////////////////////////////////////////////////////////////////
var BlockCypherNetwork;
(function (BlockCypherNetwork) {
    BlockCypherNetwork["BitcoinMainnet"] = "btc";
    BlockCypherNetwork["BitcoinTestnet"] = "btc-testnet";
})(BlockCypherNetwork = exports.BlockCypherNetwork || (exports.BlockCypherNetwork = {}));
exports.BlockCypher = {
    Address: (network, address) => `https://live.blockcypher.com/${network}/address/${address}/`,
    Transaction: (network, txHash) => `https://live.blockcypher.com/${network}/tx/${txHash}/`,
};
//# sourceMappingURL=bitcoin.js.map