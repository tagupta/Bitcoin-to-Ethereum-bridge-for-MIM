"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CombinedAPI = exports.CombinedAPIClass = exports.fixUTXOs = exports.fixUTXO = exports.fixValue = exports.sortUTXOs = exports.DEFAULT_TIMEOUT = void 0;
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
// Default timeout for network requests.
const SECONDS = 1000;
exports.DEFAULT_TIMEOUT = 30 * SECONDS;
/**
 * sortUTXOs compares two UTXOs by amount, then confirmations and then hash.
 *
 * @example
 * sortUTXOs({amount: 1, confirmations: 1}, {amount: 2, confirmations: 0});
 * // -1, representing that the first parameter should be ordered first.
 *
 * @returns a negative value to represent that a should come before b or a
 * positive value to represent that b should come before a.
 */
const sortUTXOs = (a, b) => {
    const aAmount = new bignumber_js_1.default(a.amount);
    const bAmount = new bignumber_js_1.default(b.amount);
    // Sort greater values first.
    return !aAmount.isEqualTo(bAmount)
        ? bAmount.minus(aAmount).toNumber()
        : // If the UTXOs have the same value, sort by number of confirmations.
            a.confirmations !== b.confirmations
                ? a.confirmations - b.confirmations
                : // Fallback so sorting by txHash alphabetically.
                    a.txHash <= b.txHash
                        ? -1
                        : 1;
};
exports.sortUTXOs = sortUTXOs;
/**
 * fixValue turns a readable value, e.g. `0.0001` BTC, to the value in the smallest
 * unit, e.g. `10000` sats.
 *
 * @example
 * fixValue(0.0001, 8) = 10000;
 *
 * @param value Value in the readable representation, e.g. `0.0001` BTC.
 * @param decimals The number of decimals to shift by, e.g. 8.
 */
const fixValue = (value, decimals) => new bignumber_js_1.default(value)
    .multipliedBy(new bignumber_js_1.default(10).exponentiatedBy(decimals))
    .decimalPlaces(0);
exports.fixValue = fixValue;
/**
 * fixUTXO calls {{fixValue}} on the value of the UTXO.
 */
const fixUTXO = (utxo, decimals) => (Object.assign(Object.assign({}, utxo), { amount: exports.fixValue(utxo.amount, decimals).toFixed() }));
exports.fixUTXO = fixUTXO;
/**
 * fixUTXOs maps over an array of UTXOs and calls {{fixValue}}.
 */
const fixUTXOs = (utxos, decimals) => utxos.map((utxo) => exports.fixUTXO(utxo, decimals));
exports.fixUTXOs = fixUTXOs;
const notNull = (x) => {
    if (x === undefined || x === null) {
        throw new Error(`Unexpected ${String(x)} value.`);
    }
    return x;
};
const withPriority = (api, defaultPriority = 0) => api.api &&
    api.priority !== undefined
    ? api
    : { api: api, priority: defaultPriority };
class CombinedAPIClass {
    constructor(apis = [], { priority = 0 } = {}) {
        /**
         * Provide a new API to be used with the other APIs.
         *
         * @param api
         * @param { priority } Optionally set the priority of the API, where a lower
         * priority means it will be selected before other APIs.
         */
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.apis.push(withPriority(api, priority));
            return this;
        };
        this.fetchUTXO = async (txHash, vOut) => this.forEachAPI(
        // Filter APIs with `fetchUTXO`.
        (api) => api.fetchUTXO !== undefined, 
        // Call `fetchUTXO` on the API.
        async (api) => notNull(api.fetchUTXO)(txHash, vOut));
        this.fetchUTXOs = async (address, confirmations) => this.forEachAPI(
        // Filter APIs with `fetchUTXOs`.
        (api) => api.fetchUTXOs !== undefined, 
        // Call `fetchUTXOs` on the API.
        async (api) => notNull(api.fetchUTXOs)(address, confirmations));
        this.fetchTXs = async (address, confirmations) => this.forEachAPI(
        // Filter APIs with `fetchTXs`.
        (api) => api.fetchTXs !== undefined, 
        // Call `fetchTXs` on the API.
        async (api) => notNull(api.fetchTXs)(address, confirmations));
        this.broadcastTransaction = async (hex) => this.forEachAPI(
        // Filter APIs with `broadcastTransaction`.
        (api) => api.broadcastTransaction !== undefined, 
        // Call `broadcastTransaction` on the API.
        async (api) => notNull(api.broadcastTransaction)(hex));
        this.forEachAPI = async (filter, onAPI) => {
            const apis = this.apis
                .map((api, index) => ({ api, index }))
                .filter(({ api }) => filter(api.api))
                .sort(({ api: a }, { api: b }) => 
            // Sort by priority, and randomly for the same priority.
            a.priority !== b.priority
                ? a.priority - b.priority
                : Math.random() * 2 - 1);
            if (!apis.length) {
                throw new Error(`No API available for call.`);
            }
            let firstError;
            const previousIndices = [];
            for (const { api, index } of apis) {
                try {
                    const result = await onAPI(api.api);
                    // If any previous API failed, it may be down or rate limited,
                    // so its priority is reduced.
                    for (const previousIndex of previousIndices) {
                        this.apis[previousIndex].priority -= 5;
                    }
                    return result;
                }
                catch (error) {
                    previousIndices.push(index);
                    firstError = firstError || error;
                }
            }
            throw firstError;
        };
        this.apis = apis.map((api) => withPriority(api, priority));
    }
}
exports.CombinedAPIClass = CombinedAPIClass;
exports.CombinedAPI = utils_1.Callable(CombinedAPIClass);
//# sourceMappingURL=API.js.map