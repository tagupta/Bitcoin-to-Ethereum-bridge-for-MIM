/// <reference types="node" />
import { LockChain, RenNetwork, RenNetworkDetails, RenNetworkString, BurnPayloadConfig } from "@renproject/interfaces";
import BigNumber from "bignumber.js";
import { APIWithPriority, BitcoinAPI, UTXO } from "./APIs/API";
export declare type BtcAddress = string;
export declare type BtcTransaction = UTXO;
export declare type BtcDeposit = {
    transaction: BtcTransaction;
    amount: string;
};
export declare type BtcNetwork = "mainnet" | "testnet" | "regtest";
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
export declare abstract class BitcoinBaseChain implements LockChain<BtcTransaction, BtcDeposit, BtcAddress, BtcNetwork, boolean> {
    static chain: string;
    chain: string;
    name: string;
    legacyName: LockChain["legacyName"];
    renNetwork: RenNetworkDetails | undefined;
    chainNetwork: BtcNetwork | undefined;
    static asset: string;
    asset: string;
    withDefaultAPIs: (network: BtcNetwork) => this;
    api: import("./APIs/API").CombinedAPIClass;
    withAPI: (api: BitcoinAPI | APIWithPriority, { priority }?: {
        priority?: number | undefined;
    }) => this;
    static utils: {
        p2shPrefix: {
            [network: string]: Buffer;
        };
        addressBufferToString: (bytes: Buffer) => string;
        addressIsValid: (_address: BtcAddress | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => boolean;
        transactionIsValid: (_transaction: BtcTransaction | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => boolean;
        addressExplorerLink: (_address: BtcAddress | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => string | undefined;
        transactionExplorerLink: (_tx: BtcTransaction | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => string | undefined;
        resolveChainNetwork: (network: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => BtcNetwork;
    };
    utils: {
        p2shPrefix: {
            [network: string]: Buffer;
        };
        addressBufferToString: (bytes: Buffer) => string;
        addressIsValid: (_address: BtcAddress | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => boolean;
        transactionIsValid: (_transaction: BtcTransaction | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => boolean;
        addressExplorerLink: (_address: BtcAddress | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => string | undefined;
        transactionExplorerLink: (_tx: BtcTransaction | string, _network?: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => string | undefined;
        resolveChainNetwork: (network: RenNetwork | RenNetworkString | RenNetworkDetails | BtcNetwork) => BtcNetwork;
    } & {
        addressIsValid: (address: string, network?: "mainnet" | "testnet" | "regtest" | undefined) => boolean;
        addressExplorerLink: ((address: any, network?: "mainnet" | "testnet" | "regtest" | undefined) => string | undefined) | undefined;
        transactionExplorerLink: ((tx: any, network?: "mainnet" | "testnet" | "regtest" | undefined) => string | undefined) | undefined;
    };
    constructor(network?: BtcNetwork);
    /**
     * See [[LockChain.initialize]].
     */
    initialize: (renNetwork: RenNetwork | RenNetworkString | RenNetworkDetails) => this;
    /**
     * See [[LockChain.assetIsNative]].
     */
    assetIsNative: (asset: string) => boolean;
    assetIsSupported: (asset: string) => boolean;
    readonly assertAssetIsSupported: (asset: string) => void;
    /**
     * See [[LockChain.assetDecimals]].
     */
    assetDecimals: (asset: string) => number;
    /**
     * See [[LockChain.getDeposits]].
     */
    getDeposits: (asset: string, address: BtcAddress, progress: boolean | undefined, onDeposit: (deposit: BtcDeposit) => Promise<void>) => Promise<boolean>;
    /**
     * See [[LockChain.transactionConfidence]].
     */
    transactionConfidence: (transaction: BtcTransaction) => Promise<{
        current: number;
        target: number;
    }>;
    /**
     * See [[LockChain.getGatewayAddress]].
     */
    getGatewayAddress: (asset: string, publicKey: Buffer, gHash: Buffer) => Promise<BtcAddress> | BtcAddress;
    /**
     * See [[LockChain.addressToBytes]].
     */
    addressToBytes: (address: BtcAddress | string) => Buffer;
    /**
     * See [[LockChain.bytesToAddress]].
     */
    bytesToAddress: (address: Buffer) => string;
    /** @deprecated. Renamed to addressToBytes. */
    addressStringToBytes: (address: BtcAddress | string) => Buffer;
    addressToString: (address: BtcAddress | string) => string;
    /**
     * See [[LockChain.transactionID]].
     */
    transactionID: (transaction: BtcTransaction) => string;
    transactionIDFromRPCFormat: (txid: string | Buffer, _txindex: string, reversed?: boolean | undefined) => string;
    transactionFromRPCFormat: (txid: string | Buffer, txindex: string, reversed?: boolean | undefined) => Promise<UTXO>;
    /**
     * @deprecated Renamed to `transactionFromRPCFormat`.
     * Will be removed in 3.0.0.
     */
    transactionFromID: (txid: string | Buffer, txindex: string, reversed?: boolean | undefined) => Promise<UTXO>;
    depositV1HashString: ({ transaction }: BtcDeposit) => string;
    transactionRPCFormat: (transaction: BtcTransaction, v2?: boolean | undefined) => {
        txid: Buffer;
        txindex: string;
    };
    transactionRPCTxidFromID: (transactionID: string, v2?: boolean | undefined) => Buffer;
    private burnPayloadGetter;
    /**
     * When burning, you can call `Bitcoin.Address("...")` to make the address
     * available to the burn params.
     *
     * @category Main
     */
    Address: (address: string) => this;
    burnPayload?: ((burnPayloadConfig?: BurnPayloadConfig | undefined) => string | undefined) | undefined;
    toSats: (value: BigNumber | string | number) => string;
    fromSats: (value: BigNumber | string | number) => string;
}
