import { Callable, isHex, utilsWithChainNetwork } from "@renproject/utils";
import base58 from "bs58";
import { Insight } from "./APIs/insight";
import { BitcoinClass } from "./bitcoin";
import { validateAddress } from "./utils";
export class DigiByteClass extends BitcoinClass {
    constructor() {
        super(...arguments);
        this.chain = DigiByteClass.chain;
        this.name = DigiByteClass.chain;
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(Insight("https://multichain-web-proxy.herokuapp.com/digibyte-mainnet"))
                        .withAPI(Insight("https://digiexplorer.info/api"))
                        .withAPI(Insight("https://insight.digibyte.host/api"));
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(Insight("https://testnetexplorer.digibyteservers.io/api"));
                case "regtest":
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.asset = DigiByteClass.asset;
        this.utils = utilsWithChainNetwork(DigiByteClass.utils, () => this.chainNetwork);
    }
}
DigiByteClass.chain = "DigiByte";
DigiByteClass.asset = "DGB";
DigiByteClass.utils = {
    resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,
    p2shPrefix: {
        // Source: https://github.com/digicontributer/digibyte-js/blob/27156cd1cb4430c4a4959f46e809629846694434/lib/networks.js
        mainnet: Buffer.from([0x3f]),
        testnet: Buffer.from([0x8c]),
    },
    addressBufferToString: base58.encode,
    addressIsValid: (address, network = "mainnet") => validateAddress(address, DigiByteClass.asset, DigiByte.utils.resolveChainNetwork(network)),
    transactionIsValid: (transaction, _network = "mainnet") => isHex(typeof transaction === "string"
        ? transaction
        : transaction.txHash, { length: 32 }),
    addressExplorerLink: (address, network = "mainnet") => {
        switch (DigiByte.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://digiexplorer.info/address/${address}`;
            case "testnet":
                return `https://testnetexplorer.digibyteservers.io/address/${address}`;
            case "regtest":
                return undefined;
        }
    },
    transactionExplorerLink: (tx, network = "mainnet") => {
        const txHash = typeof tx === "string" ? tx : tx.txHash;
        switch (DigiByte.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://digiexplorer.info/tx/${txHash}`;
            case "testnet":
                return `https://testnetexplorer.digibyteservers.io/tx/${txHash}`;
            case "regtest":
                return undefined;
        }
    },
};
export const DigiByte = Callable(DigiByteClass);
const _ = DigiByte;
//# sourceMappingURL=digibyte.js.map