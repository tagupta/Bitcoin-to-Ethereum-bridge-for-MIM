import { Callable, isHex, utilsWithChainNetwork } from "@renproject/utils";
import { toCashAddress, isMainnetAddress, isTestnetAddress, isValidAddress, } from "bchaddrjs";
import base58 from "bs58";
import { BitcoinDotCom } from "./APIs/bitcoinDotCom";
import { Blockchair, BlockchairNetwork } from "./APIs/blockchair";
import { BitcoinClass } from "./bitcoin";
import { decodeBitcoinCashAddress } from "./bchaddrjs";
export class BitcoinCashClass extends BitcoinClass {
    constructor() {
        super(...arguments);
        this.chain = BitcoinCashClass.chain;
        this.name = BitcoinCashClass.chain;
        this.legacyName = "Bch";
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(BitcoinDotCom())
                        .withAPI(Blockchair(BlockchairNetwork.BITCOIN_CASH));
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(BitcoinDotCom({ testnet: true }));
                case "regtest":
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.asset = "BCH";
        this.utils = utilsWithChainNetwork(BitcoinCashClass.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.addressToBytes = (address) => decodeBitcoinCashAddress(address);
        /** @deprecated. Renamed to addressToBytes. */
        this.addressStringToBytes = this.addressToBytes;
    }
}
BitcoinCashClass.chain = "BitcoinCash";
BitcoinCashClass.asset = "BCH";
BitcoinCashClass.utils = {
    resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,
    p2shPrefix: {
        mainnet: Buffer.from([0x05]),
        testnet: Buffer.from([0xc4]),
    },
    addressBufferToString: (bytes) => toCashAddress(base58.encode(bytes)),
    addressIsValid: (address, network = "mainnet") => {
        const btcNetwork = BitcoinCash.utils.resolveChainNetwork(network);
        return (isValidAddress(address) &&
            (btcNetwork === "mainnet"
                ? isMainnetAddress(address)
                : btcNetwork === "testnet"
                    ? isTestnetAddress(address)
                    : true));
    },
    transactionIsValid: (transaction, _network = "mainnet") => isHex(typeof transaction === "string"
        ? transaction
        : transaction.txHash, { length: 32 }),
    addressExplorerLink: (address, network = "mainnet") => {
        switch (BitcoinCash.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://explorer.bitcoin.com/bch/address/${address}`;
            case "testnet":
                return `https://explorer.bitcoin.com/tbch/address/${address}`;
            case "regtest":
                return undefined;
        }
    },
    transactionExplorerLink: (tx, network = "mainnet") => {
        const txHash = typeof tx === "string" ? tx : tx.txHash;
        switch (BitcoinCash.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://explorer.bitcoin.com/bch/tx/${txHash}`;
            case "testnet":
                return `https://explorer.bitcoin.com/tbch/tx/${txHash}`;
            case "regtest":
                return undefined;
        }
    },
};
export const BitcoinCash = Callable(BitcoinCashClass);
const _ = BitcoinCash;
//# sourceMappingURL=bitcoincash.js.map