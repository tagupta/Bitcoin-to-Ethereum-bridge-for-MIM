"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filecoin = exports.FilecoinClass = void 0;
const blakejs_1 = require("blakejs");
const cids_1 = __importDefault(require("cids"));
const elliptic_1 = __importDefault(require("elliptic"));
const filecoin_address_1 = require("@glif/filecoin-address");
const filecoin_rpc_client_1 = __importDefault(require("@glif/filecoin-rpc-client"));
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const filfox_1 = require("./api/explorers/filfox");
const lotus_1 = require("./api/lotus");
const NETWORK_NOT_SUPPORTED = `Filecoin is not supported by the current RenVM network.`;
const transactionToDeposit = (transaction) => ({
    transaction,
    amount: transaction.amount.toString(),
});
class FilecoinClass {
    constructor(network, _a = {}) {
        var { useParams } = _a, options = __rest(_a, ["useParams"]);
        this.chain = FilecoinClass.chain;
        this.name = FilecoinClass.chain;
        this.asset = "FIL";
        this.utils = utils_1.utilsWithChainNetwork(FilecoinClass.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = interfaces_1.getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet ? "testnet" : "mainnet");
            this.client = new filecoin_rpc_client_1.default({
                apiAddress: utils_1.isDefined(this.clientOptions.apiAddress)
                    ? this.clientOptions.apiAddress
                    : `https://multichain-web-proxy.herokuapp.com/${this.chainNetwork}`,
                token: this.clientOptions.token,
            });
            if (this.chainNetwork === "mainnet") {
                this.filfox = new filfox_1.Filfox(this.chainNetwork);
            }
            return this;
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => asset === this.asset;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            if (asset === this.asset) {
                return 18;
            }
            throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = async (asset, address, progress, onDeposit) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            if (this.chainNetwork === "devnet") {
                throw new Error(`Unable to fetch deposits on ${this.chainNetwork}.`);
            }
            this.assertAssetIsSupported(asset);
            let height = 0;
            try {
                height = await lotus_1.getHeight(this.client);
            }
            catch (error) {
                console.error(error);
            }
            const logLimit = 100;
            const fromBlock = height - logLimit;
            const logsToCatchUp = height - (progress || 0);
            // If there's too many logs to catch-up on, fetch the transactions from
            // Filfox (mainnet only)
            if (this.filfox && (logsToCatchUp > logLimit || height === 0)) {
                try {
                    const size = 100;
                    let page = 0;
                    while (true) {
                        const { deposits, totalCount } = await utils_1.retryNTimes(async () => {
                            if (!this.filfox) {
                                throw new Error(`Filfox not defined.`);
                            }
                            return this.filfox.fetchDeposits(address.address, address.params, page, size);
                        }, 5, 5 * utils_1.SECONDS);
                        await Promise.all((deposits || []).map(async (tx) => onDeposit(transactionToDeposit(tx))));
                        if (size * (page + 1) >= totalCount) {
                            break;
                        }
                        page += 1;
                        await utils_1.sleep(10 * utils_1.SECONDS);
                    }
                }
                catch (error) {
                    // Ignore error.
                }
            }
            else {
                const txs = await lotus_1.fetchDeposits(this.client, address.address, address.params, this.chainNetwork, fromBlock, height);
                await Promise.all((txs || []).map(async (tx) => onDeposit(transactionToDeposit(tx))));
            }
            return height;
        };
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = async (transaction) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            transaction = await this.transactionFromRPCFormat(transaction.cid, "");
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === "mainnet" ? 12 : 6, // NOT FINAL VALUES
            };
        };
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, compressedPublicKey, gHash) => {
            if (!this.renNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            this.assertAssetIsSupported(asset);
            const ec = new elliptic_1.default.ec("secp256k1");
            // Decode compressed RenVM public key.
            const renVMPublicKey = ec.keyFromPublic(compressedPublicKey);
            // Interpret gHash as a private key.
            const gHashKey = ec.keyFromPrivate(gHash);
            // If `NO_PARAMS_FLAG` is set, set renVM public key and gHash public key,
            // and recreate key pair from resulting curve point.
            const derivedPublicKey = this.noParamsFlag
                ? ec.keyFromPublic(renVMPublicKey
                    .getPublic()
                    .add(gHashKey.getPublic()))
                : renVMPublicKey;
            const payload = Buffer.from(blakejs_1.blake2b(Buffer.from(derivedPublicKey.getPublic(false, "hex"), "hex"), null, 20));
            const address = this.encodeFilecoinAddress(payload);
            const params = this.noParamsFlag
                ? undefined
                : utils_1.toBase64(Buffer.from(utils_1.toURLBase64(gHash)));
            return {
                address,
                params,
            };
        };
        this.encodeFilecoinAddress = (payload) => {
            if (payload.length === 21) {
                payload = Buffer.from(payload.slice(1, 21));
            }
            // secp256k1 protocol prefix
            const protocol = 1;
            // network prefix
            const networkPrefix = this.chainNetwork === "testnet" ? "t" : "f";
            const addressObject = {
                str: Buffer.concat([Buffer.from([protocol]), payload]),
                protocol: () => protocol,
                payload: () => payload,
            };
            return filecoin_address_1.encode(networkPrefix, addressObject);
        };
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.addressToBytes = (address) => Buffer.from(filecoin_address_1.decode(typeof address === "string" ? address : address.address).str);
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.bytesToAddress = (address) => this.encodeFilecoinAddress(address);
        /** @deprecated. Renamed to addressToBytes. */
        this.addressStringToBytes = this.addressToBytes;
        this.addressToString = (address) => typeof address === "string" ? address : address.address;
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.cid;
        this.transactionIDFromRPCFormat = (txid, _txindex) => (typeof txid === "string" ? txid : new cids_1.default(txid).toString());
        this.transactionFromRPCFormat = async (txid, _txindex) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            const cid = typeof txid === "string" ? txid : new cids_1.default(txid).toString();
            try {
                return await lotus_1.fetchMessage(this.client, cid, this.chainNetwork);
            }
            catch (error) {
                if (this.filfox) {
                    try {
                        return await this.filfox.fetchMessage(cid);
                    }
                    catch (errorInner) {
                        console.error(errorInner);
                    }
                }
                throw error;
            }
        };
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.depositV1HashString = (_deposit) => {
            throw new Error(NETWORK_NOT_SUPPORTED);
        };
        this.transactionRPCFormat = (transaction, v2) => {
            if (!v2) {
                throw new Error(NETWORK_NOT_SUPPORTED);
            }
            return {
                txid: Buffer.from(new cids_1.default(transaction.cid).bytes),
                txindex: "0",
            };
        };
        this.transactionRPCTxidFromID = (transactionID) => Buffer.from(new cids_1.default(transactionID).bytes);
        /** @category Main */
        this.Address = (address) => {
            // Type validation
            utils_1.assertType("string", { address });
            this.getBurnPayload = (bytes) => bytes ? this.addressToBytes(address).toString("hex") : address;
            return this;
        };
        this.burnPayload = (config) => {
            return this.getBurnPayload
                ? this.getBurnPayload(config && config.bytes)
                : undefined;
        };
        this.chainNetwork = network;
        this.clientOptions = options;
        this.noParamsFlag = !useParams;
    }
}
exports.FilecoinClass = FilecoinClass;
FilecoinClass.chain = "Filecoin";
FilecoinClass.utils = {
    resolveChainNetwork: (network) => {
        if (network === "mainnet" ||
            network === "testnet" ||
            network === "devnet") {
            return network;
        }
        const renNetwork = interfaces_1.getRenNetworkDetails(network);
        return renNetwork.isTestnet ? "testnet" : "mainnet";
    },
    addressIsValid: (address, _network = "mainnet") => filecoin_address_1.validateAddressString(typeof address === "string" ? address : address.address),
    transactionIsValid: utils_1.doesntError((transaction, _network = "mainnet") => {
        const transactionString = typeof transaction === "string"
            ? transaction
            : transaction.cid;
        const cid = new cids_1.default(transactionString);
        return (transactionString === cid.toString() &&
            cid.bytes.length === 38);
    }),
    addressExplorerLink: (address, _network = "mainnet") => {
        // TODO: Check network.
        return `https://filfox.info/en/address/${typeof address === "string" ? address : address.address}`;
    },
    transactionExplorerLink: (transaction, _network = "mainnet") => {
        // TODO: Check network.
        return `https://filfox.info/en/message/${typeof transaction === "string" ? transaction : transaction.cid}`;
    },
};
// @dev Removes any static fields, except `utils`.
exports.Filecoin = utils_1.Callable(FilecoinClass);
const _ = exports.Filecoin;
const __ = exports.Filecoin();
//# sourceMappingURL=filecoin.js.map