var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { blake2b } from "blakejs";
import CID from "cids";
import elliptic from "elliptic";
import { decode as decodeAddress, encode as encodeAddress, validateAddressString, } from "@glif/filecoin-address";
import FilecoinClient from "@glif/filecoin-rpc-client";
import { getRenNetworkDetails, } from "@renproject/interfaces";
import { assertType, Callable, doesntError, isDefined, retryNTimes, SECONDS, sleep, toBase64, toURLBase64, utilsWithChainNetwork, } from "@renproject/utils";
import { Filfox } from "./api/explorers/filfox";
import { fetchDeposits, fetchMessage, getHeight } from "./api/lotus";
const NETWORK_NOT_SUPPORTED = `Filecoin is not supported by the current RenVM network.`;
const transactionToDeposit = (transaction) => ({
    transaction,
    amount: transaction.amount.toString(),
});
export class FilecoinClass {
    constructor(network, _a = {}) {
        var { useParams } = _a, options = __rest(_a, ["useParams"]);
        this.chain = FilecoinClass.chain;
        this.name = FilecoinClass.chain;
        this.asset = "FIL";
        this.utils = utilsWithChainNetwork(FilecoinClass.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet ? "testnet" : "mainnet");
            this.client = new FilecoinClient({
                apiAddress: isDefined(this.clientOptions.apiAddress)
                    ? this.clientOptions.apiAddress
                    : `https://multichain-web-proxy.herokuapp.com/${this.chainNetwork}`,
                token: this.clientOptions.token,
            });
            if (this.chainNetwork === "mainnet") {
                this.filfox = new Filfox(this.chainNetwork);
            }
            return this;
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => asset === this.asset;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            if (asset === this.asset) {
                return 18;
            }
            throw new Error(`Asset ${asset} not supported on ${this.chain}.`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = (asset, address, progress, onDeposit) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            if (this.chainNetwork === "devnet") {
                throw new Error(`Unable to fetch deposits on ${this.chainNetwork}.`);
            }
            this.assertAssetIsSupported(asset);
            let height = 0;
            try {
                height = yield getHeight(this.client);
            }
            catch (error) {
                console.error(error);
            }
            const logLimit = 100;
            const fromBlock = height - logLimit;
            const logsToCatchUp = height - (progress || 0);
            // If there's too many logs to catch-up on, fetch the transactions from
            // Filfox (mainnet only)
            if (this.filfox && (logsToCatchUp > logLimit || height === 0)) {
                try {
                    const size = 100;
                    let page = 0;
                    while (true) {
                        const { deposits, totalCount } = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {
                            if (!this.filfox) {
                                throw new Error(`Filfox not defined.`);
                            }
                            return this.filfox.fetchDeposits(address.address, address.params, page, size);
                        }), 5, 5 * SECONDS);
                        yield Promise.all((deposits || []).map((tx) => __awaiter(this, void 0, void 0, function* () { return onDeposit(transactionToDeposit(tx)); })));
                        if (size * (page + 1) >= totalCount) {
                            break;
                        }
                        page += 1;
                        yield sleep(10 * SECONDS);
                    }
                }
                catch (error) {
                    // Ignore error.
                }
            }
            else {
                const txs = yield fetchDeposits(this.client, address.address, address.params, this.chainNetwork, fromBlock, height);
                yield Promise.all((txs || []).map((tx) => __awaiter(this, void 0, void 0, function* () { return onDeposit(transactionToDeposit(tx)); })));
            }
            return height;
        });
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            transaction = yield this.transactionFromRPCFormat(transaction.cid, "");
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === "mainnet" ? 12 : 6, // NOT FINAL VALUES
            };
        });
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, compressedPublicKey, gHash) => {
            if (!this.renNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            this.assertAssetIsSupported(asset);
            const ec = new elliptic.ec("secp256k1");
            // Decode compressed RenVM public key.
            const renVMPublicKey = ec.keyFromPublic(compressedPublicKey);
            // Interpret gHash as a private key.
            const gHashKey = ec.keyFromPrivate(gHash);
            // If `NO_PARAMS_FLAG` is set, set renVM public key and gHash public key,
            // and recreate key pair from resulting curve point.
            const derivedPublicKey = this.noParamsFlag
                ? ec.keyFromPublic(renVMPublicKey
                    .getPublic()
                    .add(gHashKey.getPublic()))
                : renVMPublicKey;
            const payload = Buffer.from(blake2b(Buffer.from(derivedPublicKey.getPublic(false, "hex"), "hex"), null, 20));
            const address = this.encodeFilecoinAddress(payload);
            const params = this.noParamsFlag
                ? undefined
                : toBase64(Buffer.from(toURLBase64(gHash)));
            return {
                address,
                params,
            };
        };
        this.encodeFilecoinAddress = (payload) => {
            if (payload.length === 21) {
                payload = Buffer.from(payload.slice(1, 21));
            }
            // secp256k1 protocol prefix
            const protocol = 1;
            // network prefix
            const networkPrefix = this.chainNetwork === "testnet" ? "t" : "f";
            const addressObject = {
                str: Buffer.concat([Buffer.from([protocol]), payload]),
                protocol: () => protocol,
                payload: () => payload,
            };
            return encodeAddress(networkPrefix, addressObject);
        };
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.addressToBytes = (address) => Buffer.from(decodeAddress(typeof address === "string" ? address : address.address).str);
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.bytesToAddress = (address) => this.encodeFilecoinAddress(address);
        /** @deprecated. Renamed to addressToBytes. */
        this.addressStringToBytes = this.addressToBytes;
        this.addressToString = (address) => typeof address === "string" ? address : address.address;
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.cid;
        this.transactionIDFromRPCFormat = (txid, _txindex) => (typeof txid === "string" ? txid : new CID(txid).toString());
        this.transactionFromRPCFormat = (txid, _txindex) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            const cid = typeof txid === "string" ? txid : new CID(txid).toString();
            try {
                return yield fetchMessage(this.client, cid, this.chainNetwork);
            }
            catch (error) {
                if (this.filfox) {
                    try {
                        return yield this.filfox.fetchMessage(cid);
                    }
                    catch (errorInner) {
                        console.error(errorInner);
                    }
                }
                throw error;
            }
        });
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.depositV1HashString = (_deposit) => {
            throw new Error(NETWORK_NOT_SUPPORTED);
        };
        this.transactionRPCFormat = (transaction, v2) => {
            if (!v2) {
                throw new Error(NETWORK_NOT_SUPPORTED);
            }
            return {
                txid: Buffer.from(new CID(transaction.cid).bytes),
                txindex: "0",
            };
        };
        this.transactionRPCTxidFromID = (transactionID) => Buffer.from(new CID(transactionID).bytes);
        /** @category Main */
        this.Address = (address) => {
            // Type validation
            assertType("string", { address });
            this.getBurnPayload = (bytes) => bytes ? this.addressToBytes(address).toString("hex") : address;
            return this;
        };
        this.burnPayload = (config) => {
            return this.getBurnPayload
                ? this.getBurnPayload(config && config.bytes)
                : undefined;
        };
        this.chainNetwork = network;
        this.clientOptions = options;
        this.noParamsFlag = !useParams;
    }
}
FilecoinClass.chain = "Filecoin";
FilecoinClass.utils = {
    resolveChainNetwork: (network) => {
        if (network === "mainnet" ||
            network === "testnet" ||
            network === "devnet") {
            return network;
        }
        const renNetwork = getRenNetworkDetails(network);
        return renNetwork.isTestnet ? "testnet" : "mainnet";
    },
    addressIsValid: (address, _network = "mainnet") => validateAddressString(typeof address === "string" ? address : address.address),
    transactionIsValid: doesntError((transaction, _network = "mainnet") => {
        const transactionString = typeof transaction === "string"
            ? transaction
            : transaction.cid;
        const cid = new CID(transactionString);
        return (transactionString === cid.toString() &&
            cid.bytes.length === 38);
    }),
    addressExplorerLink: (address, _network = "mainnet") => {
        // TODO: Check network.
        return `https://filfox.info/en/address/${typeof address === "string" ? address : address.address}`;
    },
    transactionExplorerLink: (transaction, _network = "mainnet") => {
        // TODO: Check network.
        return `https://filfox.info/en/message/${typeof transaction === "string" ? transaction : transaction.cid}`;
    },
};
// @dev Removes any static fields, except `utils`.
export const Filecoin = Callable(FilecoinClass);
const _ = Filecoin;
const __ = Filecoin();
//# sourceMappingURL=filecoin.js.map