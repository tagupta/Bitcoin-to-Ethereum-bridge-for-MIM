var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SECONDS } from "@renproject/utils";
import Axios from "axios";
const FILFOX_URL = "https://filfox.info/api/v1/";
export class Filfox {
    constructor(network = "mainnet") {
        this.fetchDeposits = (address, paramsFilterBase64 = undefined, page = 0, size = 100) => __awaiter(this, void 0, void 0, function* () {
            const heightURL = `${FILFOX_URL}tipset/recent?count=1`;
            const heightResponse = (yield Axios.get(heightURL, {
                timeout: 60 * SECONDS,
            })).data;
            if (!Array.isArray(heightResponse)) {
                throw new Error(`Unable to fetch latest Filecoin height: ${heightResponse.error}`);
            }
            const height = heightResponse[0].height;
            const messagesURL = `${FILFOX_URL}address/${address}/messages?pageSize=${size}&page=${page}&detailed`;
            const messagesResponse = (yield Axios.get(messagesURL, {
                timeout: 60 * SECONDS,
            })).data;
            if (messagesResponse.error !== undefined) {
                throw new Error(`Unable to fetch Filecoin messages: ${messagesResponse.error}`);
            }
            const { messages, totalCount } = messagesResponse;
            return {
                deposits: messages
                    .filter((message) => message.to === address)
                    .map((message) => {
                    return {
                        cid: message.cid,
                        // to: message.to,
                        amount: message.value,
                        params: message.params,
                        confirmations: height - message.height,
                        nonce: message.nonce,
                    };
                })
                    .filter((message) => paramsFilterBase64 === undefined ||
                    paramsFilterBase64 === null ||
                    message.params === paramsFilterBase64),
                totalCount,
            };
        });
        this.fetchMessage = (cid) => __awaiter(this, void 0, void 0, function* () {
            const messagesURL = `${FILFOX_URL}message/${cid}`;
            const message = (yield Axios.get(messagesURL, {
                timeout: 60 * SECONDS,
            })).data;
            if (message.error !== undefined && message.error !== "") {
                throw new Error(`Unable to fetch Filecoin messages: ${String(message.error)}`);
            }
            return {
                cid: message.cid,
                // to: message.to,
                amount: message.value,
                params: message.params,
                confirmations: message.confirmations,
                nonce: message.nonce,
            };
        });
        if (network !== "mainnet") {
            throw new Error(`Network ${network} not supported by Filscan.`);
        }
    }
}
//# sourceMappingURL=filfox.js.map