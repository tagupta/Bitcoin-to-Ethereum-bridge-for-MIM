"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixSignature = exports.fixSignatureSimple = exports.secp256k1n = exports.signatureToBuffer = void 0;
const interfaces_1 = require("@renproject/interfaces");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const assert_1 = require("./assert");
const common_1 = require("./common");
const renVMHashes_1 = require("./renVMHashes");
const signatureToBuffer = (sig) => Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]);
exports.signatureToBuffer = signatureToBuffer;
const switchV = (v) => (v === 27 ? 28 : 27); // 28 - (v - 27);
const to32Bytes = (bn) => common_1.fromHex(("0".repeat(64) + bn.toString(16)).slice(-64));
exports.secp256k1n = new bignumber_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
const fixSignatureSimple = (r, s, v) => {
    assert_1.assertType("Buffer", { r, s });
    let sBN = new bignumber_js_1.default(common_1.Ox(s), 16);
    let vFixed = ((v || 0) % 27) + 27;
    // For a given key, there are two valid signatures for each signed message.
    // We always take the one with the lower `s`.
    // secp256k1n/2 = 57896044618658097711785492504343953926418782139537452191302581570759080747168.5
    if (sBN.gt(exports.secp256k1n.div(2))) {
        // Take s = -s % secp256k1n
        sBN = exports.secp256k1n.minus(sBN);
        // Switch v
        vFixed = switchV(vFixed);
    }
    return {
        r,
        s: to32Bytes(sBN),
        v: vFixed,
    };
};
exports.fixSignatureSimple = fixSignatureSimple;
const fixSignature = (r, s, v, sigHash, pHash, amount, to, tokenIdentifier, nHash, v2, logger = interfaces_1.NullLogger) => {
    // Type validation
    assert_1.assertType("string", { amount, to, tokenIdentifier });
    assert_1.assertType("Buffer", { r, s, sigHash, pHash, nHash });
    if (typeof logger.level !== "number" || logger.level >= interfaces_1.LogLevel.Warn) {
        const expectedSighash = renVMHashes_1.generateSighash(pHash, amount, to, tokenIdentifier, nHash, v2, logger);
        if (common_1.Ox(sigHash) !== common_1.Ox(expectedSighash)) {
            logger.warn(`Warning: unexpected signature hash returned from RenVM. Expected ${common_1.Ox(expectedSighash)}, got ${common_1.Ox(sigHash)}.`);
        }
    }
    // TODO: Fix code below to check against proper mintAuthority
    // // Currently, the wrong `v` value may be returned from RenVM. We recover the
    // // address to see if we need to switch `v`. This can be removed once RenVM
    // // has been updated.
    // const recovered = {
    //     [v]: pubToAddress(ecrecover(
    //         fromHex(response.autogen.sighash)),
    //         v,
    //         fromHex(r),
    //         s.toArrayLike(Buffer, "be", 32),
    //     )),
    //     [switchV(v)]: pubToAddress(ecrecover(
    //         fromHex(response.autogen.sighash),
    //         switchV(v),
    //         fromHex(r),
    //         s.toArrayLike(Buffer, "be", 32),
    //     )),
    // };
    // const expected = fromHex(.network.renVM.mintAuthority);
    // if (recovered[v].equals(expected)) {
    //     // Do nothing
    // } else if (recovered[switchV(v)].equals(expected)) {
    //     console.info("[info][ren-js] switching v value");
    //     v = switchV(v);
    // } else {
    //     throw new Error(`Invalid signature - unable to recover mint authority from signature (Expected ${Ox(expected)}, got ${Ox(recovered[v])})`);
    // }
    return exports.fixSignatureSimple(r, s, v);
};
exports.fixSignature = fixSignature;
//# sourceMappingURL=signatureUtils.js.map