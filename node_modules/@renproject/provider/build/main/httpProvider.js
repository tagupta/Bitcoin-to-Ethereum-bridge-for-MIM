"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpProvider = void 0;
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const axios_1 = __importDefault(require("axios"));
const generatePayload = (method, params) => ({
    id: 1,
    jsonrpc: "2.0",
    method,
    params,
});
class HttpProvider {
    constructor(ipOrMultiaddress, logger = interfaces_1.NullLogger) {
        this.sendMessage = async (method, request, retry = 2, timeout = 120 * utils_1.SECONDS) => {
            const payload = generatePayload(method, request);
            if (
            // Check level before doing expensive JSON call.
            typeof this.logger.level !== "number" ||
                this.logger.level >= interfaces_1.LogLevel.Debug) {
                this.logger.debug("[request]", JSON.stringify(payload, null, "    "));
            }
            try {
                const response = await utils_1.retryNTimes(async () => axios_1.default.post(this.nodeURL, payload, 
                // Use a 120 second timeout. This could be reduced, but
                // should be done based on the method, since some requests
                // may take a long time, especially on a slow connection.
                { timeout }), retry, 1 * utils_1.SECONDS);
                if (response.status !== 200) {
                    throw this.responseError(`Unexpected status code ${String(response.status)} returned from node.`, response);
                }
                if (response.data.error) {
                    throw new Error(response.data.error);
                }
                if (response.data.result === undefined) {
                    throw new Error(`Empty result returned from node.`);
                }
                if (typeof this.logger.level !== "number" ||
                    this.logger.level >= interfaces_1.LogLevel.Debug) {
                    this.logger.debug("[response]", JSON.stringify(response.data.result, null, "    "));
                }
                return response.data.result;
            }
            catch (error) {
                if (error.response) {
                    error.message = `Node returned status ${String(error.response.status)} with reason: ${utils_1.extractError(error)}`;
                }
                throw error;
            }
        };
        this.responseError = (msg, response) => {
            const error = new Error(msg);
            error.response = response;
            return error;
        };
        this.logger = logger;
        if (typeof ipOrMultiaddress !== "string") {
            throw new Error(`Invalid node URL ${String(ipOrMultiaddress)}`);
        }
        if (ipOrMultiaddress.indexOf("://") === -1) {
            throw new Error(`Invalid node URL without protocol: ${ipOrMultiaddress}.`);
        }
        this.nodeURL = ipOrMultiaddress;
    }
}
exports.HttpProvider = HttpProvider;
//# sourceMappingURL=httpProvider.js.map