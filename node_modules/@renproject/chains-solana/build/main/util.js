"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.finalizeTransaction = exports.createInstructionWithEthAddress2 = exports.toBuffer = void 0;
const utils_1 = require("@renproject/utils");
const web3_js_1 = require("@solana/web3.js");
const BufferLayout = __importStar(require("buffer-layout"));
const ETHEREUM_ADDRESS_BYTES = 20;
const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
const SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([
    BufferLayout.u8("numSignatures"),
    BufferLayout.u16("signatureOffset"),
    BufferLayout.u8("signatureInstructionIndex"),
    BufferLayout.u16("ethAddressOffset"),
    BufferLayout.u8("ethAddressInstructionIndex"),
    BufferLayout.u16("messageDataOffset"),
    BufferLayout.u16("messageDataSize"),
    BufferLayout.u8("messageInstructionIndex"),
    BufferLayout.blob(21, "ethAddress"),
    BufferLayout.blob(64, "signature"),
    BufferLayout.u8("recoveryId"),
]);
const toBuffer = (arr) => {
    if (arr instanceof Buffer) {
        return arr;
    }
    else if (arr instanceof Uint8Array) {
        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    else {
        return Buffer.from(arr);
    }
};
exports.toBuffer = toBuffer;
/**
 * Create an secp256k1 instruction with an Ethereum address.
 *
 * We need to add an extra byte to the ethAddress to match our secp offset
 * */
const createInstructionWithEthAddress2 = (params) => {
    const { ethAddress: rawAddress, message, signature, recoveryId } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
        if (rawAddress.startsWith("0x")) {
            ethAddress = Buffer.from(rawAddress.substr(2), "hex");
        }
        else {
            ethAddress = Buffer.from(rawAddress, "hex");
        }
    }
    else {
        ethAddress = rawAddress;
    }
    const ethAddressLength = ethAddress.length;
    utils_1.assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddressLength} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart + 1;
    const signatureOffset = ethAddressOffset + ethAddressLength;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = Buffer.alloc(Number(SECP256K1_INSTRUCTION_LAYOUT.span) + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
        numSignatures,
        signatureOffset,
        signatureInstructionIndex: 1,
        ethAddressOffset,
        ethAddressInstructionIndex: 1,
        messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: 1,
        signature: exports.toBuffer(signature),
        ethAddress: exports.toBuffer([0, ...ethAddress]),
        recoveryId,
    }, instructionData);
    instructionData.fill(exports.toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new web3_js_1.TransactionInstruction({
        keys: [],
        programId: web3_js_1.Secp256k1Program.programId,
        data: instructionData,
    });
};
exports.createInstructionWithEthAddress2 = createInstructionWithEthAddress2;
/**
 * Wait for a transaction to be confirmed, and then wait up to 20 seconds for it
 * to be finalized. Some wallets don't seem to return if you wait for a
 * transaction to be finalized, so we return after 20 seconds.
 */
const finalizeTransaction = async (connection, signature) => {
    // Wait up to 20 seconds for the transaction to be finalized.
    await Promise.race([
        connection.confirmTransaction(signature, "finalized"),
        20 * utils_1.SECONDS,
    ]);
};
exports.finalizeTransaction = finalizeTransaction;
//# sourceMappingURL=util.js.map