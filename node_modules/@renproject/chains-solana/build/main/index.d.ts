/// <reference types="node" />
import { BurnDetails, ContractCall, LockAndMintTransaction, Logger, MintChain, RenNetwork, RenNetworkDetails, RenNetworkString, OverwritableLockAndMintParams, OverwritableBurnAndReleaseParams, BurnPayloadConfig, EventEmitterTyped } from "@renproject/interfaces";
import { Connection, PublicKey, Transaction } from "@solana/web3.js";
import BigNumber from "bignumber.js";
import { SolNetworkConfig } from "./networks";
import { GatewayRegistryState } from "./layouts";
export declare type SolTransaction = string;
export declare type SolAddress = string;
export interface SolanaProvider {
    connection: Connection;
    wallet: {
        publicKey: PublicKey;
        signTransaction: (transaction: Transaction) => Promise<Transaction>;
    };
}
interface SolOptions {
    logger?: Logger;
    includeAddressInPayload?: boolean;
}
export declare class SolanaClass implements MintChain<SolTransaction, SolAddress, SolNetworkConfig> {
    static chain: "Solana";
    chain: "Solana";
    name: "Solana";
    renNetworkDetails: SolNetworkConfig;
    private _logger;
    private _includeAddressInPayload;
    burnPayloadConfig: BurnPayloadConfig;
    provider: SolanaProvider;
    constructor(provider: SolanaProvider, renNetwork?: RenNetwork | RenNetworkString | RenNetworkDetails | SolNetworkConfig, options?: SolOptions);
    static utils: {
        resolveChainNetwork: (renNetwork: SolNetworkConfig | RenNetwork | RenNetworkDetails | RenNetworkString) => SolNetworkConfig;
        /**
         * A Solana address is a base58-encoded 32-byte ed25519 public key.
         */
        addressIsValid: (address: string) => boolean;
        /**
         * A Solana transaction's ID is a base58-encoded 64-byte signature.
         */
        transactionIsValid: (transaction: string) => boolean;
        addressExplorerLink: (address: SolAddress, network: RenNetwork | RenNetworkString | RenNetworkDetails | SolNetworkConfig) => string;
        transactionExplorerLink: (transaction: SolTransaction, network?: RenNetwork | RenNetworkString | RenNetworkDetails | SolNetworkConfig) => string;
    };
    utils: any;
    /**
     * Should be set by `constructor` or `initialize`.
     */
    renNetwork?: RenNetworkDetails;
    gatewayRegistryData?: GatewayRegistryState;
    _initialized?: Promise<true>;
    /**
     * `initialize` allows RenJS to pass in parameters after the user has
     * initialized the Chain. This allows the user to pass in network
     * parameters such as the network only once.
     *
     * If the Chain's constructor has an optional network parameter and the
     * user has explicitly initialized it, the Chain should ignore the
     * network passed in to `initialize`. This is to allow different network
     * combinations, such as working with testnet Bitcoin and a local Ethereum
     * chain - whereas the default `testnet` configuration would use testnet
     * Bitcoin and Ethereum's Kovan testnet.
     */
    initialize: (network: RenNetwork | RenNetworkString | RenNetworkDetails) => Promise<this>;
    waitForInitialization(): Promise<true>;
    withProvider: (provider: any) => this;
    assetIsNative: (asset: string) => boolean;
    /**
     * `assetIsSupported` should return true if the the asset is native to the
     * chain or if the asset can be minted onto the chain.
     *
     * ```ts
     * ethereum.assetIsSupported = asset => asset === "ETH" || asset === "BTC" || ...;
     * ```
     */
    assetIsSupported: (asset: string) => Promise<boolean>;
    assetDecimals: (asset: string) => Promise<number>;
    transactionID: (transaction: SolTransaction) => string;
    transactionConfidence: (transaction: SolTransaction) => Promise<{
        current: number;
        target: number;
    }>;
    transactionRPCFormat: (transaction: SolTransaction) => {
        txid: Buffer;
        txindex: string;
    };
    transactionRPCTxidFromID: (transactionID: string) => Buffer;
    transactionIDFromRPCFormat: (txid: string | Buffer, txindex: string) => string;
    transactionFromRPCFormat: (txid: string | Buffer, _txindex: string, _reversed?: boolean | undefined) => string;
    /**
     * @deprecated Renamed to `transactionFromRPCFormat`.
     * Will be removed in 3.0.0.
     */
    transactionFromID: (txid: string | Buffer, _txindex: string, _reversed?: boolean | undefined) => string;
    resolveTokenGatewayContract: (asset: string) => string;
    getSPLTokenPubkey(asset: string): Promise<PublicKey>;
    constructRenVMMsg: (p_hash: Buffer, amount: string, token: Buffer, to: string, n_hash: Buffer) => Buffer[];
    /**
     * `submitMint` should take the completed mint transaction from RenVM and
     * submit its signature to the mint chain to finalize the mint.
     */
    submitMint: (asset: string, contractCalls: ContractCall[], mintTx: LockAndMintTransaction, eventEmitter: EventEmitterTyped<{
        transactionHash: [string];
        confirmation: [number, {
            status: number;
        }];
    }>) => Promise<string>;
    findMintByDepositDetails: (asset: string, sHash: Buffer, nHash: Buffer, pHash: Buffer, to: string, amount: string) => Promise<string | undefined>;
    /**
     * Fetch the mint and burn fees for an asset.
     */
    getFees(_asset: string): {
        burn: number;
        mint: number;
    };
    /**
     * Fetch the addresses' balance of the asset's representation on the chain.
     */
    getBalance(asset: string, address: SolAddress): Promise<BigNumber>;
    getMintParams: (asset: string) => Promise<OverwritableLockAndMintParams>;
    Account({ amount, value, address, }: {
        amount?: string | BigNumber;
        value?: string | BigNumber;
        address?: string;
    }): this;
    Params(params: OverwritableBurnAndReleaseParams): this;
    _getParams: ((burnPayload?: string) => OverwritableBurnAndReleaseParams) | undefined;
    getBurnParams: (_asset: string, burnPayload?: string | undefined) => OverwritableBurnAndReleaseParams | undefined;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    findBurn: (asset: string, eventEmitter: EventEmitterTyped<{
        transactionHash: [string];
    }>, _transaction?: string | undefined, burnNonce?: string | number | Buffer | undefined) => Promise<BurnDetails<SolTransaction> | undefined>;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    submitBurn: (asset: string, eventEmitter: EventEmitterTyped<{
        transactionHash: [string];
    }>, contractCalls: ContractCall[]) => Promise<BurnDetails<string>>;
    getAssociatedTokenAccount(asset: string, address?: string): Promise<PublicKey | false>;
    createAssociatedTokenAccount(asset: string, address?: string): Promise<string>;
}
export declare type Solana = SolanaClass;
export declare const Solana: import("@renproject/utils").CallableConstructor<typeof SolanaClass>;
export {};
