/// <reference types="node" />
import { AbiItem, DepositCommon, LockAndMintParams, LockAndMintTransaction, Logger, PromiEvent, RenNetworkDetails, TxStatus } from "@renproject/interfaces";
import { AbstractRenVMProvider } from "@renproject/rpc";
import { EventEmitter } from "events";
import { RenJSConfig } from "./config";
interface MintState {
    logger: Logger;
    selector: string;
    config: RenJSConfig & {
        networkDelay: number;
    };
}
interface MintStatePartial {
    renNetwork: RenNetworkDetails;
    gPubKey: Buffer;
    gHash: Buffer;
    pHash: Buffer;
    targetConfirmations: number | undefined;
    token?: string;
}
export interface DepositState {
    renTxSubmitted: boolean;
    queryTxResult?: LockAndMintTransaction;
    queryTxResultTimestamp?: number | undefined;
    gHash: Buffer;
    gPubKey: Buffer;
    nHash: Buffer;
    nonce: Buffer;
    output: {
        txindex: string;
        txid: Buffer;
    };
    amount: string;
    payload: Buffer;
    pHash: Buffer;
    to: string;
    fn: string;
    fnABI: AbiItem[];
    tags: [] | [string];
    txHash: string;
}
/**
 * A `LockAndMint` object tied to a particular gateway address. LockAndMint
 * should not be created directly. Instead, [[RenJS.lockAndMint]] will create a
 * `LockAndMint` object.
 *
 * `LockAndMint` extends the EventEmitter class, and emits a `"deposit"` event
 * for each new deposit that is observed. Deposits will only be watched for if
 * there is an active listener for the `"deposit"` event.
 *
 * A LockAndMint object watches transactions to the [[gatewayAddress]] on the
 * lock-chain.
 *
 * Deposits to the gateway address can be listened to with the `"deposit"`
 * event using [[on]], which will return [[LockAndMintDeposit]] instances.
 *
 * ```ts
 * console.log(`Deposit to ${JSON.stringify(lockAndMint.gatewayAddress)}`);
 *
 * lockAndMint.on("deposit", async (deposit) => {
 *    console.log(`Received deposit`, deposit);
 *    await RenJS.defaultDepositHandler(deposit);
 * });
 * ```
 *
 * @noInheritDoc
 */
export declare class LockAndMint<
/**
 * @hidden
 */
LockTransaction = any, LockDeposit extends DepositCommon<LockTransaction> = DepositCommon<LockTransaction>, LockAddress extends string | {
    address: string;
} = any, MintTransaction = any, MintAddress extends string | {
    address: string;
} = any> extends EventEmitter {
    /**
     * The generated gateway address for the lock-chain. For chains such as BTC
     * this is a string. For other chains, this may be an object, so the method
     * of showing this address to users should be implemented on a
     * chain-by-chain basis.
     */
    gatewayAddress: LockAddress | undefined;
    /** The parameters passed in when creating the LockAndMint. */
    params: LockAndMintParams<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>;
    /** See [[RenJS.renVM]]. */
    renVM: AbstractRenVMProvider;
    /**
     * Internal state of the mint object, including the `gHash` and `pHash`.
     * Interface may change across minor and patch releases.
     */
    _state: MintState & Partial<MintStatePartial>;
    /**
     * Deposits represents the lock deposits that have been detected so far.
     */
    private deposits;
    private getDepositsProgress;
    /**
     * @hidden - should be created using [[RenJS.lockAndMint]] instead.
     */
    constructor(renVM: AbstractRenVMProvider, params: LockAndMintParams<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>, config?: RenJSConfig);
    confirmationTarget: () => Promise<number>;
    /**
     * @hidden - Called automatically when calling [[RenJS.lockAndMint]]. It has
     * been split from the constructor because it's asynchronous.
     */
    readonly _initialize: () => Promise<LockAndMint<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>>;
    /**
     * `processDeposit` allows you to manually provide the details of a deposit
     * and returns a [[LockAndMintDeposit]] object.
     *
     * @param deposit The deposit details in the format defined by the
     * LockChain. This should be the same format as `deposit.depositDetails` for
     * a deposit returned from `.on("deposit", ...)`.
     *
     * ```ts
     * lockAndMint
     *   .processDeposit({
     *       transaction: {
     *           cid:
     *               "bafy2bzacedvu74e7ohjcwlh4fbx7ddf6li42fiuosajob6metcj2qwkgkgof2",
     *           to: "t1v2ftlxhedyoijv7uqgxfygiziaqz23lgkvks77i",
     *           amount: (0.01 * 1e8).toString(),
     *           params: "EzGbvVHf8lb0v8CUfjh8y+tLbZzfIFcnNnt/gh6axmw=",
     *           confirmations: 1,
     *           nonce: 7,
     *       },
     *       amount: (0.01 * 1e8).toString(),
     *   })
     *   .on(deposit => RenJS.defaultDepositHandler)
     *   .catch(console.error);
     * ```
     *
     * @category Main
     */
    processDeposit: (deposit: LockDeposit) => Promise<LockAndMintDeposit<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>>;
    addListener: <Event_1 extends "deposit">(event: Event_1, listener: Event_1 extends "deposit" ? (deposit: LockAndMintDeposit<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>) => void : never) => this;
    /**
     * `on` creates a new listener to `"deposit"` events, returning
     * [[LockAndMintDeposit]] instances.
     *
     * `on` extends `EventEmitter.on`, modifying it to immediately return all
     * previous `"deposit"` events, in addition to new events, when a new
     * listener is created.
     *
     * @category Main
     */
    on: <Event_1 extends "deposit">(event: Event_1, listener: Event_1 extends "deposit" ? (deposit: LockAndMintDeposit<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>) => void : never) => this;
    private readonly generateGatewayAddress;
    private readonly wait;
}
export declare enum DepositStatus {
    Detected = "detected",
    Confirmed = "confirmed",
    Signed = "signed",
    Reverted = "reverted",
    Submitted = "submitted"
}
export declare const DepositStatusIndex: {
    detected: number;
    confirmed: number;
    signed: number;
    reverted: number;
    submitted: number;
};
/**
 * A LockAndMintDeposit represents a deposit that has been made to a gateway
 * address.
 *
 * Once it has been detected, the steps required to complete the mint are:
 * 1. Wait for the transaction to be mined. The number of confirmations here
 * depends on the asset.
 * 2. Submit the deposit to RenVM and wait for a signature.
 * 3. Submit the deposit to the lock-chain.
 *
 * Each of these steps can be performed using their respective methods. Each
 * of these return a PromiEvent, meaning that in addition to being a promise,
 * they also emit events that can be listened to.
 *
 * ```ts
 * await deposit.confirmed();
 * await deposit.signed();
 * await deposit.mint();
 * ```
 */
export declare class LockAndMintDeposit<LockTransaction = any, LockDeposit extends DepositCommon<LockTransaction> = DepositCommon<LockTransaction>, LockAddress extends string | {
    address: string;
} = any, MintTransaction = any, MintAddress extends string | {
    address: string;
} = any> {
    /** The details, including amount, of the deposit. */
    depositDetails: LockDeposit;
    /** The parameters passed in when calling [[RenJS.lockAndMint]]. */
    params: LockAndMintParams<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>;
    /**
     * The status of the deposit, updated automatically. You can also call
     * `refreshStatus` to re-fetch this.
     *
     * ```ts
     * deposit.status;
     * // > "signed"
     * ```
     */
    status: DepositStatus;
    /** See [[RenJS.renVM]]. */
    renVM: AbstractRenVMProvider;
    mintTransaction?: MintTransaction;
    revertReason?: string;
    gatewayAddress: LockAddress | undefined;
    /**
     * Internal state of the mint object, including the `gHash` and `pHash`.
     * Interface may change across minor and patch releases.
     */
    _state: MintState & MintStatePartial & DepositState;
    /** @hidden */
    constructor(depositDetails: LockDeposit, params: LockAndMintParams<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>, renVM: AbstractRenVMProvider, state: MintState & MintStatePartial, gatewayAddress?: LockAddress);
    /** @hidden */
    readonly _initialize: () => Promise<this>;
    /**
     * `txHash` returns the RenVM transaction hash, which is distinct from the
     * lock or mint chain transaction hashes. It can be used to query the
     * lock-and-mint details from RenVM  once they've been submitted to it.
     *
     * The RenVM txHash is a URL-base64 string.
     *
     * ```ts
     * deposit.txHash();
     * // > "QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI"
     * ```
     */
    txHash: () => string;
    /**
     * `queryTx` fetches the RenVM transaction details of the deposit.
     *
     * ```ts
     * await deposit.queryTx();
     * // > { to: "...", hash: "...", status: "done", in: {...}, out: {...} }
     */
    queryTx: (retries?: number) => Promise<LockAndMintTransaction>;
    /**
     * `refreshStatus` fetches the deposit's status on the mint-chain, RenVM
     * and lock-chain to calculate it's [[DepositStatus]].
     *
     * ```ts
     * await deposit.refreshStatus();
     * // > "signed"
     * ```
     */
    refreshStatus: () => Promise<DepositStatus>;
    /**
     * `confirmations` returns the deposit's current and target number of
     * confirmations on the lock-chain.
     *
     * ```ts
     * await deposit
     *  .confirmations();
     * // > { current: 4, target: 6 }
     * ```
     */
    confirmations: () => Promise<{
        current: number;
        target: number;
    }>;
    confirmationTarget: () => Promise<number>;
    /**
     * `confirmed` will return once the deposit has reached the target number of
     * confirmations.
     *
     * It returns a PromiEvent which emits a `"confirmation"` event with the
     * current and target number of confirmations as the event parameters.
     *
     * The events emitted by the PromiEvent are:
     * 1. `"confirmation"` - called when a new confirmation is seen
     * 2. `"target"` - called immediately to make the target confirmations
     * available.
     *
     * ```ts
     * await deposit
     *  .confirmed()
     *  .on("target", (target) => console.log(`Waiting for ${target} confirmations`))
     *  .on("confirmation", (confs, target) => console.log(`${confs}/${target}`))
     * ```
     *
     * @category Main
     */
    confirmed: () => PromiEvent<LockAndMintDeposit<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>, {
        confirmation: [number, number];
        target: [number];
    }>;
    /**
     * `signed` waits for RenVM's signature to be available.
     *
     * It returns a PromiEvent which emits a `"txHash"` event with the deposit's
     * RenVM txHash (aka Transaction ID).
     *
     * ```ts
     * await deposit
     *  .signed()
     *  .on("txHash", (txHash) => console.log(txHash))
     * ```
     *
     * The events emitted by the PromiEvent are:
     * 1. `txHash` - the RenVM transaction hash of the deposit.
     * 2. `status` - the RenVM status of the transaction, of type [[TxStatus]].
     *
     * @category Main
     */
    signed: () => PromiEvent<LockAndMintDeposit<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>, {
        txHash: [string];
        status: [TxStatus];
    }>;
    /**
     * `findTransaction` checks if the deposit signature has already been
     * submitted to the mint chain.
     *
     * ```ts
     * await deposit.findTransaction();
     * // > "0x1234" // (or undefined)
     * ```
     */
    findTransaction: () => Promise<MintTransaction | undefined>;
    /**
     * `mint` submits the RenVM signature to the mint chain.
     *
     * It returns a PromiEvent and the events emitted depend on the mint chain.
     *
     * The PromiEvent's events are defined by the mint-chain implementation. For
     * Ethereum, it emits the same events as a Web3 PromiEvent.
     *
     * @category Main
     */
    mint: (override?: {
        [name: string]: unknown;
    } | undefined) => PromiEvent<MintTransaction, {
        transactionHash: [string];
        confirmation: [number, {
            status: number;
        }];
    }>;
    /**
     * `_submitMintTransaction` will create the RebVN mint transaction and return
     * its txHash. If `config.submit` is true, it will also submit it to RenVM.
     *
     * Note that `_submitMintTransaction`'s return type changes from `string` to
     * `Promise<string>` if `config.submit` is true. This may be split up into
     * two methods in the future to avoid this weirdness - likely once the `v1`
     * RPC format is phased out.
     *
     * @param config Set `config.submit` to `true` to submit the transaction.
     */
    private _submitMintTransaction;
    private readonly validateParams;
}
export {};
