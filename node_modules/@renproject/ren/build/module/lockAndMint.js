var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { getRenNetworkDetails, newPromiEvent, NullLogger, RenJSErrors, TxStatus, TxStatusIndex, } from "@renproject/interfaces";
import { assertObject, assertType, emptyNonce, extractError, fromBase64, fromHex, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, keccak256, overrideContractCalls, Ox, payloadToMintABI, renVMHashToBase64, retryNTimes, SECONDS, sleep, strip0x, toBase64, toURLBase64, } from "@renproject/utils";
import { EventEmitter } from "events";
import { OrderedMap } from "immutable";
import base58 from "bs58";
import { defaultAbiCoder } from "ethers/lib/utils";
/**
 * A `LockAndMint` object tied to a particular gateway address. LockAndMint
 * should not be created directly. Instead, [[RenJS.lockAndMint]] will create a
 * `LockAndMint` object.
 *
 * `LockAndMint` extends the EventEmitter class, and emits a `"deposit"` event
 * for each new deposit that is observed. Deposits will only be watched for if
 * there is an active listener for the `"deposit"` event.
 *
 * A LockAndMint object watches transactions to the [[gatewayAddress]] on the
 * lock-chain.
 *
 * Deposits to the gateway address can be listened to with the `"deposit"`
 * event using [[on]], which will return [[LockAndMintDeposit]] instances.
 *
 * ```ts
 * console.log(`Deposit to ${JSON.stringify(lockAndMint.gatewayAddress)}`);
 *
 * lockAndMint.on("deposit", async (deposit) => {
 *    console.log(`Received deposit`, deposit);
 *    await RenJS.defaultDepositHandler(deposit);
 * });
 * ```
 *
 * @noInheritDoc
 */
export class LockAndMint extends EventEmitter {
    /**
     * @hidden - should be created using [[RenJS.lockAndMint]] instead.
     */
    constructor(renVM, params, config = {}) {
        super();
        /**
         * Deposits represents the lock deposits that have been detected so far.
         */
        this.deposits = OrderedMap();
        this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {
            if (isDefined(this._state.targetConfirmations)) {
                return this._state.targetConfirmations;
            }
            let target;
            const getConfirmationTarget = this.renVM.getConfirmationTarget;
            if (getConfirmationTarget) {
                target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {
                    return getConfirmationTarget(this._state.selector, this.params.from);
                }), 2);
            }
            const defaultConfirmations = this._state.renNetwork && this._state.renNetwork.isTestnet ? 2 : 6;
            this._state.targetConfirmations = isDefined(target)
                ? target
                : defaultConfirmations;
            return this._state.targetConfirmations;
        });
        /**
         * @hidden - Called automatically when calling [[RenJS.lockAndMint]]. It has
         * been split from the constructor because it's asynchronous.
         */
        this._initialize = () => __awaiter(this, void 0, void 0, function* () {
            this._state.renNetwork =
                this._state.renNetwork ||
                    getRenNetworkDetails(yield this.renVM.getNetwork(this._state.selector));
            if (!this.params.from.renNetwork) {
                yield this.params.from.initialize(this._state.renNetwork);
            }
            if (!this.params.to.renNetwork) {
                yield this.params.to.initialize(this._state.renNetwork);
            }
            const overwriteParams = this.params.to.getMintParams &&
                (yield this.params.to.getMintParams(this.params.asset));
            this.params = Object.assign(Object.assign({}, overwriteParams), this.params);
            try {
                this.gatewayAddress = yield this.generateGatewayAddress();
            }
            catch (error) {
                throw error;
            }
            // Will fetch deposits as long as there's at least one deposit.
            this.wait().catch(console.error);
            try {
                this._state.targetConfirmations = yield this.confirmationTarget();
            }
            catch (error) {
                console.error(error);
            }
            return this;
        });
        /**
         * `processDeposit` allows you to manually provide the details of a deposit
         * and returns a [[LockAndMintDeposit]] object.
         *
         * @param deposit The deposit details in the format defined by the
         * LockChain. This should be the same format as `deposit.depositDetails` for
         * a deposit returned from `.on("deposit", ...)`.
         *
         * ```ts
         * lockAndMint
         *   .processDeposit({
         *       transaction: {
         *           cid:
         *               "bafy2bzacedvu74e7ohjcwlh4fbx7ddf6li42fiuosajob6metcj2qwkgkgof2",
         *           to: "t1v2ftlxhedyoijv7uqgxfygiziaqz23lgkvks77i",
         *           amount: (0.01 * 1e8).toString(),
         *           params: "EzGbvVHf8lb0v8CUfjh8y+tLbZzfIFcnNnt/gh6axmw=",
         *           confirmations: 1,
         *           nonce: 7,
         *       },
         *       amount: (0.01 * 1e8).toString(),
         *   })
         *   .on(deposit => RenJS.defaultDepositHandler)
         *   .catch(console.error);
         * ```
         *
         * @category Main
         */
        this.processDeposit = (deposit) => __awaiter(this, void 0, void 0, function* () {
            if (!this._state.renNetwork ||
                !this._state.pHash ||
                !this._state.gHash ||
                !this._state.gPubKey ||
                !this.gatewayAddress) {
                throw new Error("Gateway address must be generated before calling 'wait'.");
            }
            const depositID = this.params.from.transactionID(deposit.transaction);
            let depositObject = this.deposits.get(depositID);
            // If the transaction hasn't been seen before.
            if (!depositObject) {
                depositObject = new LockAndMintDeposit(deposit, this.params, this.renVM, Object.assign(Object.assign({}, this._state), { renNetwork: this._state.renNetwork, pHash: this._state.pHash, gHash: this._state.gHash, gPubKey: this._state.gPubKey, token: this._state.token, targetConfirmations: isDefined(this._state.targetConfirmations)
                        ? this._state.targetConfirmations
                        : undefined }), this.gatewayAddress);
                this.deposits = this.deposits.set(depositID, depositObject);
                yield depositObject._initialize();
                // Check if deposit has already been submitted.
                if (this._state.config.loadCompletedDeposits ||
                    depositObject.status !== DepositStatus.Submitted) {
                    this.emit("deposit", depositObject);
                    // this.deposits.set(deposit);
                    this._state.logger.debug("new deposit:", deposit);
                    this.deposits = this.deposits.set(depositID, depositObject);
                }
            }
            return depositObject;
        });
        this.addListener = (event, listener) => {
            // Emit previous deposit events.
            if (event === "deposit") {
                this.deposits.map((deposit) => {
                    listener(deposit);
                });
            }
            super.on(event, listener);
            return this;
        };
        /**
         * `on` creates a new listener to `"deposit"` events, returning
         * [[LockAndMintDeposit]] instances.
         *
         * `on` extends `EventEmitter.on`, modifying it to immediately return all
         * previous `"deposit"` events, in addition to new events, when a new
         * listener is created.
         *
         * @category Main
         */
        this.on = (event, listener) => this.addListener(event, listener);
        // Private methods /////////////////////////////////////////////////////////
        this.generateGatewayAddress = () => __awaiter(this, void 0, void 0, function* () {
            if (this.gatewayAddress) {
                return this.gatewayAddress;
            }
            const { nonce, contractCalls } = this.params;
            if (!nonce) {
                throw new Error(`Must call 'initialize' before calling 'generateGatewayAddress'.`);
            }
            if (!contractCalls) {
                throw new Error(`Must provide contract call details.`);
            }
            // Last contract call
            const { contractParams, sendTo, contractFn } = contractCalls[contractCalls.length - 1];
            // FIXME: dirty hack, but we need to re-write how we deal with
            // addresses in order to do this cleanly
            // (need to follow the multichain address pattern)
            const sendToHex = this.params.to.name == "Solana"
                ? base58.decode(sendTo).toString("hex")
                : sendTo;
            this._state.pHash = generatePHash(contractParams || [], this._state.logger);
            // Check if the transaction is either a v0.2 transaction, or has the
            // version set to `0` in a v0.4 transaction.
            // See [RenJSConfig.transactionVersion]
            const v0Transaction = this.renVM.version(this._state.selector) === 1 ||
                this._state.config.transactionVersion === 0;
            const tokenGatewayContract = !v0Transaction
                ? Ox(generateSHash(this._state.selector))
                : yield this.params.to.resolveTokenGatewayContract(this.params.asset);
            const gHash = generateGHash(contractParams || [], sendToHex, tokenGatewayContract, fromHex(nonce), !v0Transaction, this._state.logger);
            this._state.gHash = gHash;
            this._state.gPubKey =
                this._state.config.gPubKey &&
                    this._state.config.gPubKey.length > 0
                    ? this._state.config.gPubKey
                    : yield this.renVM.selectPublicKey(this._state.selector, this.renVM.version(this._state.selector) >= 2
                        ? this.params.from.name
                        : this.params.asset);
            this._state.logger.debug("gPubKey:", Ox(this._state.gPubKey));
            if (!this._state.gPubKey || this._state.gPubKey.length === 0) {
                throw new Error("Unable to fetch RenVM shard public key.");
            }
            if (!gHash || gHash.length === 0) {
                throw new Error("Invalid gateway hash being passed to gateway address generation.");
            }
            if (!this.params.asset || this.params.asset.length === 0) {
                throw new Error("Invalid asset being passed to gateway address generation.");
            }
            const gatewayAddress = yield this.params.from.getGatewayAddress(this.params.asset, this._state.gPubKey, gHash);
            this.gatewayAddress = gatewayAddress;
            this._state.logger.debug("gateway address:", this.gatewayAddress);
            const filteredContractParams = contractParams
                ? contractParams.filter((contractParam) => !contractParam.notInPayload)
                : contractParams;
            const encodedParameters = defaultAbiCoder.encode((filteredContractParams || []).map((i) => i.type), (filteredContractParams || []).map((i) => i.value));
            const fnABI = payloadToMintABI(contractFn, filteredContractParams || []);
            if (this.params.tags && this.params.tags.length > 1) {
                throw new Error("Providing multiple tags is not supported yet.");
            }
            const tags = this.params.tags && this.params.tags.length
                ? [this.params.tags[0]]
                : [];
            this._state.token =
                yield this.params.to.resolveTokenGatewayContract(this.params.asset);
            if (this.renVM.submitGatewayDetails) {
                const promise = this.renVM.submitGatewayDetails(this.params.from.addressToString(gatewayAddress), Object.assign(Object.assign({}, this._state), { token: this._state.token, nHash: Buffer.from("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", "base64"), payload: fromHex(encodedParameters), nonce: fromHex(nonce), fn: contractFn, fnABI, to: this.renVM.version(this._state.selector) >= 2
                        ? strip0x(sendTo)
                        : Ox(sendTo), tags, 
                    // See [RenJSConfig.transactionVersion]
                    transactionVersion: this._state.config.transactionVersion }), 5);
                if (promise.catch) {
                    promise.catch(console.error);
                }
            }
            return this.gatewayAddress;
        });
        this.wait = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._state.pHash ||
                !this._state.gHash ||
                !this._state.gPubKey ||
                !this.gatewayAddress) {
                throw new Error("Gateway address must be generated before calling 'wait'.");
            }
            while (true) {
                const listenerCancelled = () => this.listenerCount("deposit") === 0;
                try {
                    // If there are no listeners, continue. TODO: Exit loop entirely
                    // until a lister is added again.
                    if (listenerCancelled()) {
                        yield sleep(1 * SECONDS);
                        continue;
                    }
                }
                catch (error) {
                    this._state.logger.error(extractError(error));
                }
                // Change the return type of `this.processDeposit` to `void`.
                const onDeposit = (deposit) => __awaiter(this, void 0, void 0, function* () {
                    yield this.processDeposit(deposit);
                });
                // TODO: Flag deposits that have been cancelled, updating their status.
                const cancelDeposit = () => __awaiter(this, void 0, void 0, function* () { return Promise.resolve(); });
                try {
                    this.getDepositsProgress = yield this.params.from.getDeposits(this.params.asset, this.gatewayAddress, this.getDepositsProgress, onDeposit, cancelDeposit, listenerCancelled);
                }
                catch (error) {
                    this._state.logger.error(extractError(error));
                }
                yield sleep(this._state.config.networkDelay);
            }
        });
        this.params = params;
        this.renVM = renVM;
        this._state = {
            logger: config.logger || NullLogger,
            selector: this.renVM.selector(this.params),
            config: Object.assign(Object.assign({}, config), { networkDelay: config.networkDelay || 15 * SECONDS }),
        };
        const txHash = this.params.txHash;
        // Decode nonce or use empty nonce 0x0.
        const nonce = this.params.nonce
            ? fromHex(this.params.nonce)
            : emptyNonce();
        this.params.nonce = nonce;
        if (!txHash) {
            this.params.nonce = nonce;
        }
        {
            // Debug log
            const _a = this.params, { to: _to, from: _from } = _a, restOfParams = __rest(_a, ["to", "from"]);
            this._state.logger.debug("lockAndMint created:", restOfParams);
        }
    }
}
export var DepositStatus;
(function (DepositStatus) {
    DepositStatus["Detected"] = "detected";
    DepositStatus["Confirmed"] = "confirmed";
    DepositStatus["Signed"] = "signed";
    DepositStatus["Reverted"] = "reverted";
    DepositStatus["Submitted"] = "submitted";
})(DepositStatus || (DepositStatus = {}));
export const DepositStatusIndex = {
    [DepositStatus.Detected]: 0,
    [DepositStatus.Confirmed]: 1,
    [DepositStatus.Signed]: 2,
    [DepositStatus.Reverted]: 3,
    [DepositStatus.Submitted]: 4,
};
/**
 * A LockAndMintDeposit represents a deposit that has been made to a gateway
 * address.
 *
 * Once it has been detected, the steps required to complete the mint are:
 * 1. Wait for the transaction to be mined. The number of confirmations here
 * depends on the asset.
 * 2. Submit the deposit to RenVM and wait for a signature.
 * 3. Submit the deposit to the lock-chain.
 *
 * Each of these steps can be performed using their respective methods. Each
 * of these return a PromiEvent, meaning that in addition to being a promise,
 * they also emit events that can be listened to.
 *
 * ```ts
 * await deposit.confirmed();
 * await deposit.signed();
 * await deposit.mint();
 * ```
 */
export class LockAndMintDeposit {
    /** @hidden */
    constructor(depositDetails, params, renVM, state, gatewayAddress) {
        /** @hidden */
        this._initialize = () => __awaiter(this, void 0, void 0, function* () {
            yield this.refreshStatus();
            return this;
        });
        /**
         * `txHash` returns the RenVM transaction hash, which is distinct from the
         * lock or mint chain transaction hashes. It can be used to query the
         * lock-and-mint details from RenVM  once they've been submitted to it.
         *
         * The RenVM txHash is a URL-base64 string.
         *
         * ```ts
         * deposit.txHash();
         * // > "QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI"
         * ```
         */
        this.txHash = () => {
            // The type of `txHash` is a function instead of a string to match the
            // interface of BurnAndRelease.
            return this._state.txHash;
        };
        /**
         * `queryTx` fetches the RenVM transaction details of the deposit.
         *
         * ```ts
         * await deposit.queryTx();
         * // > { to: "...", hash: "...", status: "done", in: {...}, out: {...} }
         */
        this.queryTx = (retries = 2) => __awaiter(this, void 0, void 0, function* () {
            if (DepositStatusIndex[this.status] >=
                DepositStatusIndex[DepositStatus.Signed] &&
                this._state.queryTxResult) {
                return this._state.queryTxResult;
            }
            const response = yield this.renVM.queryMintOrBurn(this._state.selector, fromBase64(this.txHash()), retries);
            this._state.queryTxResult = response;
            // Update status.
            if (response.out && response.out.revert !== undefined) {
                this.status = DepositStatus.Reverted;
                this.revertReason = response.out.revert.toString();
            }
            else if (response.out && response.out.signature) {
                if (DepositStatusIndex[this.status] <
                    DepositStatusIndex[DepositStatus.Signed]) {
                    this.status = DepositStatus.Signed;
                }
            }
            return response;
        });
        /**
         * `refreshStatus` fetches the deposit's status on the mint-chain, RenVM
         * and lock-chain to calculate it's [[DepositStatus]].
         *
         * ```ts
         * await deposit.refreshStatus();
         * // > "signed"
         * ```
         */
        this.refreshStatus = () => __awaiter(this, void 0, void 0, function* () {
            const status = yield (() => __awaiter(this, void 0, void 0, function* () {
                let queryTxResult;
                // Fetch sighash.
                try {
                    queryTxResult = yield this.queryTx(1);
                }
                catch (_error) {
                    // Ignore error.
                    queryTxResult = null;
                }
                try {
                    // Check if the transaction has been submitted to the mint-chain.
                    const transaction = yield this.findTransaction();
                    if (transaction !== undefined) {
                        return DepositStatus.Submitted;
                    }
                }
                catch (_error) {
                    // Ignore error.
                }
                try {
                    queryTxResult =
                        queryTxResult === undefined
                            ? yield this.queryTx(1)
                            : queryTxResult;
                    if (queryTxResult &&
                        queryTxResult.txStatus === TxStatus.TxStatusDone) {
                        // Check if transaction was reverted.
                        if (queryTxResult.out &&
                            queryTxResult.out.revert !== undefined) {
                            this.status = DepositStatus.Reverted;
                            this.revertReason = queryTxResult.out.revert.toString();
                        }
                        else {
                            return DepositStatus.Signed;
                        }
                    }
                }
                catch (_error) {
                    // Ignore error.
                }
                try {
                    const confirmations = yield this.confirmations();
                    if (confirmations.current >= confirmations.target) {
                        return DepositStatus.Confirmed;
                    }
                }
                catch (_error) {
                    // Ignore error.
                }
                return DepositStatus.Detected;
            }))();
            this.status = status;
            return status;
        });
        /**
         * `confirmations` returns the deposit's current and target number of
         * confirmations on the lock-chain.
         *
         * ```ts
         * await deposit
         *  .confirmations();
         * // > { current: 4, target: 6 }
         * ```
         */
        this.confirmations = () => __awaiter(this, void 0, void 0, function* () {
            const { current, target } = yield this.params.from.transactionConfidence(this.depositDetails.transaction);
            return {
                current,
                target: isDefined(this._state.targetConfirmations)
                    ? this._state.targetConfirmations
                    : target,
            };
        });
        this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {
            if (isDefined(this._state.targetConfirmations)) {
                return this._state.targetConfirmations;
            }
            let target;
            const getConfirmationTarget = this.renVM.getConfirmationTarget;
            if (getConfirmationTarget) {
                target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {
                    return getConfirmationTarget(this._state.selector, this.params.from);
                }), 2);
            }
            const defaultConfirmations = this._state.renNetwork && this._state.renNetwork.isTestnet ? 2 : 6;
            this._state.targetConfirmations = isDefined(target)
                ? target
                : defaultConfirmations;
            return this._state.targetConfirmations;
        });
        /**
         * `confirmed` will return once the deposit has reached the target number of
         * confirmations.
         *
         * It returns a PromiEvent which emits a `"confirmation"` event with the
         * current and target number of confirmations as the event parameters.
         *
         * The events emitted by the PromiEvent are:
         * 1. `"confirmation"` - called when a new confirmation is seen
         * 2. `"target"` - called immediately to make the target confirmations
         * available.
         *
         * ```ts
         * await deposit
         *  .confirmed()
         *  .on("target", (target) => console.log(`Waiting for ${target} confirmations`))
         *  .on("confirmation", (confs, target) => console.log(`${confs}/${target}`))
         * ```
         *
         * @category Main
         */
        this.confirmed = () => {
            const promiEvent = newPromiEvent();
            (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    promiEvent.emit("target", yield this.confirmationTarget());
                }
                catch (error) {
                    this._state.logger.error(error);
                }
                // If the transaction has been confirmed according to RenVM, return.
                const transactionIsConfirmed = () => DepositStatusIndex[this.status] >=
                    DepositStatusIndex[DepositStatus.Confirmed] ||
                    (this._state.queryTxResult &&
                        TxStatusIndex[this._state.queryTxResult.txStatus] >=
                            TxStatusIndex[TxStatus.TxStatusPending]);
                let iterationCount = 0;
                let currentConfidenceRatio = 0;
                // Continue while the transaction isn't confirmed and the promievent
                // isn't cancelled.
                while (!promiEvent._isCancelled() && !transactionIsConfirmed()) {
                    // In the first loop, submit to RenVM immediately.
                    if (iterationCount % 5 === 0) {
                        try {
                            if (!this._state.renTxSubmitted) {
                                yield this._submitMintTransaction();
                            }
                            yield this.queryTx();
                            if (transactionIsConfirmed()) {
                                break;
                            }
                        }
                        catch (error) {
                            // Ignore error.
                            this._state.logger.debug(error);
                        }
                    }
                    try {
                        const confidence = yield this.confirmations();
                        const confidenceRatio = confidence.target === 0
                            ? 1
                            : confidence.current / confidence.target;
                        if (confidenceRatio > currentConfidenceRatio) {
                            currentConfidenceRatio = confidenceRatio;
                            promiEvent.emit("confirmation", confidence.current, confidence.target);
                        }
                        if (confidenceRatio >= 1) {
                            break;
                        }
                        this._state.logger.debug(`deposit confidence: ${confidence.current} / ${confidence.target}`);
                    }
                    catch (error) {
                        this._state.logger.error(`Error fetching transaction confidence: ${extractError(error)}`);
                    }
                    yield sleep(this._state.config.networkDelay);
                    iterationCount += 1;
                }
                // Update status.
                if (DepositStatusIndex[this.status] <
                    DepositStatusIndex[DepositStatus.Confirmed]) {
                    this.status = DepositStatus.Confirmed;
                }
                return this;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        /**
         * `signed` waits for RenVM's signature to be available.
         *
         * It returns a PromiEvent which emits a `"txHash"` event with the deposit's
         * RenVM txHash (aka Transaction ID).
         *
         * ```ts
         * await deposit
         *  .signed()
         *  .on("txHash", (txHash) => console.log(txHash))
         * ```
         *
         * The events emitted by the PromiEvent are:
         * 1. `txHash` - the RenVM transaction hash of the deposit.
         * 2. `status` - the RenVM status of the transaction, of type [[TxStatus]].
         *
         * @category Main
         */
        this.signed = () => {
            const promiEvent = newPromiEvent();
            (() => __awaiter(this, void 0, void 0, function* () {
                let txHash = this.txHash();
                // If the transaction has been reverted, throw the revert reason.
                if (this.status === DepositStatus.Reverted) {
                    throw new Error(this.revertReason ||
                        `RenVM transaction ${txHash} reverted.`);
                }
                // Check if the signature is already available.
                if (DepositStatusIndex[this.status] >=
                    DepositStatusIndex[DepositStatus.Signed] &&
                    this._state.queryTxResult &&
                    this._state.queryTxResult.out) {
                    // NO_COMMIT
                    // return this;
                }
                promiEvent.emit("txHash", txHash);
                this._state.logger.debug("RenVM txHash:", txHash);
                // Try to submit to RenVM. If that fails, see if they already
                // know about the transaction.
                try {
                    txHash = yield this._submitMintTransaction();
                }
                catch (error) {
                    console.error(error);
                    // this.logger.error(error);
                    try {
                        // Check if the darknodes have already seen the transaction
                        const queryTxResponse = yield this.queryTx();
                        if (queryTxResponse.txStatus === TxStatus.TxStatusNil) {
                            throw new Error(`Transaction ${txHash} has not been submitted previously.`);
                        }
                        txHash = queryTxResponse.hash;
                    }
                    catch (errorInner) {
                        let submitted = false;
                        // If transaction is not found, check for RenVM v0.2 error message.
                        if (errorInner.code === RenJSErrors.RenVMTransactionNotFound) {
                            if (error.code === RenJSErrors.AmountTooSmall ||
                                error.code === RenJSErrors.DepositSpentOrNotFound) {
                                this.status = DepositStatus.Reverted;
                                this.revertReason = String((error || {}).message).replace(/Node returned status \d+ with reason: /, "");
                                throw new Error(this.revertReason);
                            }
                            else {
                                // Retry submitting 2 more times to reduce chance
                                // of network issues causing problems.
                                txHash = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () { return this._submitMintTransaction(); }), 5, 5 * SECONDS);
                                submitted = true;
                            }
                        }
                        // Ignore errorInner.
                        this._state.logger.debug(errorInner);
                        if (!submitted) {
                            throw error;
                        }
                    }
                }
                const response = yield this.renVM.waitForTX(this._state.selector, fromBase64(txHash), (status) => {
                    promiEvent.emit("status", status);
                    this._state.logger.debug("transaction status:", status);
                }, () => promiEvent._isCancelled(), this._state.config.networkDelay);
                this._state.queryTxResult = response;
                // Update status.
                if (response.out && response.out.revert !== undefined) {
                    this.status = DepositStatus.Reverted;
                    this.revertReason = response.out.revert.toString();
                    throw new Error(this.revertReason);
                }
                else if (response.out && response.out.signature) {
                    if (DepositStatusIndex[this.status] <
                        DepositStatusIndex[DepositStatus.Signed]) {
                        this.status = DepositStatus.Signed;
                    }
                    this._state.logger.debug("signature:", response.out && response.out.signature);
                }
                return this;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        /**
         * `findTransaction` checks if the deposit signature has already been
         * submitted to the mint chain.
         *
         * ```ts
         * await deposit.findTransaction();
         * // > "0x1234" // (or undefined)
         * ```
         */
        this.findTransaction = () => __awaiter(this, void 0, void 0, function* () {
            if (this.params.to.findMint) {
                const sigHash = this._state.queryTxResult &&
                    this._state.queryTxResult.out &&
                    this._state.queryTxResult.out.revert === undefined
                    ? this._state.queryTxResult.out.sighash
                    : undefined;
                // Check if the signature has already been submitted
                this.mintTransaction = yield this.params.to.findMint(this.params.asset, this._state.nHash, sigHash);
                return this.mintTransaction;
            }
            if (this.params.contractCalls &&
                this.params.to.findMintByDepositDetails &&
                this._state.queryTxResult &&
                this._state.queryTxResult.out &&
                this._state.queryTxResult.out.revert === undefined) {
                this.mintTransaction =
                    yield this.params.to.findMintByDepositDetails(this.params.asset, keccak256(Buffer.from(this._state.selector)), this._state.nHash, this._state.pHash, this.params.contractCalls[0].sendTo, this._state.queryTxResult.out.amount);
                return this.mintTransaction;
            }
            return undefined;
        });
        /**
         * `mint` submits the RenVM signature to the mint chain.
         *
         * It returns a PromiEvent and the events emitted depend on the mint chain.
         *
         * The PromiEvent's events are defined by the mint-chain implementation. For
         * Ethereum, it emits the same events as a Web3 PromiEvent.
         *
         * @category Main
         */
        this.mint = (override) => {
            const promiEvent = newPromiEvent();
            (() => __awaiter(this, void 0, void 0, function* () {
                if (!this._state.queryTxResult) {
                    throw new Error(`Unable to submit to Ethereum without signature. Call 'signed' first.`);
                }
                const overrideArray = Object.keys(override || {}).map((key) => ({
                    name: key,
                    value: (override || {})[key],
                }));
                // Override contract call parameters that have been passed in to
                // "mint".
                let contractCalls = overrideContractCalls(this.params.contractCalls || [], { contractParams: overrideArray });
                // Filter parameters that should be included in the payload hash but
                // not the contract call.
                contractCalls = contractCalls.map((call) => (Object.assign(Object.assign({}, call), { contractParams: call.contractParams
                        ? call.contractParams.filter((param) => !param.onlyInPayload)
                        : call.contractParams })));
                const asset = this.params.asset;
                this.mintTransaction = yield this.params.to.submitMint(asset, contractCalls, this._state.queryTxResult, promiEvent);
                // Update status.
                this.status = DepositStatus.Submitted;
                return this.mintTransaction;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        // Private methods /////////////////////////////////////////////////////////
        /**
         * `_submitMintTransaction` will create the RebVN mint transaction and return
         * its txHash. If `config.submit` is true, it will also submit it to RenVM.
         *
         * Note that `_submitMintTransaction`'s return type changes from `string` to
         * `Promise<string>` if `config.submit` is true. This may be split up into
         * two methods in the future to avoid this weirdness - likely once the `v1`
         * RPC format is phased out.
         *
         * @param config Set `config.submit` to `true` to submit the transaction.
         */
        this._submitMintTransaction = () => __awaiter(this, void 0, void 0, function* () {
            const { token } = this._state;
            if (!token) {
                throw new Error(`Deposit object must be initialized.`);
            }
            const expectedTxHash = this.txHash();
            // Return if the transaction has already been successfully submitted.
            if (this._state.renTxSubmitted) {
                return expectedTxHash;
            }
            // The transaction has already been submitted and accepted.
            if (this._state.renTxSubmitted) {
                return expectedTxHash;
            }
            const encodedHash = yield this.renVM.submitMint(Object.assign(Object.assign({}, this._state), { token, 
                // See [RenJSConfig.transactionVersion]
                transactionVersion: this._state.config.transactionVersion }));
            const returnedTxHash = this.renVM.version(this._state.selector) >= 2
                ? toURLBase64(encodedHash)
                : toBase64(encodedHash);
            // Indicate that the tx has been submitted successfully.
            this._state.renTxSubmitted = true;
            if (returnedTxHash !== expectedTxHash) {
                this._state.logger.warn(`Unexpected txHash returned from RenVM. Received: ${returnedTxHash}, expected: ${expectedTxHash}`);
            }
            this._state.renTxSubmitted = true;
            return returnedTxHash;
        });
        this.validateParams = () => {
            assertObject({
                from: "object",
                to: "object",
                contractCalls: "any[]",
                asset: "string",
                txHash: "string | undefined",
                nonce: "Buffer | string | undefined",
                tags: "string[] | undefined",
            }, { params: this.params });
            if (this.params.contractCalls) {
                this.params.contractCalls.map((contractCall) => {
                    assertType("string", {
                        sendTo: contractCall.sendTo,
                        contractFn: contractCall.contractFn,
                    });
                });
            }
        };
        assertObject({
            transaction: "any",
            amount: "string",
        }, {
            depositDetails: depositDetails,
        });
        assertObject({
            selector: "string",
            logger: "object",
            renNetwork: "object",
            gPubKey: "Buffer",
            gHash: "Buffer",
            pHash: "Buffer",
            targetConfirmations: "number | undefined",
            config: "object",
        }, { state });
        this.depositDetails = depositDetails;
        this.params = params;
        this.renVM = renVM;
        this.gatewayAddress = gatewayAddress;
        // this._state = state;
        // `processDeposit` will call `refreshStatus` which will set the proper
        // status.
        this.status = DepositStatus.Detected;
        const { txHash, contractCalls, nonce } = this.params;
        if (!nonce) {
            throw new Error(`No nonce passed in to LockAndMintDeposit.`);
        }
        if (!txHash && (!contractCalls || !contractCalls.length)) {
            throw new Error(`Must provide Ren transaction hash or contract call details.`);
        }
        this.validateParams();
        const deposit = this.depositDetails;
        const providedTxHash = this.params.txHash
            ? renVMHashToBase64(this.params.txHash, this.renVM.version(state.selector) >= 2)
            : undefined;
        if (!contractCalls || !contractCalls.length) {
            throw new Error(`Unable to submit to RenVM without contract call details.`);
        }
        // Last contract call
        const { contractParams, sendTo, contractFn } = contractCalls[contractCalls.length - 1];
        const filteredContractParams = contractParams
            ? contractParams.filter((contractParam) => !contractParam.notInPayload)
            : contractParams;
        const encodedParameters = defaultAbiCoder.encode((filteredContractParams || []).map((i) => i.type), (filteredContractParams || []).map((i) => i.value));
        const { pHash, config } = state;
        // Check if the transaction is either a v0.2 transaction, or has the
        // version set to `0` in a v0.4 transaction.
        // See [RenJSConfig.transactionVersion]
        const v0Transaction = this.renVM.version(state.selector) === 1 ||
            config.transactionVersion === 0;
        const transactionDetails = this.params.from.transactionRPCFormat(this.depositDetails.transaction, !v0Transaction);
        const nHash = generateNHash(fromHex(nonce), transactionDetails.txid, transactionDetails.txindex, !v0Transaction);
        const outputHashFormat = renVM.version(state.selector) >= 2
            ? ""
            : this.params.from.depositV1HashString(deposit);
        const fnABI = payloadToMintABI(contractFn, filteredContractParams || []);
        if (this.params.tags && this.params.tags.length > 1) {
            throw new Error("Providing multiple tags is not supported yet.");
        }
        const tags = this.params.tags && this.params.tags.length
            ? [this.params.tags[0]]
            : [];
        this._state = Object.assign(Object.assign({}, state), { 
            // gHash
            // gPubKey
            nHash, nonce: fromHex(nonce), output: this.params.from.transactionRPCFormat(deposit.transaction, renVM.version(state.selector) >= 2), amount: deposit.amount, payload: fromHex(encodedParameters), pHash, to: renVM.version(state.selector) >= 2
                ? strip0x(sendTo)
                : Ox(sendTo), fn: contractFn, fnABI,
            tags, 
            // Will be set in the next statement.
            txHash: "", renTxSubmitted: false });
        this._state.txHash = (renVM.version(this._state.selector) >= 2 ? toURLBase64 : toBase64)(this.renVM.mintTxHash(Object.assign(Object.assign({}, this._state), { outputHashFormat, 
            // See [RenJSConfig.transactionVersion]
            transactionVersion: config.transactionVersion })));
        if (providedTxHash &&
            !fromBase64(providedTxHash).equals(fromBase64(this.txHash()))) {
            throw new Error(`Inconsistent RenVM transaction hash: got ${providedTxHash} but expected ${this.txHash()}.`);
        }
        {
            // Debug log
            const _a = this.params, { to: _to, from: _from } = _a, restOfParams = __rest(_a, ["to", "from"]);
            this._state.logger.debug("LockAndMintDeposit created", depositDetails, restOfParams);
        }
    }
}
//# sourceMappingURL=lockAndMint.js.map