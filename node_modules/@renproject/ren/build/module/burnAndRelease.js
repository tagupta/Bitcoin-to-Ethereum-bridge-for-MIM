var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { getRenNetworkDetails, newPromiEvent, NullLogger, } from "@renproject/interfaces";
import { assertObject, assertType, fromBase64, generateBurnTxHash, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, Ox, renVMHashToBase64, retryNTimes, SECONDS, sleep, toBase64, toURLBase64, } from "@renproject/utils";
import BN from "bn.js";
import BigNumber from "bignumber.js";
export var BurnAndReleaseStatus;
(function (BurnAndReleaseStatus) {
    BurnAndReleaseStatus["Pending"] = "pending";
    BurnAndReleaseStatus["Burned"] = "burned";
    BurnAndReleaseStatus["Released"] = "released";
    BurnAndReleaseStatus["Reverted"] = "reverted";
})(BurnAndReleaseStatus || (BurnAndReleaseStatus = {}));
export class BurnAndRelease {
    /** @hidden */
    constructor(renVM, params, config = {}) {
        this.validateParams = () => {
            assertObject({
                from: "object | undefined",
                to: "object",
                transaction: "any | undefined",
                burnNonce: "string | number | undefined",
                contractCalls: "any[] | undefined",
                asset: "string",
                txHash: "string | undefined",
                nonce: "Buffer | string | undefined",
                tags: "string[] | undefined",
            }, { params: this.params });
            if (this.params.contractCalls) {
                this.params.contractCalls.map((contractCall) => {
                    assertType("string", {
                        sendTo: contractCall.sendTo,
                        contractFn: contractCall.contractFn,
                    });
                });
            }
        };
        /** @hidden */
        this._initialize = () => __awaiter(this, void 0, void 0, function* () {
            this._state.renNetwork =
                this._state.renNetwork ||
                    getRenNetworkDetails(yield this.renVM.getNetwork(this._state.selector));
            if (this.params.from && !this.params.from.renNetwork) {
                yield this.params.from.initialize(this._state.renNetwork);
            }
            if (!this.params.to.renNetwork) {
                yield this.params.to.initialize(this._state.renNetwork);
            }
            const burnPayload = this.params.to.burnPayload &&
                (yield this.params.to.burnPayload(this.params.from.burnPayloadConfig));
            const overwriteParams = this.params.from &&
                this.params.from.getBurnParams &&
                (yield this.params.from.getBurnParams(this.params.asset, burnPayload));
            this.params = Object.assign(Object.assign({}, overwriteParams), this.params);
            return this;
        });
        /**
         * TODO: Refresh the BurnAndRelease status by checking the status of the
         * mint-chain transaction and the RenVM transaction.
         *
         * ```ts
         * await burnAndRelease.refreshStatus();
         * // > "released"
         * ```
         */
        // eslint-disable-next-line @typescript-eslint/require-await
        this.refreshStatus = () => __awaiter(this, void 0, void 0, function* () {
            return this.status;
        });
        this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {
            if (isDefined(this._state.targetConfirmations)) {
                return this._state.targetConfirmations;
            }
            let target;
            const getConfirmationTarget = this.renVM.getConfirmationTarget;
            if (getConfirmationTarget) {
                target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {
                    return getConfirmationTarget(this._state.selector, this.params.from);
                }), 2);
            }
            this._state.targetConfirmations = isDefined(target) ? target : 6;
            return this._state.targetConfirmations;
        });
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.burn = () => {
            const promiEvent = newPromiEvent();
            (() => __awaiter(this, void 0, void 0, function* () {
                if (this.params.txHash) {
                    return this;
                }
                if (!this.params.from) {
                    throw new Error(`Must either provide field \`to\` or field \`txHash\`.`);
                }
                const { asset, transaction, burnNonce, contractCalls } = this.params;
                let findBurnError;
                try {
                    this.burnDetails = yield this.params.from.findBurn(asset, promiEvent, transaction, burnNonce);
                }
                catch (error) {
                    findBurnError = error;
                }
                if (!this.burnDetails && contractCalls) {
                    try {
                        this.burnDetails = yield this.params.from.submitBurn(asset, promiEvent, contractCalls, { networkDelay: this._state.config.networkDelay });
                    }
                    catch (error) {
                        findBurnError = findBurnError || error;
                    }
                }
                if (!this.burnDetails) {
                    throw findBurnError || new Error(`Must provide burn details.`);
                }
                this.status = BurnAndReleaseStatus.Burned;
                let confirmationTarget = 1;
                let confirmationTargetError = false;
                try {
                    confirmationTarget = yield this.confirmationTarget();
                }
                catch (error) {
                    console.error(error);
                    confirmationTargetError = true;
                }
                let currentConfirmations = 0;
                while (currentConfirmations < confirmationTarget) {
                    try {
                        let target;
                        ({ current: currentConfirmations, target } =
                            yield this.params.from.transactionConfidence(this.burnDetails.transaction));
                        if (confirmationTargetError) {
                            confirmationTarget = target;
                        }
                        // Eth based chains only emits until 24 confs;
                        // keep emitting so that we can update the UI
                        promiEvent.emit("confirmation", currentConfirmations, confirmationTarget);
                        // Exit early so that we don't have to sleep if confs are met
                        if (currentConfirmations >= confirmationTarget) {
                            break;
                        }
                    }
                    catch (error) {
                        console.error(error);
                    }
                    yield sleep(10 * SECONDS);
                }
                return this;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        /**
         * `txHash` returns the RenVM transaction hash, which is distinct from the
         * lock or mint chain transaction hashes. It can be used to query the
         * burn-and-release details from RenVM once they've been submitted to it.
         *
         * The RenVM txHash is a URL-base64 string.
         *
         * ```ts
         * burnAndRelease.txHash();
         * // > "QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI"
         * ```
         */
        this.txHash = () => {
            const txHash = this.params.txHash;
            if (txHash) {
                return renVMHashToBase64(txHash, this.renVM.version(this._state.selector) >= 2);
            }
            if (!this.params.from) {
                throw new Error(`Must either provide field \`to\` or field \`txHash\`.`);
            }
            if (!this.burnDetails) {
                throw new Error("Must call `burn` before calling `txHash`.");
            }
            if (this.renVM.version(this._state.selector) >= 2 &&
                this.renVM.burnTxHash) {
                const { transaction, amount, to, nonce } = this.burnDetails;
                const payload = Buffer.from([]);
                const pHash = generatePHash([], this._state.logger);
                const { txid, txindex } = this.params.from.transactionRPCFormat(transaction, true);
                const nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, "be", 32);
                const nHash = generateNHash(nonceBuffer, txid, txindex, this.renVM.version(this._state.selector) >= 2, this._state.logger);
                const sHash = generateSHash(`${this.params.asset}/to${this.params.to.name}`);
                const gHash = generateGHash([], Ox(this.params.to.addressToBytes(to)), Ox(sHash), nonceBuffer, this.renVM.version(this._state.selector) >= 2, this._state.logger);
                return toURLBase64(this.renVM.burnTxHash({
                    selector: this._state.selector,
                    gHash,
                    gPubKey: Buffer.from([]),
                    nHash,
                    nonce: nonceBuffer,
                    output: {
                        txid,
                        txindex,
                    },
                    // FIXME: needed until we support different asset decimals between chains
                    amount: this._state.selector === "FIL/fromSolana"
                        ? amount.multipliedBy(Math.pow(10, 9)).toFixed()
                        : amount.toFixed(),
                    payload,
                    pHash,
                    to: to.toString(),
                }));
            }
            else {
                return toBase64(generateBurnTxHash(this._state.selector, this.burnDetails.nonce.toFixed(), this._state.logger));
            }
        };
        /**
         * queryTx requests the status of the burn from RenVM.
         */
        this.queryTx = () => __awaiter(this, void 0, void 0, function* () {
            const burnTransaction = yield this.renVM.queryMintOrBurn(this._state.selector, fromBase64(this.txHash()));
            this._state.queryTxResult = burnTransaction;
            return burnTransaction;
        });
        /**
         * submit queries RenVM for the status of the burn until the funds are
         * released.
         */
        this.release = () => {
            const promiEvent = newPromiEvent();
            (() => __awaiter(this, void 0, void 0, function* () {
                if (!this.burnDetails && !this.params.txHash) {
                    throw new Error("Must call `burn` before calling `release`.");
                }
                const txHash = this.txHash();
                if (!this.params.txHash && this.burnDetails) {
                    if (!this.params.from) {
                        throw new Error(`Must either provide field \`to\` or field \`txHash\`.`);
                    }
                    if (this.params.tags && this.params.tags.length > 1) {
                        throw new Error("Providing multiple tags is not supported yet.");
                    }
                    const tags = this.params.tags && this.params.tags.length
                        ? [this.params.tags[0]]
                        : [];
                    const { transaction, amount, to, nonce } = this.burnDetails;
                    try {
                        let returnedTxHash;
                        if (this.renVM.version(this._state.selector) >= 2) {
                            assertType("string", { to });
                            const payload = Buffer.from([]);
                            const pHash = generatePHash([], this._state.logger);
                            const { txid, txindex } = this.params.from.transactionRPCFormat(transaction, true);
                            const nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, "be", 32);
                            const nHash = generateNHash(nonceBuffer, txid, txindex, this.renVM.version(this._state.selector) >= 2, this._state.logger);
                            const sHash = generateSHash(`${this.params.asset}/to${this.params.to.name}`);
                            const gHash = generateGHash([], Ox(this.params.to.addressToBytes(to)), Ox(sHash), nonceBuffer, this.renVM.version(this._state.selector) >= 2, this._state.logger);
                            returnedTxHash = toURLBase64(yield this.renVM.submitBurn({
                                selector: this._state.selector,
                                tags,
                                gHash,
                                gPubKey: Buffer.from([]),
                                nHash,
                                nonce: nonceBuffer,
                                output: {
                                    txid,
                                    txindex,
                                },
                                // FIXME: hack until we support differing decimals between burn + release chains
                                amount: this._state.selector === "FIL/fromSolana"
                                    ? amount.multipliedBy(Math.pow(10, 9)).toFixed()
                                    : amount.toFixed(),
                                payload,
                                pHash,
                                to: to.toString(),
                                // from v1
                                burnNonce: new BigNumber(0),
                            }));
                        }
                        else {
                            returnedTxHash = toBase64(yield this.renVM.submitBurn({
                                selector: this._state.selector,
                                tags,
                                burnNonce: nonce,
                                // for v2
                                gHash: Buffer.from([]),
                                gPubKey: Buffer.from([]),
                                nHash: Buffer.from([]),
                                nonce: Buffer.from([]),
                                output: { txid: Buffer.from([]), txindex: "" },
                                amount: "",
                                payload: Buffer.from([]),
                                pHash: Buffer.from([]),
                                to: "",
                            }));
                        }
                        if (txHash && txHash !== returnedTxHash) {
                            this._state.logger.warn(`Unexpected txHash returned from RenVM. Received: ${returnedTxHash}, expected: ${txHash}`);
                        }
                    }
                    catch (error) {
                        // TODO: Check against already being submitted.
                        throw error;
                    }
                }
                // const txHash = await this.renVMNetwork.submitTokenFromEthereum(this.params.sendToken, burnNonce);
                promiEvent.emit("txHash", txHash);
                this._state.logger.debug("txHash:", txHash);
                const response = yield this.renVM.waitForTX(this._state.selector, fromBase64(txHash), (status) => {
                    promiEvent.emit("status", status);
                    this._state.logger.debug("transaction status:", status);
                }, () => promiEvent._isCancelled(), this._state.config.networkDelay);
                if (response.out && response.out.revert !== undefined) {
                    this.status = BurnAndReleaseStatus.Reverted;
                    this.revertReason = response.out.revert.toString();
                    throw new Error(this.revertReason);
                }
                else {
                    this.status = BurnAndReleaseStatus.Released;
                    if (response.out &&
                        this.renVM.version(this._state.selector) >= 2) {
                        let transaction;
                        try {
                            if (response.out.txid) {
                                const txid = response.out.txid;
                                transaction =
                                    yield this.params.to.transactionFromRPCFormat(txid, "", true);
                            }
                            else if (response.out.outpoint) {
                                const { hash, index } = response.out.outpoint;
                                transaction =
                                    yield this.params.to.transactionFromRPCFormat(hash, index.toFixed(), true);
                            }
                        }
                        catch (error) {
                            this._state.logger.debug(error);
                        }
                        if (transaction) {
                            this.releaseTransaction = transaction;
                            promiEvent.emit("transaction", transaction);
                        }
                    }
                }
                return response;
            }))()
                .then(promiEvent.resolve)
                .catch(promiEvent.reject);
            return promiEvent;
        };
        this.params = params;
        this.renVM = renVM;
        this._state = {
            logger: config.logger || NullLogger,
            selector: this.renVM.selector(this.params),
            targetConfirmations: undefined,
            config: Object.assign(Object.assign({}, config), { networkDelay: config.networkDelay || 15 * SECONDS }),
        };
        this.validateParams();
        this.status = this.params.txHash
            ? BurnAndReleaseStatus.Burned
            : BurnAndReleaseStatus.Pending;
        {
            // Debug log
            const restOfParams = __rest(this.params, []);
            this._state.logger.debug("burnAndRelease created:", restOfParams);
        }
    }
}
//# sourceMappingURL=burnAndRelease.js.map