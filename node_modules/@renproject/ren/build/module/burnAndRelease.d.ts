import { BurnAndReleaseParams, BurnAndReleaseTransaction, BurnDetails, DepositCommon, Logger, PromiEvent, RenNetworkDetails, TxStatus } from "@renproject/interfaces";
import { AbstractRenVMProvider } from "@renproject/rpc";
import { RenJSConfig } from "./config";
export declare enum BurnAndReleaseStatus {
    Pending = "pending",
    Burned = "burned",
    Released = "released",
    Reverted = "reverted"
}
export declare class BurnAndRelease<LockTransaction = any, LockDeposit extends DepositCommon<LockTransaction> = DepositCommon<LockTransaction>, LockAddress extends string | {
    address: string;
} = any, MintTransaction = any, MintAddress extends string | {
    address: string;
} = any> {
    /** The details of the burn, including the amount and recipient. */
    burnDetails: BurnDetails<MintTransaction> | undefined;
    /** The parameters passed in when calling [[RenJS.burnAndRelease]]. */
    params: BurnAndReleaseParams<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>;
    /**
     * The status of the burn, updated automatically.
     *
     * ```ts
     * burnAndRelease.status;
     * // > "released"
     * ```
     */
    status: BurnAndReleaseStatus;
    /** See [[RenJS.renVM]]. */
    readonly renVM: AbstractRenVMProvider;
    /**
     * Internal state of the burn object. Interface may change across minor and
     * patch releases.
     */
    readonly _state: {
        targetConfirmations: number | undefined;
        logger: Logger;
        queryTxResult?: BurnAndReleaseTransaction;
        renNetwork?: RenNetworkDetails;
        selector: string;
        config: RenJSConfig & {
            networkDelay: number;
        };
    };
    revertReason?: string;
    releaseTransaction?: LockTransaction;
    /** @hidden */
    constructor(renVM: AbstractRenVMProvider, params: BurnAndReleaseParams<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>, config?: RenJSConfig);
    private readonly validateParams;
    /** @hidden */
    readonly _initialize: () => Promise<this>;
    /**
     * TODO: Refresh the BurnAndRelease status by checking the status of the
     * mint-chain transaction and the RenVM transaction.
     *
     * ```ts
     * await burnAndRelease.refreshStatus();
     * // > "released"
     * ```
     */
    refreshStatus: () => Promise<BurnAndReleaseStatus>;
    confirmationTarget: () => Promise<number>;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    burn: () => PromiEvent<BurnAndRelease<LockTransaction, LockDeposit, LockAddress, MintTransaction, MintAddress>, {
        transactionHash: [string];
        confirmation: [number, number];
    }>;
    /**
     * `txHash` returns the RenVM transaction hash, which is distinct from the
     * lock or mint chain transaction hashes. It can be used to query the
     * burn-and-release details from RenVM once they've been submitted to it.
     *
     * The RenVM txHash is a URL-base64 string.
     *
     * ```ts
     * burnAndRelease.txHash();
     * // > "QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI"
     * ```
     */
    txHash: () => string;
    /**
     * queryTx requests the status of the burn from RenVM.
     */
    queryTx: () => Promise<BurnAndReleaseTransaction>;
    /**
     * submit queries RenVM for the status of the burn until the funds are
     * released.
     */
    release: () => PromiEvent<BurnAndReleaseTransaction, {
        txHash: [string];
        status: [TxStatus];
        transaction: [LockTransaction];
    }>;
}
