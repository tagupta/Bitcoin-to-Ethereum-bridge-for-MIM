"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultDepositHandler = void 0;
const utils_1 = require("@renproject/utils");
const lockAndMint_1 = require("./lockAndMint");
/**
 * See [[RenJS.defaultDepositHandler]].
 */
const createDepositHandler = (retries = -1) => {
    const fn = async (deposit) => {
        // Loop until the deposit status is `Submitted`.
        while (deposit.status !== lockAndMint_1.DepositStatus.Submitted) {
            switch (deposit.status) {
                // The deposit has been seen, but not enough confirmations have
                // passed yet.
                case lockAndMint_1.DepositStatus.Detected:
                    await utils_1.retryNTimes(async () => {
                        deposit._state.logger.log(`Calling .confirmed`);
                        await deposit
                            .confirmed()
                            .on("target", (target) => {
                            deposit._state.logger.log(`Waiting for ${target} confirmations`);
                        })
                            .on("confirmation", (confs, target) => {
                            deposit._state.logger.log(`${confs}/${target} confirmations`);
                        });
                    }, retries, 10 * utils_1.SECONDS, deposit._state.logger);
                    break;
                // The deposit as been seen and confirmed, but it hasn't been
                // signed by RenVM yet.
                case lockAndMint_1.DepositStatus.Confirmed:
                    await utils_1.retryNTimes(async () => {
                        try {
                            deposit._state.logger.log(`Calling .signed`);
                            await deposit
                                .signed()
                                .on("txHash", (status) => {
                                deposit._state.logger.log(`RenVM hash: ${status}`);
                            })
                                .on("status", (status) => {
                                deposit._state.logger.log(`status: ${status}`);
                            });
                        }
                        catch (error) {
                            if (deposit.status === lockAndMint_1.DepositStatus.Reverted) {
                                return;
                            }
                            throw error;
                        }
                    }, retries, 10 * utils_1.SECONDS, deposit._state.logger);
                    break;
                // The mint has been signed by RenVM and can be submitted to
                // the mint-chain.
                case lockAndMint_1.DepositStatus.Signed:
                    await utils_1.retryNTimes(async () => {
                        try {
                            deposit._state.logger.log(`Calling .mint`);
                            await deposit
                                .mint()
                                .on("transactionHash", (txHash) => {
                                deposit._state.logger.log(`txHash: ${deposit.params.to.utils
                                    .transactionExplorerLink
                                    ? deposit.params.to.utils.transactionExplorerLink(txHash) || String(txHash)
                                    : String(txHash)}`);
                            });
                        }
                        catch (error) {
                            // Ethereum revert message.
                            if (/(execution reverted)|(Transaction has been reverted)/.exec(error.message || String(error))) {
                                deposit.status = lockAndMint_1.DepositStatus.Reverted;
                                deposit.revertReason =
                                    error.message || String(error);
                                return;
                            }
                            throw error;
                        }
                    }, retries, 10 * utils_1.SECONDS, deposit._state.logger);
                    break;
                // RenVM wasn't able to sign the mint. Potential causes can be
                // found in `deposit.revertReason`.
                case lockAndMint_1.DepositStatus.Reverted:
                    throw new Error(`RenVM transaction reverted${deposit.revertReason
                        ? ": " + deposit.revertReason
                        : ""}`);
            }
        }
    };
    fn.withRetries = (newRetries) => createDepositHandler(newRetries);
    return fn;
};
/**
 * See [[RenJS.defaultDepositHandler]].
 */
exports.defaultDepositHandler = createDepositHandler();
//# sourceMappingURL=defaultDepositHandler.js.map