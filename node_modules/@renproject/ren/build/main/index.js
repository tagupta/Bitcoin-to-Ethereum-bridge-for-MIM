"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockAndMintDeposit = exports.DepositStatus = exports.LockAndMint = exports.BurnAndRelease = void 0;
const interfaces_1 = require("@renproject/interfaces");
const rpc_1 = require("@renproject/rpc");
const v2_1 = require("@renproject/rpc/build/main/v2");
const utils_1 = require("@renproject/utils");
const burnAndRelease_1 = require("./burnAndRelease");
const defaultDepositHandler_1 = require("./defaultDepositHandler");
const lockAndMint_1 = require("./lockAndMint");
var burnAndRelease_2 = require("./burnAndRelease");
Object.defineProperty(exports, "BurnAndRelease", { enumerable: true, get: function () { return burnAndRelease_2.BurnAndRelease; } });
var lockAndMint_2 = require("./lockAndMint");
Object.defineProperty(exports, "LockAndMint", { enumerable: true, get: function () { return lockAndMint_2.LockAndMint; } });
Object.defineProperty(exports, "DepositStatus", { enumerable: true, get: function () { return lockAndMint_2.DepositStatus; } });
Object.defineProperty(exports, "LockAndMintDeposit", { enumerable: true, get: function () { return lockAndMint_2.LockAndMintDeposit; } });
/**
 * This is the main exported class from `@renproject/ren`.
 *
 * ```typescript
 * import RenJS from "@renproject/ren";
 * ```
 *
 * By default, RenJS will connect to the RenVM mainnet network. To connect
 * to `testnet` or to configure a custom connection, RenJS takes an optional
 * provider object. See the [[constructor]] for more details.
 *
 * ```typescript
 * new RenJS(); // Same as `new RenJS("mainnet");`
 * new RenJS("testnet");
 * new RenJS(custom provider object);
 * ```
 *
 * It then exposes two main functions:
 * 1. [[lockAndMint]] - for transferring assets to Ethereum.
 * 2. [[burnAndRelease]] - for transferring assets out of Ethereum.
 *
 * Also see:
 * 1. [[getFees]] - for estimating the fees that will be incurred by minting or
 * burning.
 * 2. [[defaultDepositHandler]]
 *
 */
class RenJS {
    /**
     * Accepts the name of a network, or a network object.
     *
     * @param network Provide the name of a network - `"mainnet"` or `"testnet"` - or a network object.
     * @param providerOrConfig Provide a custom RPC provider, or provide RenJS configuration settings.
     */
    constructor(providerOrNetwork, config) {
        // const provider: string | Provider | undefined;
        // let config: RenJSConfig | undefined;
        // if (
        //     providerOrConfig &&
        //     (typeof providerOrConfig === "string" ||
        //         (providerOrConfig as Provider).sendMessage)
        // ) {
        //     provider = providerOrConfig as string | Provider;
        // } else if (providerOrConfig) {
        //     config = providerOrConfig as RenJSConfig;
        // }
        /**
         * @hidden
         */
        this.utils = RenJS.utils;
        this.getFees = async ({ asset, from, to, }) => {
            if (!(await from.assetIsSupported(asset))) {
                throw new Error(`Asset not supported by chain ${from.name}.`);
            }
            if (!(await to.assetIsSupported(asset))) {
                throw new Error(`Asset not supported by chain ${to.name}.`);
            }
            if (await from.assetIsNative(asset)) {
                // LockAndMint
                return await this.renVM.estimateTransactionFee(asset, from, to);
            }
            else if (await to.assetIsNative(asset)) {
                // BurnAndRelease
                return await this.renVM.estimateTransactionFee(asset, to, from);
            }
            else {
                // BurnAndMint
                return await this.renVM.estimateTransactionFee(asset, from, to);
            }
        };
        /**
         * `lockAndMint` initiates the process of bridging an asset from its native
         * chain to a host chain.
         *
         * See [[LockAndMintParams]] for all the options that can be set.
         *
         * Returns a [[LockAndMint]] object.
         *
         * Example initialization:
         *
         * ```js
         * const lockAndMint = renJS.lockAndMint({
         *     asset: "BTC",
         *     from: Bitcoin(),
         *     to: Ethereum(web3Provider).Account({
         *         address: "0x...",
         *     }),
         * });
         * ```
         *
         * @param params See [[LockAndMintParams]].
         */
        this.lockAndMint = async (params, config) => new lockAndMint_1.LockAndMint(this.renVM, params, Object.assign(Object.assign({}, this._config), config))._initialize();
        /**
         * `burnAndRelease` submits a burn log to RenVM.
         * Returns a [[BurnAndRelease]] object.
         */
        this.burnAndRelease = async (params, config) => new burnAndRelease_1.BurnAndRelease(this.renVM, params, Object.assign(Object.assign({}, this._config), config))._initialize();
        this._config = config || {};
        this._logger =
            (config && config.logger) ||
                new interfaces_1.SimpleLogger((config && config.logLevel) || interfaces_1.LogLevel.Error);
        this._config.logger = this._logger;
        const defaultProvider = () => config && config.useV2TransactionFormat
            ? new v2_1.RenVMProvider(
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            (providerOrNetwork || interfaces_1.RenNetwork.Mainnet), undefined, this._logger)
            : new rpc_1.CombinedProvider(
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            (providerOrNetwork || interfaces_1.RenNetwork.Mainnet), this._logger);
        // Use provided provider, provider URL or default lightnode URL.
        this.renVM =
            providerOrNetwork &&
                typeof providerOrNetwork !== "string" &&
                providerOrNetwork.sendMessage
                ? providerOrNetwork
                : defaultProvider();
    }
}
exports.default = RenJS;
// /**
//  * [STATIC] `Tokens` exposes the tokens that can be passed in to the lockAndMint and
//  * burnAndRelease methods.
//  */
// public static Tokens = Tokens;
/**
 * `Networks` exposes the network options that can be passed in to the RenJS
 * constructor. `Networks.Mainnet` resolves to the string `"mainnet"`.
 */
RenJS.Networks = interfaces_1.RenNetwork;
/**
 * A collection of helper functions. [[utils.randomNonce]] can be be used to
 * generate a nonce when calling [[RenJS.lockAndMint]].
 */
RenJS.utils = {
    randomNonce: utils_1.randomNonce,
    toSmallestUnit: utils_1.toSmallestUnit,
    fromSmallestUnit: utils_1.fromSmallestUnit,
    fromAscii: (str) => Buffer.from(str),
};
/**
 * `RenJS.defaultDepositHandler` can be passed as a deposit callback when
 * minting. It will handle submitting to RenVM and then to the mint-chain,
 * as long as a valid provider for the mint-chain is given.
 *
 * This is not recommended for front-ends, since it may trigger a wallet
 * pop-up unexpectedly when the mint is ready to be submitted.
 *
 * ```ts
 * lockAndMint.on("deposit", RenJS.defaultDepositHandler);
 * ```
 */
RenJS.defaultDepositHandler = defaultDepositHandler_1.defaultDepositHandler;
// ////////////////////////////////////////////////////////////////////////// //
// EXPORTS                                                                    //
// Based on https://github.com/MikeMcl/bignumber.js/blob/master/bignumber.js  //
// ////////////////////////////////////////////////////////////////////////// //
/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-explicit-any */
RenJS.default = RenJS.RenJS = RenJS;
RenJS.LockAndMint = lockAndMint_1.LockAndMint;
RenJS.BurnAndRelease = burnAndRelease_1.BurnAndRelease;
RenJS.DepositStatus = lockAndMint_1.DepositStatus;
RenJS.LockAndMintDeposit = lockAndMint_1.LockAndMintDeposit;
// AMD
try {
    // @ts-ignore
    if (typeof define === "function" && define.amd) {
        // @ts-ignore
        define(() => RenJS);
    }
}
catch (error) {
    /* ignore */
}
// Node.js and other environments that support module.exports.
try {
    // @ts-ignore
    if (typeof module !== "undefined" && module.exports) {
        module.exports = RenJS;
    }
}
catch (error) {
    /* ignore */
}
// Browser.
try {
    // @ts-ignore
    if (typeof window !== "undefined" && window) {
        window.RenJS = RenJS;
    }
}
catch (error) {
    /* ignore */
}
//# sourceMappingURL=index.js.map