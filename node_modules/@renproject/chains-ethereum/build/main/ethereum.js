"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ethereum = exports.EthereumClass = void 0;
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const base_1 = require("./base");
class EthereumClass extends base_1.EthereumBaseChain {
    constructor(web3Provider, renNetwork, config = {}) {
        super(web3Provider, renNetwork, config);
        this.getMintParams = (asset) => this._getParams ? this._getParams(asset) : undefined;
        this.getBurnParams = (asset, burnPayload) => this._getParams ? this._getParams(asset, burnPayload) : undefined;
        /** @category Main */
        this.Address = (address, txConfig) => this.Account({ address }, txConfig);
        /** @category Main */
        this.Account = ({ value, address, }, txConfig) => {
            this._getParams = async (asset, burnPayload) => {
                if (!this.renNetworkDetails || !this.provider) {
                    throw new Error(`Ethereum must be initialized before calling 'getContractCalls'.`);
                }
                if (!value) {
                    // Mint
                    if (!address) {
                        throw new Error(`Must provide Ethereum recipient address.`);
                    }
                    // // Resolve .ens name
                    // if (/.*\.ens/.exec(address)) {
                    //     address = await this.provider.eth.ens.getAddress(address);
                    // }
                    return {
                        contractCalls: [
                            {
                                sendTo: this.renNetworkDetails.addresses
                                    .BasicAdapter,
                                contractFn: "mint",
                                contractParams: [
                                    {
                                        type: "string",
                                        name: "_symbol",
                                        value: asset,
                                    },
                                    {
                                        type: "address",
                                        name: "_address",
                                        value: address,
                                    },
                                ],
                                txConfig,
                            },
                        ],
                    };
                }
                else {
                    // Burn
                    if (!value) {
                        throw new Error(`Send amount must be provided in order to send directly to an address.`);
                    }
                    if (!burnPayload) {
                        throw new Error(`Must provide burn recipient address`);
                    }
                    const addressToBuffer = Buffer.from(burnPayload);
                    const gateway = await this.getGatewayContractAddress(asset);
                    return {
                        contractCalls: [
                            {
                                sendTo: gateway,
                                contractFn: "burn",
                                contractParams: [
                                    {
                                        type: "bytes",
                                        name: "_to",
                                        value: utils_1.Ox(addressToBuffer),
                                    },
                                    {
                                        type: "uint256",
                                        name: "_amount",
                                        value: new bignumber_js_1.default(value).toFixed(),
                                    },
                                ],
                                txConfig,
                            },
                        ],
                    };
                }
            };
            return this;
        };
        /** @category Main */
        this.Contract = (contractCall) => {
            this._getParams = (asset, burnPayload) => {
                if (!this.renNetworkDetails) {
                    throw new Error(`Ethereum must be initialized before calling 'getContractCalls'`);
                }
                if (typeof contractCall === "function") {
                    if (!burnPayload) {
                        throw new Error(`Must provide burn payload`);
                    }
                    const addressToBuffer = Buffer.from(burnPayload);
                    return {
                        contractCalls: [contractCall(utils_1.Ox(addressToBuffer), asset)],
                    };
                }
                else {
                    return { contractCalls: [contractCall] };
                }
            };
            return this;
        };
        /** @category Main */
        this.Transaction = (transaction) => {
            this._getParams = (_asset, _burnPayload) => {
                return {
                    transaction,
                };
            };
            return this;
        };
        /** @category Main */
        this.BurnNonce = (burnNonce) => {
            this._getParams = (_asset, _burnPayload) => {
                return {
                    burnNonce,
                };
            };
            return this;
        };
        this.toWei = (value) => new bignumber_js_1.default(value)
            .times(new bignumber_js_1.default(10).exponentiatedBy(18))
            .decimalPlaces(0)
            .toFixed();
        this.fromWei = (value) => new bignumber_js_1.default(value)
            .dividedBy(new bignumber_js_1.default(10).exponentiatedBy(18))
            .toFixed();
    }
}
exports.EthereumClass = EthereumClass;
// @dev Removes any static fields, except `utils`.
exports.Ethereum = utils_1.Callable(EthereumClass);
//# sourceMappingURL=ethereum.js.map