"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transactionIsValid = exports.addressIsValid = exports.submitToEthereum = exports.findMintBySigHash = exports.getTokenAddress = exports.findBurnByNonce = exports.getGatewayAddress = exports.extractBurnDetails = exports.parseBurnEvent = exports.waitForReceipt = exports.eventTopics = void 0;
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bn_js_1 = __importDefault(require("bn.js"));
const ethers = __importStar(require("ethers"));
const EMPTY_ADDRESS = "0x" + "00".repeat(20);
/**
 * eventTopics contains the Ethereum event identifiers (the first log topic) for
 * Gateway contract events.
 */
exports.eventTopics = {
    /**
     * ```js
     * event LogBurn(
     *     bytes _to,
     *     uint256 _amount,
     *     uint256 indexed _n,
     *     bytes indexed _indexedTo
     *  );
     * ```
     */
    LogBurn: utils_1.Ox(utils_1.keccak256(Buffer.from("LogBurn(bytes,uint256,uint256,bytes)"))),
    /**
     * ```js
     * event LogMint(
     *     address indexed _to,
     *     uint256 _amount,
     *     uint256 indexed _n,
     *     bytes32 indexed _signedMessageHash
     * );
     * ```
     */
    LogMint: utils_1.Ox(utils_1.keccak256(Buffer.from("LogMint(address,uint256,uint256,bytes32)"))),
};
/**
 * Waits for the receipt of a transaction to be available, retrying every 3
 * seconds until it is.
 *
 * @param web3 A web3 instance.
 * @param txHash The hash of the transaction being read.
 */
const waitForReceipt = async (provider, txHash, logger, timeout) => 
// eslint-disable-next-line @typescript-eslint/no-misused-promises
new Promise(async (resolve, reject) => {
    utils_1.assertType("string", { txHash });
    // Wait for confirmation
    let receipt;
    while (!receipt || !receipt.blockHash) {
        if (logger) {
            logger.debug(`Fetching transaction receipt: ${txHash}`);
        }
        receipt = await provider.getTransactionReceipt(txHash);
        if (receipt && receipt.blockHash) {
            break;
        }
        await utils_1.sleep(utils_1.isDefined(timeout) ? timeout : 15 * utils_1.SECONDS);
    }
    // Status might be undefined - so check against `false` explicitly.
    if (receipt.status === 0) {
        reject(new Error(`Transaction was reverted. { "transactionHash": "${txHash}" }`));
        return;
    }
    resolve(receipt);
    return;
});
exports.waitForReceipt = waitForReceipt;
const parseBurnEvent = (event) => {
    utils_1.assert(event.topics[0] === exports.eventTopics.LogBurn);
    const burnLogABI = {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bytes",
                name: "_to",
                type: "bytes",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "_amount",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "_n",
                type: "uint256",
            },
            {
                indexed: true,
                internalType: "bytes",
                name: "_indexedTo",
                type: "bytes",
            },
        ],
        name: "LogBurn",
        type: "event",
    };
    const burnLogDecoder = new ethers.utils.Interface([burnLogABI]);
    const decodedLog = burnLogDecoder.parseLog(event);
    const [_to, _amount, _n] = decodedLog.args;
    return {
        transaction: event.transactionHash,
        amount: new bignumber_js_1.default(_amount.toString()),
        to: utils_1.fromHex(_to).toString(),
        nonce: new bignumber_js_1.default(_n.toString()),
    };
};
exports.parseBurnEvent = parseBurnEvent;
const extractBurnDetails = async (provider, txHash, logger, timeout) => {
    utils_1.assertType("string", { txHash });
    const receipt = await exports.waitForReceipt(provider, txHash, logger, timeout);
    if (!receipt.logs) {
        throw Error("No events found in transaction");
    }
    const burnDetails = receipt.logs
        .filter((event) => event.topics[0] === exports.eventTopics.LogBurn)
        .map((event) => exports.parseBurnEvent(event));
    if (burnDetails.length > 1) {
        // WARNING: More than one burn found.
    }
    if (burnDetails.length) {
        return burnDetails[0];
    }
    throw Error("No reference ID found in logs");
};
exports.extractBurnDetails = extractBurnDetails;
const getGatewayAddress = async (network, provider, asset) => {
    try {
        const getGatewayBySymbol = {
            constant: true,
            inputs: [
                {
                    internalType: "string",
                    name: "_tokenSymbol",
                    type: "string",
                },
            ],
            name: "getGatewayBySymbol",
            outputs: [
                {
                    internalType: "contract IGateway",
                    name: "",
                    type: "address",
                },
            ],
            payable: false,
            stateMutability: "view",
            type: "function",
        };
        const registry = new ethers.Contract(network.addresses.GatewayRegistry, [getGatewayBySymbol], provider);
        // const registry = new web3.eth.Contract(
        //     [getGatewayBySymbol],
        //     network.addresses.GatewayRegistry,
        // );
        const registryAddress = utils_1.Ox(await registry.getGatewayBySymbol(asset));
        if (!registryAddress || registryAddress === EMPTY_ADDRESS) {
            throw new Error(`Empty address returned.`);
        }
        return registryAddress;
    }
    catch (error) {
        (error || {}).message = `Error looking up ${asset} gateway address${error.message ? `: ${String(error.message)}` : "."}`;
        throw error;
    }
};
exports.getGatewayAddress = getGatewayAddress;
const findBurnByNonce = async (network, provider, asset, nonce) => {
    const gatewayAddress = await exports.getGatewayAddress(network, provider, asset);
    const nonceBuffer = Buffer.isBuffer(nonce)
        ? Buffer.from(nonce)
        : new bn_js_1.default(nonce).toArrayLike(Buffer, "be", 32);
    const burnEvents = await provider.getLogs({
        address: gatewayAddress,
        fromBlock: "1",
        toBlock: "latest",
        topics: [exports.eventTopics.LogBurn, utils_1.Ox(nonceBuffer)],
    });
    if (!burnEvents.length) {
        throw Error(`Burn not found for nonce ${utils_1.Ox(nonceBuffer)}`);
    }
    if (burnEvents.length > 1) {
        // WARNING: More than one burn with the same nonce.
    }
    return exports.parseBurnEvent(burnEvents[0]);
};
exports.findBurnByNonce = findBurnByNonce;
const getTokenAddress = async (network, provider, asset) => {
    try {
        const getTokenBySymbolABI = {
            constant: true,
            inputs: [
                {
                    internalType: "string",
                    name: "_tokenSymbol",
                    type: "string",
                },
            ],
            name: "getTokenBySymbol",
            outputs: [
                {
                    internalType: "contract IERC20",
                    name: "",
                    type: "address",
                },
            ],
            payable: false,
            stateMutability: "view",
            type: "function",
        };
        const registry = new ethers.Contract(network.addresses.GatewayRegistry, [getTokenBySymbolABI], provider);
        const tokenAddress = utils_1.Ox(await registry.getTokenBySymbol(asset));
        if (!tokenAddress || tokenAddress === EMPTY_ADDRESS) {
            throw new Error(`Empty address returned.`);
        }
        return tokenAddress;
    }
    catch (error) {
        (error || {}).message = `Error looking up ${asset} token address on ${network.chainLabel}${error.message ? `: ${String(error.message)}` : "."}`;
        throw error;
    }
};
exports.getTokenAddress = getTokenAddress;
const findMintBySigHash = async (network, provider, asset, nHash, sigHash, blockLimit) => {
    let status;
    try {
        const gatewayAddress = await exports.getGatewayAddress(network, provider, asset);
        const statusABI = {
            constant: true,
            inputs: [
                {
                    internalType: "bytes32",
                    name: "",
                    type: "bytes32",
                },
            ],
            name: "status",
            outputs: [
                {
                    internalType: "bool",
                    name: "",
                    type: "bool",
                },
            ],
            payable: false,
            stateMutability: "view",
            type: "function",
        };
        const gatewayContract = new ethers.Contract(gatewayAddress, [statusABI], provider);
        let fromBlock = 1;
        let toBlock = "latest";
        if (blockLimit) {
            toBlock = new bignumber_js_1.default((await provider.getBlockNumber()).toString()).toNumber();
            fromBlock = toBlock - blockLimit + 1;
        }
        const newMintEvents = await provider.getLogs({
            address: gatewayAddress,
            fromBlock,
            toBlock,
            topics: [exports.eventTopics.LogMint, null, null, utils_1.Ox(nHash)],
        });
        if (newMintEvents.length) {
            return newMintEvents[0].transactionHash;
        }
        if (sigHash) {
            // We can skip the `status` check and call `getPastLogs` directly - for now both are called in case
            // the contract
            status = await gatewayContract.status(utils_1.Ox(sigHash));
            if (!status) {
                return undefined;
            }
            const oldMintEvents = await provider.getLogs({
                address: gatewayAddress,
                fromBlock,
                toBlock,
                topics: [
                    exports.eventTopics.LogMint,
                    null,
                    null,
                    utils_1.Ox(sigHash),
                ],
            });
            if (oldMintEvents.length) {
                return oldMintEvents[0].transactionHash;
            }
        }
    }
    catch (error) {
        console.warn(error);
        // Continue with transaction
    }
    if (status) {
        // The sigHash has already been used, but no transaction was found.
        // Possible due to a restriction on the number logs that can be fetched,
        // which is the case on BSC.
        return "";
    }
    return;
};
exports.findMintBySigHash = findMintBySigHash;
const submitToEthereum = async (signer, contractCalls, mintTx, eventEmitter, 
// config?: { [key: string]: unknown },
logger = interfaces_1.NullLogger) => {
    if (!mintTx.out) {
        throw new Error(`No result available from RenVM transaction.`);
    }
    if (mintTx.out.revert !== undefined) {
        throw new Error(`Unable to submit reverted RenVM transaction.`);
    }
    if (!mintTx.out.signature) {
        throw new Error(`No signature available from RenVM transaction.`);
    }
    let transaction;
    for (let i = 0; i < contractCalls.length; i++) {
        const contractCall = contractCalls[i];
        const last = i === contractCalls.length - 1;
        const { contractParams, contractFn, sendTo } = contractCall;
        const callParams = last
            ? [
                ...(contractParams || []).map((value) => value.value),
                utils_1.Ox(new bignumber_js_1.default(mintTx.out.amount).toString(16)),
                utils_1.Ox(mintTx.out.nhash),
                utils_1.Ox(mintTx.out.signature), // _sig: string
            ]
            : (contractParams || []).map((value) => value.value);
        const ABI = last
            ? utils_1.payloadToMintABI(contractFn, contractParams || [])
            : utils_1.payloadToABI(contractFn, contractParams || []);
        const contract = new ethers.Contract(sendTo, ABI, signer);
        const txConfig = typeof contractCall === "object"
            ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                contractCall.txConfig
            : {};
        const config = Object.assign(Object.assign({}, txConfig), {
            value: txConfig && txConfig.value
                ? txConfig.value.toString()
                : undefined,
            gasPrice: txConfig && txConfig.gasPrice
                ? txConfig.gasPrice.toString()
                : undefined,
        });
        logger.debug("Calling Ethereum contract", contractFn, sendTo, ...callParams, config);
        const tx = await contract[contractFn](...callParams, config);
        if (last) {
            eventEmitter.emit("transactionHash", tx.hash);
        }
        const receipt = await tx.wait();
        if (last) {
            eventEmitter.emit("confirmation", 1, { status: 1 });
        }
        transaction = receipt.transactionHash;
        if (logger) {
            logger.debug("Transaction hash", transaction);
        }
    }
    if (transaction === undefined) {
        throw new Error(`Must provide contract call.`);
    }
    return transaction;
};
exports.submitToEthereum = submitToEthereum;
const addressIsValid = (address) => {
    if (/^.+\.eth$/.exec(address)) {
        return true;
    }
    try {
        ethers.utils.getAddress(address);
        return true;
    }
    catch (_error) {
        return false;
    }
};
exports.addressIsValid = addressIsValid;
const transactionIsValid = (transaction) => transaction !== null && utils_1.isHex(transaction, { length: 32, prefix: true });
exports.transactionIsValid = transactionIsValid;
//# sourceMappingURL=utils.js.map