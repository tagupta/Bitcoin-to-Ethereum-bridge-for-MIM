/// <reference types="node" />
import { BurnDetails, ContractCall, LockAndMintTransaction, Logger, MintChain, RenNetwork, RenNetworkDetails, RenNetworkString, EventEmitterTyped } from "@renproject/interfaces";
import BigNumber from "bignumber.js";
import * as ethers from "ethers";
import { Web3Provider } from "@ethersproject/providers";
import { EthereumConfig } from "./networks";
import { EthAddress, EthProvider, EthTransaction } from "./types";
export declare const EthereumConfigMap: {
    mainnet: EthereumConfig;
    testnet: EthereumConfig;
    devnet: EthereumConfig;
};
export declare type NetworkInput = RenNetwork | RenNetworkString | RenNetworkDetails | EthereumConfig;
export declare class EthereumBaseChain implements MintChain<EthTransaction, EthAddress, EthereumConfig> {
    static chain: string;
    chain: string;
    name: string;
    legacyName: MintChain["legacyName"];
    logRequestLimit: number | undefined;
    private logger;
    static configMap: {
        [network in RenNetwork]?: EthereumConfig;
    };
    configMap: {
        [network in RenNetwork]?: EthereumConfig;
    };
    static utils: {
        resolveChainNetwork: (renNetwork?: RenNetworkDetails | RenNetwork | RenNetworkString | EthereumConfig | undefined) => EthereumConfig;
        addressIsValid: (address: string) => boolean;
        transactionIsValid: (transaction: EthTransaction) => boolean;
        addressExplorerLink: (address: EthAddress, network?: NetworkInput | undefined) => string;
        transactionExplorerLink: (transaction: EthTransaction, network?: NetworkInput | undefined) => string;
    };
    utils: {
        resolveChainNetwork: (renNetwork?: RenNetworkDetails | RenNetwork | RenNetworkString | EthereumConfig | undefined) => EthereumConfig;
        addressIsValid: (address: string) => boolean;
        transactionIsValid: (transaction: EthTransaction) => boolean;
        addressExplorerLink: (address: EthAddress, network?: NetworkInput | undefined) => string;
        transactionExplorerLink: (transaction: EthTransaction, network?: NetworkInput | undefined) => string;
    } & {
        addressIsValid: (address: string, network?: "mainnet" | "testnet" | EthereumConfig | undefined) => boolean;
        addressExplorerLink: ((address: any, network?: "mainnet" | "testnet" | EthereumConfig | undefined) => string | undefined) | undefined;
        transactionExplorerLink: ((tx: any, network?: "mainnet" | "testnet" | EthereumConfig | undefined) => string | undefined) | undefined;
    };
    provider: Web3Provider | undefined;
    signer: ethers.Signer | undefined;
    renNetworkDetails: EthereumConfig | undefined;
    readonly getTokenContractAddress: (asset: string) => Promise<string>;
    readonly getGatewayContractAddress: (token: string) => Promise<string>;
    constructor(web3Provider: EthProvider, renNetwork?: RenNetwork | RenNetworkString | RenNetworkDetails | EthereumConfig, config?: {
        logger?: Logger;
    });
    withProvider: (web3Provider: EthProvider) => this;
    /**
     * See [LockChain.initialize].
     */
    initialize: (renNetwork: RenNetwork | RenNetworkString | RenNetworkDetails) => this;
    assetIsNative: (asset: string) => boolean;
    /**
     * `assetIsSupported` should return true if the asset is native to the
     * MintChain.
     *
     * ```ts
     * ethereum.assetIsSupported = asset => asset === "ETH";
     * ```
     */
    assetIsSupported: (asset: string) => Promise<boolean>;
    /**
     * `assetDecimals` should return the number of decimals of the asset.
     *
     * If the asset is not supported, an error should be thrown.
     *
     
     */
    assetDecimals: (asset: string) => Promise<number>;
    transactionID: (transaction: EthTransaction) => string;
    transactionIDFromRPCFormat: (txid: string | Buffer, txindex: string) => string;
    transactionFromRPCFormat: (txid: string | Buffer, _txindex: string) => string;
    /**
     * @deprecated Renamed to `transactionFromRPCFormat`.
     * Will be removed in 3.0.0.
     */
    transactionFromID: (txid: string | Buffer, _txindex: string) => string;
    transactionConfidence: (transaction: EthTransaction) => Promise<{
        current: number;
        target: number;
    }>;
    submitMint: (asset: string, contractCalls: ContractCall[], mintTx: LockAndMintTransaction, eventEmitter: EventEmitterTyped<{
        transactionHash: [string];
        confirmation: [number, {
            status: number;
        }];
    }>) => Promise<EthTransaction>;
    findMint: (asset: string, nHash: Buffer, sigHash?: Buffer | undefined) => Promise<EthTransaction | undefined>;
    resolveTokenGatewayContract: (asset: string) => Promise<string>;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    submitBurn: (_asset: string, eventEmitter: EventEmitterTyped<{
        transactionHash: [string];
    }>, contractCalls: ContractCall[], config?: {
        networkDelay?: number;
    }) => Promise<BurnDetails<EthTransaction>>;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    findBurn: (asset: string, eventEmitter: EventEmitterTyped<{
        transactionHash: [string];
    }>, transaction?: EthTransaction | undefined, burnNonce?: string | number | Buffer | undefined, config?: {
        networkDelay?: number;
    }) => Promise<BurnDetails<EthTransaction> | undefined>;
    getFees: (asset: string) => Promise<{
        burn: number;
        mint: number;
    }>;
    getBalance: (asset: string, address?: string | undefined) => Promise<BigNumber>;
    transactionRPCFormat: (transaction: EthTransaction, _v2?: boolean | undefined) => {
        txid: Buffer;
        txindex: string;
    };
    transactionRPCTxidFromID: (transactionID: string) => Buffer;
}
