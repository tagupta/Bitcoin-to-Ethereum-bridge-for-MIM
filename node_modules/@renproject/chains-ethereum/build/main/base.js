"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumBaseChain = exports.EthereumConfigMap = void 0;
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethers = __importStar(require("ethers"));
const networks_1 = require("./networks");
const utils_2 = require("./utils");
exports.EthereumConfigMap = {
    [interfaces_1.RenNetwork.Mainnet]: networks_1.renMainnet,
    [interfaces_1.RenNetwork.Testnet]: networks_1.renTestnet,
    [interfaces_1.RenNetwork.Devnet]: networks_1.renDevnet,
};
const isEthereumConfig = (renNetwork) => {
    return !!renNetwork.addresses;
};
const resolveNetwork = (renNetwork) => {
    if (!renNetwork) {
        return exports.EthereumConfigMap[interfaces_1.RenNetwork.Mainnet];
    }
    let networkConfig;
    if (renNetwork && isEthereumConfig(renNetwork)) {
        networkConfig = renNetwork;
    }
    else if (renNetwork) {
        const networkDetails = interfaces_1.getRenNetworkDetails(renNetwork);
        if (exports.EthereumConfigMap[networkDetails.name]) {
            networkConfig = exports.EthereumConfigMap[networkDetails.name];
        }
    }
    if (!networkConfig) {
        throw new Error(`Unrecognized network ${typeof renNetwork === "string" ? renNetwork : renNetwork.name}.`);
    }
    return networkConfig;
};
class EthereumBaseChain {
    constructor(web3Provider, renNetwork, config = {}) {
        this.chain = EthereumBaseChain.chain;
        this.name = EthereumBaseChain.chain;
        this.legacyName = "Eth";
        this.logRequestLimit = undefined;
        this.configMap = exports.EthereumConfigMap;
        this.utils = utils_1.utilsWithChainNetwork(EthereumBaseChain.utils, () => this.renNetworkDetails);
        this.getTokenContractAddress = async (asset) => {
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return utils_2.getTokenAddress(this.renNetworkDetails, this.provider, asset);
        };
        this.getGatewayContractAddress = async (token) => {
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const gatewayAddress = await utils_2.getGatewayAddress(this.renNetworkDetails, this.provider, token);
            if (gatewayAddress === "0x0000000000000000000000000000000000000000") {
                throw new Error(`Asset not supported on mint-chain.`);
            }
            return gatewayAddress;
        };
        this.withProvider = (web3Provider) => {
            if (web3Provider.signer && web3Provider.provider) {
                this.provider = web3Provider.provider;
                this.signer = web3Provider.signer;
            }
            else {
                const provider = web3Provider._isProvider
                    ? web3Provider
                    : new ethers.providers.Web3Provider(web3Provider);
                this.provider = provider;
                this.signer = provider.getSigner();
            }
            return this;
        };
        /**
         * See [LockChain.initialize].
         */
        this.initialize = (renNetwork) => {
            this.renNetworkDetails =
                this.renNetworkDetails ||
                    exports.EthereumConfigMap[interfaces_1.getRenNetworkDetails(renNetwork).name];
            if (!this.renNetworkDetails) {
                throw new Error(`Unable to set ${this.name} network for RenVM network ${interfaces_1.getRenNetworkDetails(renNetwork).name}. Please provide ${this.name} network details to ${this.name} constructor.`);
            }
            return this;
        };
        // Supported assets
        this.assetIsNative = (asset) => {
            return asset === "ETH";
        };
        /**
         * `assetIsSupported` should return true if the asset is native to the
         * MintChain.
         *
         * ```ts
         * ethereum.assetIsSupported = asset => asset === "ETH";
         * ```
         */
        this.assetIsSupported = async (asset) => {
            if (this.assetIsNative(asset)) {
                return true;
            }
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            // Check that there's a gateway contract for the asset.
            try {
                return !!(await this.getGatewayContractAddress(asset));
            }
            catch (error) {
                if (/(Empty address returned)|(Asset not supported on mint-chain)/.exec(String((error || {}).message))) {
                    // Ignore
                }
                else {
                    console.warn(error);
                }
                return false;
            }
        };
        /**
         * `assetDecimals` should return the number of decimals of the asset.
         *
         * If the asset is not supported, an error should be thrown.
         *
         
         */
        this.assetDecimals = async (asset) => {
            if (!this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (asset === "ETH") {
                return 18;
            }
            const tokenAddress = await this.getTokenContractAddress(asset);
            const decimalsABI = {
                constant: true,
                inputs: [],
                name: "decimals",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const tokenContract = new ethers.Contract(tokenAddress, [decimalsABI], this.provider);
            const decimalsRaw = await tokenContract.decimals();
            return new bignumber_js_1.default(decimalsRaw.toString()).toNumber();
        };
        this.transactionID = (transaction) => {
            return transaction || "";
        };
        this.transactionIDFromRPCFormat = (txid, txindex) => this.transactionID(this.transactionFromRPCFormat(txid, txindex));
        this.transactionFromRPCFormat = (txid, _txindex) => utils_1.Ox(txid);
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.transactionConfidence = async (transaction) => {
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (transaction === null) {
                throw new Error(`Unable to fetch transaction confidence, transaction hash is 'null'.`);
            }
            const currentBlock = new bignumber_js_1.default((await this.provider.getBlockNumber()).toString());
            const receipt = await this.provider.getTransactionReceipt(transaction);
            let current = 0;
            if (receipt.blockNumber) {
                const transactionBlock = new bignumber_js_1.default(receipt.blockNumber.toString());
                current = currentBlock.minus(transactionBlock).plus(1).toNumber();
            }
            return {
                current,
                target: this.renNetworkDetails.isTestnet ? 15 : 30,
            };
        };
        this.submitMint = async (asset, contractCalls, mintTx, eventEmitter) => {
            if (!mintTx.out) {
                throw new Error(`No signature passed to mint submission.`);
            }
            if (mintTx.out.revert !== undefined) {
                throw new Error(`Unable to submit reverted RenVM transaction.`);
            }
            if (!this.provider || !this.signer) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const existingTransaction = await this.findMint(asset, mintTx.out.nhash, mintTx.out.sighash);
            if (existingTransaction === "") {
                return "";
            }
            else if (existingTransaction) {
                eventEmitter.emit("transactionHash", existingTransaction);
                eventEmitter.emit("confirmation", 1, { status: 1 });
                return existingTransaction;
            }
            return await utils_2.submitToEthereum(this.signer, contractCalls, mintTx, eventEmitter);
        };
        this.findMint = async (asset, nHash, sigHash) => {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return utils_2.findMintBySigHash(this.renNetworkDetails, this.provider, asset, nHash, sigHash, this.logRequestLimit);
        };
        this.resolveTokenGatewayContract = async (asset) => {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return utils_1.Ox(await utils_2.getTokenAddress(this.renNetworkDetails, this.provider, asset));
        };
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.submitBurn = async (_asset, eventEmitter, contractCalls, config = {}) => {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            // Make a call to the provided contract and Pass on the
            // transaction hash.
            let transaction;
            for (let i = 0; i < contractCalls.length; i++) {
                const contractCall = contractCalls[i];
                const last = i === contractCalls.length - 1;
                const { contractParams, contractFn, sendTo } = contractCall;
                const callParams = [
                    ...(contractParams || []).map((value) => value.value),
                ];
                const ABI = utils_1.payloadToABI(contractFn, contractParams);
                const contract = new ethers.Contract(sendTo, ABI, this.signer);
                let txConfig = typeof contractCall === "object"
                    ? contractCall.txConfig
                    : {};
                txConfig = Object.assign(Object.assign({}, txConfig), {
                    value: txConfig && txConfig.value
                        ? txConfig.value.toString()
                        : undefined,
                    gasPrice: txConfig && txConfig.gasPrice
                        ? txConfig.gasPrice.toString()
                        : undefined,
                });
                if (this.logger) {
                    this.logger.debug("Calling Ethereum contract", contractFn, sendTo, ...callParams, txConfig);
                }
                const tx = await contract[contractFn](...callParams, txConfig);
                if (last) {
                    eventEmitter.emit("transactionHash", tx.hash);
                }
                const receipt = await tx.wait();
                transaction = receipt.transactionHash;
                if (this.logger) {
                    this.logger.debug("Transaction hash", transaction);
                }
            }
            if (!transaction) {
                throw new Error(`Unable to find burn from provided parameters.`);
            }
            return utils_2.extractBurnDetails(this.provider, transaction, this.logger, config.networkDelay);
        };
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.findBurn = async (asset, eventEmitter, 
        // Once of the following should not be undefined.
        transaction, burnNonce, config = {}) => {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (!transaction && burnNonce) {
                return utils_2.findBurnByNonce(this.renNetworkDetails, this.provider, asset, burnNonce.toString());
            }
            if (!transaction) {
                return undefined;
            }
            eventEmitter.emit("transactionHash", transaction);
            return utils_2.extractBurnDetails(this.provider, transaction, this.logger, config.networkDelay);
        };
        this.getFees = async (asset) => {
            if (!this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const gatewayAddress = await this.getGatewayContractAddress(asset);
            const mintFeeABI = {
                constant: true,
                inputs: [],
                name: "mintFee",
                outputs: [
                    {
                        internalType: "uint16",
                        name: "",
                        type: "uint16",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const burnFeeABI = {
                constant: true,
                inputs: [],
                name: "burnFee",
                outputs: [
                    {
                        internalType: "uint16",
                        name: "",
                        type: "uint16",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const gatewayContract = new ethers.Contract(gatewayAddress, [mintFeeABI, burnFeeABI], this.provider);
            const mintFee = await gatewayContract.mintFee();
            const burnFee = await gatewayContract.burnFee();
            return {
                mint: new bignumber_js_1.default(mintFee.toString()).toNumber(),
                burn: new bignumber_js_1.default(burnFee.toString()).toNumber(),
            };
        };
        this.getBalance = async (asset, address) => {
            const balanceOfABI = {
                constant: true,
                inputs: [
                    {
                        internalType: "address",
                        name: "account",
                        type: "address",
                    },
                ],
                name: "balanceOf",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            if (!this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const tokenAddress = await this.getTokenContractAddress(asset);
            const tokenContract = new ethers.Contract(tokenAddress, [balanceOfABI], this.provider);
            const balanceRaw = await await tokenContract.balanceOf(address);
            return new bignumber_js_1.default(balanceRaw.toString());
        };
        this.transactionRPCFormat = (transaction, _v2) => {
            utils_1.assertType("string | null", { transaction });
            if (transaction === null) {
                throw new Error(`Unable to encode transaction, transaction hash is 'null'.`);
            }
            return {
                txid: utils_1.fromHex(transaction),
                txindex: "0",
            };
        };
        this.transactionRPCTxidFromID = (transactionID) => utils_1.fromHex(transactionID);
        if (web3Provider) {
            /* eslint-disable @typescript-eslint/no-explicit-any */
            if (web3Provider.signer &&
                web3Provider.provider) {
                this.provider = web3Provider.provider;
                this.signer = web3Provider.signer;
            }
            else {
                const provider = web3Provider._isProvider
                    ? web3Provider
                    : new ethers.providers.Web3Provider(web3Provider);
                this.provider = provider;
                this.signer = provider.getSigner();
            }
        }
        if (renNetwork) {
            this.renNetworkDetails = resolveNetwork(renNetwork);
        }
        this.logger = config.logger;
    }
}
exports.EthereumBaseChain = EthereumBaseChain;
EthereumBaseChain.chain = "Ethereum";
EthereumBaseChain.configMap = exports.EthereumConfigMap;
EthereumBaseChain.utils = {
    resolveChainNetwork: resolveNetwork,
    addressIsValid: utils_2.addressIsValid,
    transactionIsValid: utils_2.transactionIsValid,
    addressExplorerLink: (address, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||
        networks_1.renMainnet).etherscan}/address/${address}`,
    transactionExplorerLink: (transaction, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||
        networks_1.renMainnet).etherscan}/tx/${transaction || ""}`,
};
const _ = EthereumBaseChain;
//# sourceMappingURL=base.js.map