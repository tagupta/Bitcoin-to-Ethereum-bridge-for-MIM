var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Callable, Ox } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { EthereumBaseChain } from "./base";
export class EthereumClass extends EthereumBaseChain {
    constructor(web3Provider, renNetwork, config = {}) {
        super(web3Provider, renNetwork, config);
        this.getMintParams = (asset) => this._getParams ? this._getParams(asset) : undefined;
        this.getBurnParams = (asset, burnPayload) => this._getParams ? this._getParams(asset, burnPayload) : undefined;
        /** @category Main */
        this.Address = (address, txConfig) => this.Account({ address }, txConfig);
        /** @category Main */
        this.Account = ({ value, address, }, txConfig) => {
            this._getParams = (asset, burnPayload) => __awaiter(this, void 0, void 0, function* () {
                if (!this.renNetworkDetails || !this.provider) {
                    throw new Error(`Ethereum must be initialized before calling 'getContractCalls'.`);
                }
                if (!value) {
                    // Mint
                    if (!address) {
                        throw new Error(`Must provide Ethereum recipient address.`);
                    }
                    // // Resolve .ens name
                    // if (/.*\.ens/.exec(address)) {
                    //     address = await this.provider.eth.ens.getAddress(address);
                    // }
                    return {
                        contractCalls: [
                            {
                                sendTo: this.renNetworkDetails.addresses
                                    .BasicAdapter,
                                contractFn: "mint",
                                contractParams: [
                                    {
                                        type: "string",
                                        name: "_symbol",
                                        value: asset,
                                    },
                                    {
                                        type: "address",
                                        name: "_address",
                                        value: address,
                                    },
                                ],
                                txConfig,
                            },
                        ],
                    };
                }
                else {
                    // Burn
                    if (!value) {
                        throw new Error(`Send amount must be provided in order to send directly to an address.`);
                    }
                    if (!burnPayload) {
                        throw new Error(`Must provide burn recipient address`);
                    }
                    const addressToBuffer = Buffer.from(burnPayload);
                    const gateway = yield this.getGatewayContractAddress(asset);
                    return {
                        contractCalls: [
                            {
                                sendTo: gateway,
                                contractFn: "burn",
                                contractParams: [
                                    {
                                        type: "bytes",
                                        name: "_to",
                                        value: Ox(addressToBuffer),
                                    },
                                    {
                                        type: "uint256",
                                        name: "_amount",
                                        value: new BigNumber(value).toFixed(),
                                    },
                                ],
                                txConfig,
                            },
                        ],
                    };
                }
            });
            return this;
        };
        /** @category Main */
        this.Contract = (contractCall) => {
            this._getParams = (asset, burnPayload) => {
                if (!this.renNetworkDetails) {
                    throw new Error(`Ethereum must be initialized before calling 'getContractCalls'`);
                }
                if (typeof contractCall === "function") {
                    if (!burnPayload) {
                        throw new Error(`Must provide burn payload`);
                    }
                    const addressToBuffer = Buffer.from(burnPayload);
                    return {
                        contractCalls: [contractCall(Ox(addressToBuffer), asset)],
                    };
                }
                else {
                    return { contractCalls: [contractCall] };
                }
            };
            return this;
        };
        /** @category Main */
        this.Transaction = (transaction) => {
            this._getParams = (_asset, _burnPayload) => {
                return {
                    transaction,
                };
            };
            return this;
        };
        /** @category Main */
        this.BurnNonce = (burnNonce) => {
            this._getParams = (_asset, _burnPayload) => {
                return {
                    burnNonce,
                };
            };
            return this;
        };
        this.toWei = (value) => new BigNumber(value)
            .times(new BigNumber(10).exponentiatedBy(18))
            .decimalPlaces(0)
            .toFixed();
        this.fromWei = (value) => new BigNumber(value)
            .dividedBy(new BigNumber(10).exponentiatedBy(18))
            .toFixed();
    }
}
// @dev Removes any static fields, except `utils`.
export const Ethereum = Callable(EthereumClass);
//# sourceMappingURL=ethereum.js.map