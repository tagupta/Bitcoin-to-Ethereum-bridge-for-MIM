import { getRenNetworkDetails, RenNetwork, } from "@renproject/interfaces";
import { Callable, utilsWithChainNetwork } from "@renproject/utils";
import { EthereumClass } from "./ethereum";
import { StandardExplorer } from "./networks";
import { addressIsValid, transactionIsValid } from "./utils";
export const renGoerli = {
    name: "Görli Testnet",
    chain: "goerliTestnet",
    isTestnet: true,
    chainLabel: "Görli Testnet",
    networkID: 6284,
    addresses: {
        GatewayRegistry: "0xD881213F5ABF783d93220e6bD3Cc21706A8dc1fC",
        BasicAdapter: "0xD087b0540e172553c12DEEeCDEf3dFD21Ec02066",
    },
    publicProvider: ({ infura } = {}) => `https://goerli.infura.io/v3/${infura || ""}`,
    explorer: StandardExplorer("https://goerli.etherscan.io"),
    /** @deprecated Renamed to publicProvider. Will be removed in 3.0.0. */
    infura: "https://goerli.infura.io",
    /** @deprecated Renamed to explorer. Will be removed in 3.0.0. */
    etherscan: "https://goerli.etherscan.io",
};
export const GoerliConfigMap = {
    [RenNetwork.Testnet]: renGoerli,
};
const resolveGoerliNetwork = (renNetwork) => {
    if (!renNetwork) {
        return renGoerli;
    }
    if (renNetwork.addresses) {
        return renNetwork;
    }
    else {
        const details = getRenNetworkDetails(
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        renNetwork);
        if (!details.isTestnet) {
            throw new Error(`Goerli not supported on mainnet.`);
        }
        return renGoerli;
    }
};
export class GoerliClass extends EthereumClass {
    constructor(web3Provider, renNetwork, config = {}) {
        // To be compatible with the Ethereum chain class, the first parameter
        // is a web3Provider and the second the RenVM network.
        super(web3Provider, resolveGoerliNetwork(renNetwork), config);
        this.chain = GoerliClass.chain;
        this.name = GoerliClass.chain;
        this.legacyName = undefined;
        this.configMap = GoerliConfigMap;
        this.utils = utilsWithChainNetwork(GoerliClass.utils, () => this.renNetworkDetails);
        this.initialize = (renNetwork) => {
            this.renNetworkDetails =
                this.renNetworkDetails ||
                    GoerliConfigMap[getRenNetworkDetails(renNetwork).name];
            if (!this.renNetworkDetails) {
                throw new Error(`Unable to set ${this.name} network for RenVM network ${getRenNetworkDetails(renNetwork).name}. Please provide ${this.name} network details to ${this.name} constructor.`);
            }
            return this;
        };
    }
}
GoerliClass.chain = "Goerli";
// public logRequestLimit = 1000;
GoerliClass.configMap = GoerliConfigMap;
GoerliClass.utils = {
    resolveChainNetwork: resolveGoerliNetwork,
    addressIsValid,
    transactionIsValid,
    addressExplorerLink: (address, network) => `${(Goerli.utils.resolveChainNetwork(network) || renGoerli)
        .etherscan}/address/${address}`,
    transactionExplorerLink: (transaction, network) => `${(Goerli.utils.resolveChainNetwork(network) || renGoerli)
        .etherscan}/tx/${transaction || ""}`,
};
// @dev Removes any static fields, except `utils`.
export const Goerli = Callable(GoerliClass);
//# sourceMappingURL=goerli.js.map