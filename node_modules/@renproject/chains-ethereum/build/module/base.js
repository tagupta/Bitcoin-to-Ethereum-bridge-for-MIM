var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getRenNetworkDetails, RenNetwork, } from "@renproject/interfaces";
import { assertType, fromHex, Ox, payloadToABI, utilsWithChainNetwork, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import * as ethers from "ethers";
import { renDevnet, renMainnet, renTestnet } from "./networks";
import { addressIsValid, transactionIsValid, extractBurnDetails, findBurnByNonce, findMintBySigHash, getGatewayAddress, getTokenAddress, submitToEthereum, } from "./utils";
export const EthereumConfigMap = {
    [RenNetwork.Mainnet]: renMainnet,
    [RenNetwork.Testnet]: renTestnet,
    [RenNetwork.Devnet]: renDevnet,
};
const isEthereumConfig = (renNetwork) => {
    return !!renNetwork.addresses;
};
const resolveNetwork = (renNetwork) => {
    if (!renNetwork) {
        return EthereumConfigMap[RenNetwork.Mainnet];
    }
    let networkConfig;
    if (renNetwork && isEthereumConfig(renNetwork)) {
        networkConfig = renNetwork;
    }
    else if (renNetwork) {
        const networkDetails = getRenNetworkDetails(renNetwork);
        if (EthereumConfigMap[networkDetails.name]) {
            networkConfig = EthereumConfigMap[networkDetails.name];
        }
    }
    if (!networkConfig) {
        throw new Error(`Unrecognized network ${typeof renNetwork === "string" ? renNetwork : renNetwork.name}.`);
    }
    return networkConfig;
};
export class EthereumBaseChain {
    constructor(web3Provider, renNetwork, config = {}) {
        this.chain = EthereumBaseChain.chain;
        this.name = EthereumBaseChain.chain;
        this.legacyName = "Eth";
        this.logRequestLimit = undefined;
        this.configMap = EthereumConfigMap;
        this.utils = utilsWithChainNetwork(EthereumBaseChain.utils, () => this.renNetworkDetails);
        this.getTokenContractAddress = (asset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return getTokenAddress(this.renNetworkDetails, this.provider, asset);
        });
        this.getGatewayContractAddress = (token) => __awaiter(this, void 0, void 0, function* () {
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const gatewayAddress = yield getGatewayAddress(this.renNetworkDetails, this.provider, token);
            if (gatewayAddress === "0x0000000000000000000000000000000000000000") {
                throw new Error(`Asset not supported on mint-chain.`);
            }
            return gatewayAddress;
        });
        this.withProvider = (web3Provider) => {
            if (web3Provider.signer && web3Provider.provider) {
                this.provider = web3Provider.provider;
                this.signer = web3Provider.signer;
            }
            else {
                const provider = web3Provider._isProvider
                    ? web3Provider
                    : new ethers.providers.Web3Provider(web3Provider);
                this.provider = provider;
                this.signer = provider.getSigner();
            }
            return this;
        };
        /**
         * See [LockChain.initialize].
         */
        this.initialize = (renNetwork) => {
            this.renNetworkDetails =
                this.renNetworkDetails ||
                    EthereumConfigMap[getRenNetworkDetails(renNetwork).name];
            if (!this.renNetworkDetails) {
                throw new Error(`Unable to set ${this.name} network for RenVM network ${getRenNetworkDetails(renNetwork).name}. Please provide ${this.name} network details to ${this.name} constructor.`);
            }
            return this;
        };
        // Supported assets
        this.assetIsNative = (asset) => {
            return asset === "ETH";
        };
        /**
         * `assetIsSupported` should return true if the asset is native to the
         * MintChain.
         *
         * ```ts
         * ethereum.assetIsSupported = asset => asset === "ETH";
         * ```
         */
        this.assetIsSupported = (asset) => __awaiter(this, void 0, void 0, function* () {
            if (this.assetIsNative(asset)) {
                return true;
            }
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            // Check that there's a gateway contract for the asset.
            try {
                return !!(yield this.getGatewayContractAddress(asset));
            }
            catch (error) {
                if (/(Empty address returned)|(Asset not supported on mint-chain)/.exec(String((error || {}).message))) {
                    // Ignore
                }
                else {
                    console.warn(error);
                }
                return false;
            }
        });
        /**
         * `assetDecimals` should return the number of decimals of the asset.
         *
         * If the asset is not supported, an error should be thrown.
         *
         
         */
        this.assetDecimals = (asset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (asset === "ETH") {
                return 18;
            }
            const tokenAddress = yield this.getTokenContractAddress(asset);
            const decimalsABI = {
                constant: true,
                inputs: [],
                name: "decimals",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const tokenContract = new ethers.Contract(tokenAddress, [decimalsABI], this.provider);
            const decimalsRaw = yield tokenContract.decimals();
            return new BigNumber(decimalsRaw.toString()).toNumber();
        });
        this.transactionID = (transaction) => {
            return transaction || "";
        };
        this.transactionIDFromRPCFormat = (txid, txindex) => this.transactionID(this.transactionFromRPCFormat(txid, txindex));
        this.transactionFromRPCFormat = (txid, _txindex) => Ox(txid);
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {
            if (!this.provider || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (transaction === null) {
                throw new Error(`Unable to fetch transaction confidence, transaction hash is 'null'.`);
            }
            const currentBlock = new BigNumber((yield this.provider.getBlockNumber()).toString());
            const receipt = yield this.provider.getTransactionReceipt(transaction);
            let current = 0;
            if (receipt.blockNumber) {
                const transactionBlock = new BigNumber(receipt.blockNumber.toString());
                current = currentBlock.minus(transactionBlock).plus(1).toNumber();
            }
            return {
                current,
                target: this.renNetworkDetails.isTestnet ? 15 : 30,
            };
        });
        this.submitMint = (asset, contractCalls, mintTx, eventEmitter) => __awaiter(this, void 0, void 0, function* () {
            if (!mintTx.out) {
                throw new Error(`No signature passed to mint submission.`);
            }
            if (mintTx.out.revert !== undefined) {
                throw new Error(`Unable to submit reverted RenVM transaction.`);
            }
            if (!this.provider || !this.signer) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const existingTransaction = yield this.findMint(asset, mintTx.out.nhash, mintTx.out.sighash);
            if (existingTransaction === "") {
                return "";
            }
            else if (existingTransaction) {
                eventEmitter.emit("transactionHash", existingTransaction);
                eventEmitter.emit("confirmation", 1, { status: 1 });
                return existingTransaction;
            }
            return yield submitToEthereum(this.signer, contractCalls, mintTx, eventEmitter);
        });
        this.findMint = (asset, nHash, sigHash) => __awaiter(this, void 0, void 0, function* () {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return findMintBySigHash(this.renNetworkDetails, this.provider, asset, nHash, sigHash, this.logRequestLimit);
        });
        this.resolveTokenGatewayContract = (asset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return Ox(yield getTokenAddress(this.renNetworkDetails, this.provider, asset));
        });
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.submitBurn = (_asset, eventEmitter, contractCalls, config = {}) => __awaiter(this, void 0, void 0, function* () {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            // Make a call to the provided contract and Pass on the
            // transaction hash.
            let transaction;
            for (let i = 0; i < contractCalls.length; i++) {
                const contractCall = contractCalls[i];
                const last = i === contractCalls.length - 1;
                const { contractParams, contractFn, sendTo } = contractCall;
                const callParams = [
                    ...(contractParams || []).map((value) => value.value),
                ];
                const ABI = payloadToABI(contractFn, contractParams);
                const contract = new ethers.Contract(sendTo, ABI, this.signer);
                let txConfig = typeof contractCall === "object"
                    ? contractCall.txConfig
                    : {};
                txConfig = Object.assign(Object.assign({}, txConfig), {
                    value: txConfig && txConfig.value
                        ? txConfig.value.toString()
                        : undefined,
                    gasPrice: txConfig && txConfig.gasPrice
                        ? txConfig.gasPrice.toString()
                        : undefined,
                });
                if (this.logger) {
                    this.logger.debug("Calling Ethereum contract", contractFn, sendTo, ...callParams, txConfig);
                }
                const tx = yield contract[contractFn](...callParams, txConfig);
                if (last) {
                    eventEmitter.emit("transactionHash", tx.hash);
                }
                const receipt = yield tx.wait();
                transaction = receipt.transactionHash;
                if (this.logger) {
                    this.logger.debug("Transaction hash", transaction);
                }
            }
            if (!transaction) {
                throw new Error(`Unable to find burn from provided parameters.`);
            }
            return extractBurnDetails(this.provider, transaction, this.logger, config.networkDelay);
        });
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.findBurn = (asset, eventEmitter, 
        // Once of the following should not be undefined.
        transaction, burnNonce, config = {}) => __awaiter(this, void 0, void 0, function* () {
            if (!this.renNetworkDetails || !this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (!transaction && burnNonce) {
                return findBurnByNonce(this.renNetworkDetails, this.provider, asset, burnNonce.toString());
            }
            if (!transaction) {
                return undefined;
            }
            eventEmitter.emit("transactionHash", transaction);
            return extractBurnDetails(this.provider, transaction, this.logger, config.networkDelay);
        });
        this.getFees = (asset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const gatewayAddress = yield this.getGatewayContractAddress(asset);
            const mintFeeABI = {
                constant: true,
                inputs: [],
                name: "mintFee",
                outputs: [
                    {
                        internalType: "uint16",
                        name: "",
                        type: "uint16",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const burnFeeABI = {
                constant: true,
                inputs: [],
                name: "burnFee",
                outputs: [
                    {
                        internalType: "uint16",
                        name: "",
                        type: "uint16",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const gatewayContract = new ethers.Contract(gatewayAddress, [mintFeeABI, burnFeeABI], this.provider);
            const mintFee = yield gatewayContract.mintFee();
            const burnFee = yield gatewayContract.burnFee();
            return {
                mint: new BigNumber(mintFee.toString()).toNumber(),
                burn: new BigNumber(burnFee.toString()).toNumber(),
            };
        });
        this.getBalance = (asset, address) => __awaiter(this, void 0, void 0, function* () {
            const balanceOfABI = {
                constant: true,
                inputs: [
                    {
                        internalType: "address",
                        name: "account",
                        type: "address",
                    },
                ],
                name: "balanceOf",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            if (!this.provider) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const tokenAddress = yield this.getTokenContractAddress(asset);
            const tokenContract = new ethers.Contract(tokenAddress, [balanceOfABI], this.provider);
            const balanceRaw = yield yield tokenContract.balanceOf(address);
            return new BigNumber(balanceRaw.toString());
        });
        this.transactionRPCFormat = (transaction, _v2) => {
            assertType("string | null", { transaction });
            if (transaction === null) {
                throw new Error(`Unable to encode transaction, transaction hash is 'null'.`);
            }
            return {
                txid: fromHex(transaction),
                txindex: "0",
            };
        };
        this.transactionRPCTxidFromID = (transactionID) => fromHex(transactionID);
        if (web3Provider) {
            /* eslint-disable @typescript-eslint/no-explicit-any */
            if (web3Provider.signer &&
                web3Provider.provider) {
                this.provider = web3Provider.provider;
                this.signer = web3Provider.signer;
            }
            else {
                const provider = web3Provider._isProvider
                    ? web3Provider
                    : new ethers.providers.Web3Provider(web3Provider);
                this.provider = provider;
                this.signer = provider.getSigner();
            }
        }
        if (renNetwork) {
            this.renNetworkDetails = resolveNetwork(renNetwork);
        }
        this.logger = config.logger;
    }
}
EthereumBaseChain.chain = "Ethereum";
EthereumBaseChain.configMap = EthereumConfigMap;
EthereumBaseChain.utils = {
    resolveChainNetwork: resolveNetwork,
    addressIsValid,
    transactionIsValid,
    addressExplorerLink: (address, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||
        renMainnet).etherscan}/address/${address}`,
    transactionExplorerLink: (transaction, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||
        renMainnet).etherscan}/tx/${transaction || ""}`,
};
const _ = EthereumBaseChain;
//# sourceMappingURL=base.js.map