var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import bech32 from "bech32";
import { getRenNetworkDetails, } from "@renproject/interfaces";
import { assertType, Callable, isHex, utilsWithChainNetwork, } from "@renproject/utils";
import { AccAddress, Key } from "@terra-money/terra.js";
import elliptic from "elliptic";
import { TerraNetwork, transactionToDeposit, UNSUPPORTED_TERRA_NETWORK, } from "./api/deposit";
import { terraDev } from "./api/terraDev";
const resolveTerraNetwork = (network) => {
    if (network === TerraNetwork.Columbus || network === TerraNetwork.Tequila) {
        return network;
    }
    const renNetwork = getRenNetworkDetails(network);
    // Prioritize the network passed in to the constructor.
    return renNetwork.isTestnet ? TerraNetwork.Tequila : TerraNetwork.Columbus;
};
export var TerraAssets;
(function (TerraAssets) {
    TerraAssets["LUNA"] = "LUNA";
})(TerraAssets || (TerraAssets = {}));
/**
 * TerraClass implements the LockChain interface for Terra (https://terra.money)
 * and it's asset LUNA.
 */
export class TerraClass {
    constructor(network) {
        this.chain = TerraClass.chain;
        this.name = TerraClass.chain;
        // The assets native to Terra.
        this.assets = [TerraAssets.LUNA];
        this.utils = utilsWithChainNetwork(TerraClass.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet
                        ? TerraNetwork.Tequila
                        : TerraNetwork.Columbus);
            return this;
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => this.assets.indexOf(asset) >= 0;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Unsupported asset ${asset}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            switch (asset) {
                case TerraAssets.LUNA:
                    return 6;
            }
            throw new Error(`Unsupported asset ${String(asset)}.`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = (asset, address, _instanceID, onDeposit) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            this.assertAssetIsSupported(asset);
            const txs = yield terraDev.fetchDeposits(address.address, this.chainNetwork);
            yield Promise.all(txs.map((tx) => __awaiter(this, void 0, void 0, function* () { return onDeposit(transactionToDeposit(tx)); })));
        });
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            transaction = yield terraDev.fetchDeposit(transaction.hash, transaction.messageIndex, this.chainNetwork);
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === TerraNetwork.Columbus ? 0 : 0,
            };
        });
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, compressedPublicKey, gHash) => {
            if (!this.renNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            this.assertAssetIsSupported(asset);
            const ec = new elliptic.ec("secp256k1");
            // Decode compressed RenVM public key.
            const renVMPublicKey = ec.keyFromPublic(compressedPublicKey);
            // Interpret gHash as a private key.
            const gHashKey = ec.keyFromPrivate(gHash);
            // If `NO_PARAMS_FLAG` is set, set renVM public key and gHash public key,
            // and recreate key pair from resulting curve point.
            const derivedPublicKey = ec.keyFromPublic(renVMPublicKey
                .getPublic()
                .add(gHashKey.getPublic()));
            const newCompressedPublicKey = Buffer.from(derivedPublicKey.getPublic().encodeCompressed());
            // @ts-expect-error `Cannot create an instance of an abstract class`
            const address = new Key(newCompressedPublicKey);
            return {
                asset,
                address: address.accAddress,
                // memo: toURLBase64(gHash),
            };
        };
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.addressToBytes = (address) => Buffer.from(bech32.fromWords(bech32.decode(typeof address === "string" ? address : address.address).words));
        /**
         * See [[LockChain.bytesToAddress]].
         */
        this.bytesToAddress = (address) => {
            const words = bech32.toWords(address);
            return bech32.encode("terra", words);
        };
        /** @deprecated. Renamed to addressToBytes. */
        this.addressStringToBytes = this.addressToBytes;
        this.addressToString = (address) => typeof address === "string" ? address : address.address;
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.hash;
        this.transactionIDFromRPCFormat = (txid, _txindex) => typeof txid === "string" ? txid : txid.toString("hex");
        this.transactionFromRPCFormat = (txid, txindex) => __awaiter(this, void 0, void 0, function* () {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            return terraDev.fetchDeposit(typeof txid === "string" ? txid : txid.toString("hex"), parseInt(txindex, 10), this.chainNetwork);
        });
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.depositV1HashString = (_deposit) => {
            throw new Error(UNSUPPORTED_TERRA_NETWORK);
        };
        this.transactionRPCFormat = (transaction, v2) => {
            if (!v2) {
                throw new Error(UNSUPPORTED_TERRA_NETWORK);
            }
            return {
                txid: Buffer.from(transaction.hash, "hex"),
                txindex: "0",
            };
        };
        this.transactionRPCTxidFromID = (transactionID) => Buffer.from(transactionID, "hex");
        this.Address = (address) => {
            // Type validation
            assertType("string", { address });
            this.getBurnPayload = (bytes) => bytes ? this.addressToBytes(address).toString("hex") : address;
            return this;
        };
        this.burnPayload = (config) => {
            return this.getBurnPayload
                ? this.getBurnPayload(config && config.bytes)
                : undefined;
        };
        this.chainNetwork = network;
    }
}
TerraClass.chain = "Terra";
TerraClass.utils = {
    resolveChainNetwork: resolveTerraNetwork,
    addressIsValid: (addressIn, _network = TerraNetwork.Columbus) => {
        const address = typeof addressIn === "string" ? addressIn : addressIn.address;
        assertType("string", { address: address });
        return AccAddress.validate(address);
    },
    transactionIsValid: (transaction, _network = TerraNetwork.Columbus) => {
        return isHex(typeof transaction === "string"
            ? transaction
            : transaction.hash, { length: 32 });
    },
    addressExplorerLink: (addressIn, network = TerraNetwork.Columbus) => {
        return `https://finder.terra.money/${Terra.utils.resolveChainNetwork(network)}/account/${typeof addressIn === "string" ? addressIn : addressIn.address}`;
    },
    transactionExplorerLink: (transaction, network = TerraNetwork.Columbus) => {
        return `https://finder.terra.money/${Terra.utils.resolveChainNetwork(network)}/tx/${typeof transaction === "string" ? transaction : transaction.hash}`;
    },
};
// @dev Removes any static fields, except `utils`.
export const Terra = Callable(TerraClass);
const _ = Terra;
//# sourceMappingURL=terra.js.map