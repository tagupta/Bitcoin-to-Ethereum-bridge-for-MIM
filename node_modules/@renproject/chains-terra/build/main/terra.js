"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Terra = exports.TerraClass = exports.TerraAssets = void 0;
const bech32_1 = __importDefault(require("bech32"));
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const terra_js_1 = require("@terra-money/terra.js");
const elliptic_1 = __importDefault(require("elliptic"));
const deposit_1 = require("./api/deposit");
const terraDev_1 = require("./api/terraDev");
const resolveTerraNetwork = (network) => {
    if (network === deposit_1.TerraNetwork.Columbus || network === deposit_1.TerraNetwork.Tequila) {
        return network;
    }
    const renNetwork = interfaces_1.getRenNetworkDetails(network);
    // Prioritize the network passed in to the constructor.
    return renNetwork.isTestnet ? deposit_1.TerraNetwork.Tequila : deposit_1.TerraNetwork.Columbus;
};
var TerraAssets;
(function (TerraAssets) {
    TerraAssets["LUNA"] = "LUNA";
})(TerraAssets = exports.TerraAssets || (exports.TerraAssets = {}));
/**
 * TerraClass implements the LockChain interface for Terra (https://terra.money)
 * and it's asset LUNA.
 */
class TerraClass {
    constructor(network) {
        this.chain = TerraClass.chain;
        this.name = TerraClass.chain;
        // The assets native to Terra.
        this.assets = [TerraAssets.LUNA];
        this.utils = utils_1.utilsWithChainNetwork(TerraClass.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = interfaces_1.getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet
                        ? deposit_1.TerraNetwork.Tequila
                        : deposit_1.TerraNetwork.Columbus);
            return this;
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => this.assets.indexOf(asset) >= 0;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Unsupported asset ${asset}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            switch (asset) {
                case TerraAssets.LUNA:
                    return 6;
            }
            throw new Error(`Unsupported asset ${String(asset)}.`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = async (asset, address, _instanceID, onDeposit) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            this.assertAssetIsSupported(asset);
            const txs = await terraDev_1.terraDev.fetchDeposits(address.address, this.chainNetwork);
            await Promise.all(txs.map(async (tx) => onDeposit(deposit_1.transactionToDeposit(tx))));
        };
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = async (transaction) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            transaction = await terraDev_1.terraDev.fetchDeposit(transaction.hash, transaction.messageIndex, this.chainNetwork);
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === deposit_1.TerraNetwork.Columbus ? 0 : 0,
            };
        };
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, compressedPublicKey, gHash) => {
            if (!this.renNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            this.assertAssetIsSupported(asset);
            const ec = new elliptic_1.default.ec("secp256k1");
            // Decode compressed RenVM public key.
            const renVMPublicKey = ec.keyFromPublic(compressedPublicKey);
            // Interpret gHash as a private key.
            const gHashKey = ec.keyFromPrivate(gHash);
            // If `NO_PARAMS_FLAG` is set, set renVM public key and gHash public key,
            // and recreate key pair from resulting curve point.
            const derivedPublicKey = ec.keyFromPublic(renVMPublicKey
                .getPublic()
                .add(gHashKey.getPublic()));
            const newCompressedPublicKey = Buffer.from(derivedPublicKey.getPublic().encodeCompressed());
            // @ts-expect-error `Cannot create an instance of an abstract class`
            const address = new terra_js_1.Key(newCompressedPublicKey);
            return {
                asset,
                address: address.accAddress,
                // memo: toURLBase64(gHash),
            };
        };
        /**
         * See [[LockChain.addressToBytes]].
         */
        this.addressToBytes = (address) => Buffer.from(bech32_1.default.fromWords(bech32_1.default.decode(typeof address === "string" ? address : address.address).words));
        /**
         * See [[LockChain.bytesToAddress]].
         */
        this.bytesToAddress = (address) => {
            const words = bech32_1.default.toWords(address);
            return bech32_1.default.encode("terra", words);
        };
        /** @deprecated. Renamed to addressToBytes. */
        this.addressStringToBytes = this.addressToBytes;
        this.addressToString = (address) => typeof address === "string" ? address : address.address;
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.hash;
        this.transactionIDFromRPCFormat = (txid, _txindex) => typeof txid === "string" ? txid : txid.toString("hex");
        this.transactionFromRPCFormat = async (txid, txindex) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized.`);
            }
            return terraDev_1.terraDev.fetchDeposit(typeof txid === "string" ? txid : txid.toString("hex"), parseInt(txindex, 10), this.chainNetwork);
        };
        /**
         * @deprecated Renamed to `transactionFromRPCFormat`.
         * Will be removed in 3.0.0.
         */
        this.transactionFromID = this.transactionFromRPCFormat;
        this.depositV1HashString = (_deposit) => {
            throw new Error(deposit_1.UNSUPPORTED_TERRA_NETWORK);
        };
        this.transactionRPCFormat = (transaction, v2) => {
            if (!v2) {
                throw new Error(deposit_1.UNSUPPORTED_TERRA_NETWORK);
            }
            return {
                txid: Buffer.from(transaction.hash, "hex"),
                txindex: "0",
            };
        };
        this.transactionRPCTxidFromID = (transactionID) => Buffer.from(transactionID, "hex");
        this.Address = (address) => {
            // Type validation
            utils_1.assertType("string", { address });
            this.getBurnPayload = (bytes) => bytes ? this.addressToBytes(address).toString("hex") : address;
            return this;
        };
        this.burnPayload = (config) => {
            return this.getBurnPayload
                ? this.getBurnPayload(config && config.bytes)
                : undefined;
        };
        this.chainNetwork = network;
    }
}
exports.TerraClass = TerraClass;
TerraClass.chain = "Terra";
TerraClass.utils = {
    resolveChainNetwork: resolveTerraNetwork,
    addressIsValid: (addressIn, _network = deposit_1.TerraNetwork.Columbus) => {
        const address = typeof addressIn === "string" ? addressIn : addressIn.address;
        utils_1.assertType("string", { address: address });
        return terra_js_1.AccAddress.validate(address);
    },
    transactionIsValid: (transaction, _network = deposit_1.TerraNetwork.Columbus) => {
        return utils_1.isHex(typeof transaction === "string"
            ? transaction
            : transaction.hash, { length: 32 });
    },
    addressExplorerLink: (addressIn, network = deposit_1.TerraNetwork.Columbus) => {
        return `https://finder.terra.money/${exports.Terra.utils.resolveChainNetwork(network)}/account/${typeof addressIn === "string" ? addressIn : addressIn.address}`;
    },
    transactionExplorerLink: (transaction, network = deposit_1.TerraNetwork.Columbus) => {
        return `https://finder.terra.money/${exports.Terra.utils.resolveChainNetwork(network)}/tx/${typeof transaction === "string" ? transaction : transaction.hash}`;
    },
};
// @dev Removes any static fields, except `utils`.
exports.Terra = utils_1.Callable(TerraClass);
const _ = exports.Terra;
//# sourceMappingURL=terra.js.map